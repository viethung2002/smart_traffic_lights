
c6t6.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   0000010c  08000000  08000000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00006d10  08000110  08000110  00001110  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       0000015c  08006e20  08006e20  00007e20  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  08006f7c  08006f7c  00008084  2**0
                  CONTENTS, READONLY
  4 .ARM          00000000  08006f7c  08006f7c  00008084  2**0
                  CONTENTS, READONLY
  5 .preinit_array 00000000  08006f7c  08006f7c  00008084  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  08006f7c  08006f7c  00007f7c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .fini_array   00000004  08006f80  08006f80  00007f80  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .data         00000084  20000000  08006f84  00008000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          00001f04  20000088  08007008  00008088  2**3
                  ALLOC
 10 ._user_heap_stack 00000604  20001f8c  08007008  00008f8c  2**0
                  ALLOC
 11 .ARM.attributes 00000029  00000000  00000000  00008084  2**0
                  CONTENTS, READONLY
 12 .debug_info   0002c96c  00000000  00000000  000080ad  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_abbrev 00004caf  00000000  00000000  00034a19  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_aranges 00001530  00000000  00000000  000396c8  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_rnglists 0000354a  00000000  00000000  0003abf8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_line   0002a45a  00000000  00000000  0003e142  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_str    00007b73  00000000  00000000  0006859c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .comment      00000043  00000000  00000000  0007010f  2**0
                  CONTENTS, READONLY
 19 .debug_frame  000046cc  00000000  00000000  00070154  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_loclists 00020552  00000000  00000000  00074820  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_line_str 000000a0  00000000  00000000  00094d72  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

08000110 <__do_global_dtors_aux>:
 8000110:	b510      	push	{r4, lr}
 8000112:	4c05      	ldr	r4, [pc, #20]	@ (8000128 <__do_global_dtors_aux+0x18>)
 8000114:	7823      	ldrb	r3, [r4, #0]
 8000116:	b933      	cbnz	r3, 8000126 <__do_global_dtors_aux+0x16>
 8000118:	4b04      	ldr	r3, [pc, #16]	@ (800012c <__do_global_dtors_aux+0x1c>)
 800011a:	b113      	cbz	r3, 8000122 <__do_global_dtors_aux+0x12>
 800011c:	4804      	ldr	r0, [pc, #16]	@ (8000130 <__do_global_dtors_aux+0x20>)
 800011e:	f3af 8000 	nop.w
 8000122:	2301      	movs	r3, #1
 8000124:	7023      	strb	r3, [r4, #0]
 8000126:	bd10      	pop	{r4, pc}
 8000128:	20000088 	.word	0x20000088
 800012c:	00000000 	.word	0x00000000
 8000130:	08006e08 	.word	0x08006e08

08000134 <frame_dummy>:
 8000134:	b508      	push	{r3, lr}
 8000136:	4b03      	ldr	r3, [pc, #12]	@ (8000144 <frame_dummy+0x10>)
 8000138:	b11b      	cbz	r3, 8000142 <frame_dummy+0xe>
 800013a:	4903      	ldr	r1, [pc, #12]	@ (8000148 <frame_dummy+0x14>)
 800013c:	4803      	ldr	r0, [pc, #12]	@ (800014c <frame_dummy+0x18>)
 800013e:	f3af 8000 	nop.w
 8000142:	bd08      	pop	{r3, pc}
 8000144:	00000000 	.word	0x00000000
 8000148:	2000008c 	.word	0x2000008c
 800014c:	08006e08 	.word	0x08006e08

08000150 <SEGGER_RTT_ASM_WriteSkipNoLock>:
        //   R4 <Rem>
        //   R5 pRing->pBuffer
        //   R6 pRing (Points to active struct SEGGER_RTT_BUFFER_DOWN)
        //   R7 WrOff
        //
        PUSH     {R4-R7}
 8000150:	b4f0      	push	{r4, r5, r6, r7}
        ADD      R3,R0,R0, LSL #+1
 8000152:	eb00 0340 	add.w	r3, r0, r0, lsl #1
        LDR.W    R0,=_SEGGER_RTT                 // pRing = &_SEGGER_RTT.aUp[BufferIndex];
 8000156:	f8df 0080 	ldr.w	r0, [pc, #128]	@ 80001d8 <_Case3+0x6>
        ADD      R0,R0,R3, LSL #+3
 800015a:	eb00 00c3 	add.w	r0, r0, r3, lsl #3
        ADD      R6,R0,#+24
 800015e:	f100 0618 	add.w	r6, r0, #24
        LDR      R0,[R6, #+16]                   // RdOff = pRing->RdOff;
 8000162:	6930      	ldr	r0, [r6, #16]
        LDR      R7,[R6, #+12]                   // WrOff = pRing->WrOff;
 8000164:	68f7      	ldr	r7, [r6, #12]
        LDR      R5,[R6, #+4]                    // pRing->pBuffer
 8000166:	6875      	ldr	r5, [r6, #4]
        CMP      R7,R0
 8000168:	4287      	cmp	r7, r0
        BCC.N    _CheckCase4                     // if (RdOff <= WrOff) {                           => Case 1), 2) or 3)
 800016a:	d32e      	bcc.n	80001ca <_CheckCase4>
        //
        // Handling for case 1, later on identical to case 4
        //
        LDR      R3,[R6, #+8]                    //  Avail = pRing->SizeOfBuffer - WrOff - 1u;      => Space until wrap-around (assume 1 byte not usable for case that RdOff == 0)
 800016c:	68b3      	ldr	r3, [r6, #8]
        SUBS     R4,R3,R7                        // <Rem> (Used in case we jump into case 2 afterwards)
 800016e:	1bdc      	subs	r4, r3, r7
        SUBS     R3,R4,#+1                       // <Avail>
 8000170:	1e63      	subs	r3, r4, #1
        CMP      R3,R2
 8000172:	4293      	cmp	r3, r2
        BCC.N    _CheckCase2                     // if (Avail >= NumBytes) {  => Case 1)?
 8000174:	d312      	bcc.n	800019c <_CheckCase2>

08000176 <_Case4>:
_Case4:
        ADDS     R5,R7,R5                        // pBuffer += WrOff
 8000176:	197d      	adds	r5, r7, r5
        ADDS     R0,R2,R7                        // v = WrOff + NumBytes
 8000178:	19d0      	adds	r0, r2, r7
 800017a:	bf00      	nop

0800017c <_LoopCopyStraight>:
        // 2x unrolling for the copy loop that is used most of the time
        // This is a special optimization for small SystemView packets and makes them even faster
        //
        _ALIGN(2)
_LoopCopyStraight:                               // memcpy(pRing->pBuffer + WrOff, pData, NumBytes);
        LDRB     R3,[R1], #+1
 800017c:	f811 3b01 	ldrb.w	r3, [r1], #1
        STRB     R3,[R5], #+1                    // *pDest++ = *pSrc++
 8000180:	f805 3b01 	strb.w	r3, [r5], #1
        SUBS     R2,R2,#+1
 8000184:	3a01      	subs	r2, #1
        BEQ      _CSDone
 8000186:	d005      	beq.n	8000194 <_CSDone>
        LDRB     R3,[R1], #+1
 8000188:	f811 3b01 	ldrb.w	r3, [r1], #1
        STRB     R3,[R5], #+1                    // *pDest++ = *pSrc++
 800018c:	f805 3b01 	strb.w	r3, [r5], #1
        SUBS     R2,R2,#+1
 8000190:	3a01      	subs	r2, #1
        BNE      _LoopCopyStraight
 8000192:	d1f3      	bne.n	800017c <_LoopCopyStraight>

08000194 <_CSDone>:
_CSDone:
#if _CORE_NEEDS_DMB                              // Do not slow down cores that do not need a DMB instruction here
        DMB                                      // Cortex-M7 may delay memory writes and also change the order in which the writes happen. Therefore, make sure that all buffer writes are finished, before updating the <WrOff> in the struct
#endif
        STR      R0,[R6, #+12]                   // pRing->WrOff = WrOff + NumBytes;
 8000194:	60f0      	str	r0, [r6, #12]
        MOVS     R0,#+1
 8000196:	2001      	movs	r0, #1
        POP      {R4-R7}
 8000198:	bcf0      	pop	{r4, r5, r6, r7}
        BX       LR                              // Return 1
 800019a:	4770      	bx	lr

0800019c <_CheckCase2>:
_CheckCase2:
        ADDS     R0,R0,R3                        // Avail += RdOff; => Space incl. wrap-around
 800019c:	18c0      	adds	r0, r0, r3
        CMP      R0,R2
 800019e:	4290      	cmp	r0, r2
        BCC.N    _Case3                          // if (Avail >= NumBytes) {           => Case 2? => If not, we have case 3) (does not fit)
 80001a0:	d317      	bcc.n	80001d2 <_Case3>
        //
        // Handling for case 2
        //
        ADDS     R0,R7,R5                        // v = pRing->pBuffer + WrOff => Do not change pRing->pBuffer here because 2nd chunk needs org. value
 80001a2:	1978      	adds	r0, r7, r5
        SUBS     R2,R2,R4                        // NumBytes -= Rem;  (Rem = pRing->SizeOfBuffer - WrOff; => Space until end of buffer)
 80001a4:	1b12      	subs	r2, r2, r4

080001a6 <_LoopCopyBeforeWrapAround>:
_LoopCopyBeforeWrapAround:                       // memcpy(pRing->pBuffer + WrOff, pData, Rem); => Copy 1st chunk
        LDRB     R3,[R1], #+1
 80001a6:	f811 3b01 	ldrb.w	r3, [r1], #1
        STRB     R3,[R0], #+1                    // *pDest++ = *pSrc++
 80001aa:	f800 3b01 	strb.w	r3, [r0], #1
        SUBS     R4,R4,#+1
 80001ae:	3c01      	subs	r4, #1
        BNE      _LoopCopyBeforeWrapAround
 80001b0:	d1f9      	bne.n	80001a6 <_LoopCopyBeforeWrapAround>
        // Special case: First check that assumed RdOff == 0 calculated that last element before wrap-around could not be used
        // But 2nd check (considering space until wrap-around and until RdOff) revealed that RdOff is not 0, so we can use the last element
        // In this case, we may use a copy straight until buffer end anyway without needing to copy 2 chunks
        // Therefore, check if 2nd memcpy is necessary at all
        //
        ADDS     R4,R2,#+0                       // Save <NumBytes> (needed as counter in loop but must be written to <WrOff> after the loop). Also use this inst to update the flags to skip 2nd loop if possible
 80001b2:	1c14      	adds	r4, r2, #0
        BEQ.N    _No2ChunkNeeded                 // if (NumBytes) {
 80001b4:	d005      	beq.n	80001c2 <_No2ChunkNeeded>

080001b6 <_LoopCopyAfterWrapAround>:
_LoopCopyAfterWrapAround:                        // memcpy(pRing->pBuffer, pData + Rem, NumBytes);
        LDRB     R3,[R1], #+1                    // pData already points to the next src byte due to copy loop increment before this loop
 80001b6:	f811 3b01 	ldrb.w	r3, [r1], #1
        STRB     R3,[R5], #+1                    // *pDest++ = *pSrc++
 80001ba:	f805 3b01 	strb.w	r3, [r5], #1
        SUBS     R2,R2,#+1
 80001be:	3a01      	subs	r2, #1
        BNE      _LoopCopyAfterWrapAround
 80001c0:	d1f9      	bne.n	80001b6 <_LoopCopyAfterWrapAround>

080001c2 <_No2ChunkNeeded>:
_No2ChunkNeeded:
#if _CORE_NEEDS_DMB                              // Do not slow down cores that do not need a DMB instruction here
        DMB                                      // Cortex-M7 may delay memory writes and also change the order in which the writes happen. Therefore, make sure that all buffer writes are finished, before updating the <WrOff> in the struct
#endif
        STR      R4,[R6, #+12]                   // pRing->WrOff = NumBytes; => Must be written after copying data because J-Link may read control block asynchronously while writing into buffer
 80001c2:	60f4      	str	r4, [r6, #12]
        MOVS     R0,#+1
 80001c4:	2001      	movs	r0, #1
        POP      {R4-R7}
 80001c6:	bcf0      	pop	{r4, r5, r6, r7}
        BX       LR                              // Return 1
 80001c8:	4770      	bx	lr

080001ca <_CheckCase4>:
_CheckCase4:
        SUBS     R0,R0,R7
 80001ca:	1bc0      	subs	r0, r0, r7
        SUBS     R0,R0,#+1                       // Avail = RdOff - WrOff - 1u;
 80001cc:	3801      	subs	r0, #1
        CMP      R0,R2
 80001ce:	4290      	cmp	r0, r2
        BCS.N    _Case4                          // if (Avail >= NumBytes) {      => Case 4) == 1) ? => If not, we have case 5) == 3) (does not fit)
 80001d0:	d2d1      	bcs.n	8000176 <_Case4>

080001d2 <_Case3>:
_Case3:
        MOVS     R0,#+0
 80001d2:	2000      	movs	r0, #0
        POP      {R4-R7}
 80001d4:	bcf0      	pop	{r4, r5, r6, r7}
        BX       LR                              // Return 0
 80001d6:	4770      	bx	lr
        LDR.W    R0,=_SEGGER_RTT                 // pRing = &_SEGGER_RTT.aUp[BufferIndex];
 80001d8:	2000188c 	.word	0x2000188c

080001dc <vApplicationGetIdleTaskMemory>:

void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize )
{
  *ppxIdleTaskTCBBuffer = &xIdleTaskTCBBuffer;
  *ppxIdleTaskStackBuffer = &xIdleStack[0];
  *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
 80001dc:	2380      	movs	r3, #128	@ 0x80
{
 80001de:	b430      	push	{r4, r5}
  *ppxIdleTaskTCBBuffer = &xIdleTaskTCBBuffer;
 80001e0:	4d03      	ldr	r5, [pc, #12]	@ (80001f0 <vApplicationGetIdleTaskMemory+0x14>)
  *ppxIdleTaskStackBuffer = &xIdleStack[0];
 80001e2:	4c04      	ldr	r4, [pc, #16]	@ (80001f4 <vApplicationGetIdleTaskMemory+0x18>)
  *ppxIdleTaskTCBBuffer = &xIdleTaskTCBBuffer;
 80001e4:	6005      	str	r5, [r0, #0]
  *ppxIdleTaskStackBuffer = &xIdleStack[0];
 80001e6:	600c      	str	r4, [r1, #0]
  *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
 80001e8:	6013      	str	r3, [r2, #0]
  /* place for user code */
}
 80001ea:	bc30      	pop	{r4, r5}
 80001ec:	4770      	bx	lr
 80001ee:	bf00      	nop
 80001f0:	2000074c 	.word	0x2000074c
 80001f4:	2000054c 	.word	0x2000054c

080001f8 <vApplicationGetTimerTaskMemory>:

void vApplicationGetTimerTaskMemory( StaticTask_t **ppxTimerTaskTCBBuffer, StackType_t **ppxTimerTaskStackBuffer, uint32_t *pulTimerTaskStackSize )
{
  *ppxTimerTaskTCBBuffer = &xTimerTaskTCBBuffer;
  *ppxTimerTaskStackBuffer = &xTimerStack[0];
  *pulTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH;
 80001f8:	f44f 7380 	mov.w	r3, #256	@ 0x100
{
 80001fc:	b430      	push	{r4, r5}
  *ppxTimerTaskTCBBuffer = &xTimerTaskTCBBuffer;
 80001fe:	4d03      	ldr	r5, [pc, #12]	@ (800020c <vApplicationGetTimerTaskMemory+0x14>)
  *ppxTimerTaskStackBuffer = &xTimerStack[0];
 8000200:	4c03      	ldr	r4, [pc, #12]	@ (8000210 <vApplicationGetTimerTaskMemory+0x18>)
  *ppxTimerTaskTCBBuffer = &xTimerTaskTCBBuffer;
 8000202:	6005      	str	r5, [r0, #0]
  *ppxTimerTaskStackBuffer = &xTimerStack[0];
 8000204:	600c      	str	r4, [r1, #0]
  *pulTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH;
 8000206:	6013      	str	r3, [r2, #0]
  /* place for user code */
}
 8000208:	bc30      	pop	{r4, r5}
 800020a:	4770      	bx	lr
 800020c:	200004a4 	.word	0x200004a4
 8000210:	200000a4 	.word	0x200000a4

08000214 <TASK_ManagerPoint>:
			station.currentColor = color;
		}
	}
}

void TASK_ManagerPoint(void *pvParams) {
 8000214:	e92d 4880 	stmdb	sp!, {r7, fp, lr}

	int32_t time_counter = 0;
	LED_COLOR color = LEDColor_YELLOW;
 8000218:	2302      	movs	r3, #2
	int32_t time_counter = 0;
 800021a:	2700      	movs	r7, #0
void TASK_ManagerPoint(void *pvParams) {
 800021c:	b087      	sub	sp, #28
			xTimerStop(xCANRequest, 0);

		if (xSemaphoreTake(xGetReq, 0) == pdTRUE
				&& (station.currentColor == LEDColor_YELLOW
						|| station.currentColor == LEDColor_RED)) {
			xTimerStart(xCANRequest, 0);
 800021e:	f04f 0b01 	mov.w	fp, #1
 8000222:	4c36      	ldr	r4, [pc, #216]	@ (80002fc <TASK_ManagerPoint+0xe8>)
 8000224:	f8df a0d8 	ldr.w	sl, [pc, #216]	@ 8000300 <TASK_ManagerPoint+0xec>
 8000228:	4e36      	ldr	r6, [pc, #216]	@ (8000304 <TASK_ManagerPoint+0xf0>)
 800022a:	4d37      	ldr	r5, [pc, #220]	@ (8000308 <TASK_ManagerPoint+0xf4>)
 800022c:	f8df 90dc 	ldr.w	r9, [pc, #220]	@ 800030c <TASK_ManagerPoint+0xf8>
 8000230:	f8df 80dc 	ldr.w	r8, [pc, #220]	@ 8000310 <TASK_ManagerPoint+0xfc>
	int32_t time_counter = 0;
 8000234:	9705      	str	r7, [sp, #20]
	LED_COLOR color = LEDColor_YELLOW;
 8000236:	f88d 3013 	strb.w	r3, [sp, #19]
 800023a:	e029      	b.n	8000290 <TASK_ManagerPoint+0x7c>
			station.isResp = false;
		}

		if (xSemaphoreTake(xChangeState, 0) == pdTRUE) {
 800023c:	2100      	movs	r1, #0
 800023e:	6828      	ldr	r0, [r5, #0]
 8000240:	f002 fc46 	bl	8002ad0 <xQueueSemaphoreTake>
 8000244:	2801      	cmp	r0, #1
 8000246:	d120      	bne.n	800028a <TASK_ManagerPoint+0x76>
			if (!station.isResp) {
 8000248:	7e23      	ldrb	r3, [r4, #24]
 800024a:	b92b      	cbnz	r3, 8000258 <TASK_ManagerPoint+0x44>
				station.initSeconds[LEDColor_RED] = TIME_LED_RED_DEFAULT;
 800024c:	2214      	movs	r2, #20
 800024e:	2305      	movs	r3, #5
				station.initSeconds[LEDColor_YELLOW] = TIME_LED_YELLOW_DEFAULT;
				station.initSeconds[LEDColor_GREEN] = TIME_LED_GREEN_DEFAULT;
 8000250:	210f      	movs	r1, #15
				station.initSeconds[LEDColor_RED] = TIME_LED_RED_DEFAULT;
 8000252:	e9c4 2303 	strd	r2, r3, [r4, #12]
				station.initSeconds[LEDColor_GREEN] = TIME_LED_GREEN_DEFAULT;
 8000256:	6161      	str	r1, [r4, #20]
			}

			switch (station.currentColor) {
 8000258:	7823      	ldrb	r3, [r4, #0]
			case LEDColor_YELLOW:
				color = LEDColor_RED;
				time_counter = station.initSeconds[LEDColor_RED] + 1;
				xQueueSend(xQueue_LED7Seg, &time_counter, 0);
 800025a:	f8d9 0000 	ldr.w	r0, [r9]
			switch (station.currentColor) {
 800025e:	2b01      	cmp	r3, #1
 8000260:	d046      	beq.n	80002f0 <TASK_ManagerPoint+0xdc>
 8000262:	2b02      	cmp	r3, #2
 8000264:	d139      	bne.n	80002da <TASK_ManagerPoint+0xc6>
				time_counter = station.initSeconds[LEDColor_RED] + 1;
 8000266:	68e3      	ldr	r3, [r4, #12]
				color = LEDColor_RED;
 8000268:	f88d b013 	strb.w	fp, [sp, #19]
				time_counter = station.initSeconds[LEDColor_RED] + 1;
 800026c:	3301      	adds	r3, #1
				break;
			case LEDColor_RED:
				color = LEDColor_GREEN;
				time_counter = station.initSeconds[LEDColor_GREEN];
 800026e:	9305      	str	r3, [sp, #20]
				xQueueSend(xQueue_LED7Seg, &time_counter, 0);
 8000270:	2300      	movs	r3, #0
 8000272:	a905      	add	r1, sp, #20
 8000274:	461a      	mov	r2, r3
 8000276:	f002 f883 	bl	8002380 <xQueueGenericSend>
				color = LEDColor_YELLOW;
				time_counter = station.initSeconds[LEDColor_YELLOW];
				xQueueSend(xQueue_LED7Seg, &time_counter, 0);
				break;
			}
			xQueueSend(xQueue_LEDColor, &color, 0);
 800027a:	2300      	movs	r3, #0
 800027c:	f8d8 0000 	ldr.w	r0, [r8]
 8000280:	461a      	mov	r2, r3
 8000282:	f10d 0113 	add.w	r1, sp, #19
 8000286:	f002 f87b 	bl	8002380 <xQueueGenericSend>
		}
//		SEGGER_SYSVIEW_PrintfTarget("okoko");
		vTaskDelay(pdMS_TO_TICKS(100));
 800028a:	2064      	movs	r0, #100	@ 0x64
 800028c:	f003 f9e4 	bl	8003658 <vTaskDelay>
		if (station.remainSeconds <= 2)
 8000290:	6863      	ldr	r3, [r4, #4]
 8000292:	2b02      	cmp	r3, #2
 8000294:	dd18      	ble.n	80002c8 <TASK_ManagerPoint+0xb4>
		if (xSemaphoreTake(xGetReq, 0) == pdTRUE
 8000296:	2100      	movs	r1, #0
 8000298:	6830      	ldr	r0, [r6, #0]
 800029a:	f002 fc19 	bl	8002ad0 <xQueueSemaphoreTake>
 800029e:	2801      	cmp	r0, #1
 80002a0:	d1cc      	bne.n	800023c <TASK_ManagerPoint+0x28>
						|| station.currentColor == LEDColor_RED)) {
 80002a2:	7823      	ldrb	r3, [r4, #0]
				&& (station.currentColor == LEDColor_YELLOW
 80002a4:	3b01      	subs	r3, #1
 80002a6:	2b01      	cmp	r3, #1
 80002a8:	d8c8      	bhi.n	800023c <TASK_ManagerPoint+0x28>
			xTimerStart(xCANRequest, 0);
 80002aa:	f8da 3000 	ldr.w	r3, [sl]
 80002ae:	9003      	str	r0, [sp, #12]
 80002b0:	9302      	str	r3, [sp, #8]
 80002b2:	f003 faad 	bl	8003810 <xTaskGetTickCount>
 80002b6:	2300      	movs	r3, #0
 80002b8:	4602      	mov	r2, r0
 80002ba:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 80002be:	9700      	str	r7, [sp, #0]
 80002c0:	f003 ff9c 	bl	80041fc <xTimerGenericCommand>
			station.isResp = false;
 80002c4:	7627      	strb	r7, [r4, #24]
 80002c6:	e7b9      	b.n	800023c <TASK_ManagerPoint+0x28>
			xTimerStop(xCANRequest, 0);
 80002c8:	2300      	movs	r3, #0
 80002ca:	2103      	movs	r1, #3
 80002cc:	461a      	mov	r2, r3
 80002ce:	f8da 0000 	ldr.w	r0, [sl]
 80002d2:	9700      	str	r7, [sp, #0]
 80002d4:	f003 ff92 	bl	80041fc <xTimerGenericCommand>
 80002d8:	e7dd      	b.n	8000296 <TASK_ManagerPoint+0x82>
				color = LEDColor_YELLOW;
 80002da:	2202      	movs	r2, #2
				xQueueSend(xQueue_LED7Seg, &time_counter, 0);
 80002dc:	2300      	movs	r3, #0
				time_counter = station.initSeconds[LEDColor_YELLOW];
 80002de:	6921      	ldr	r1, [r4, #16]
				color = LEDColor_YELLOW;
 80002e0:	f88d 2013 	strb.w	r2, [sp, #19]
				time_counter = station.initSeconds[LEDColor_YELLOW];
 80002e4:	9105      	str	r1, [sp, #20]
				xQueueSend(xQueue_LED7Seg, &time_counter, 0);
 80002e6:	461a      	mov	r2, r3
 80002e8:	a905      	add	r1, sp, #20
 80002ea:	f002 f849 	bl	8002380 <xQueueGenericSend>
				break;
 80002ee:	e7c4      	b.n	800027a <TASK_ManagerPoint+0x66>
				color = LEDColor_GREEN;
 80002f0:	f04f 0203 	mov.w	r2, #3
				time_counter = station.initSeconds[LEDColor_GREEN];
 80002f4:	6963      	ldr	r3, [r4, #20]
				color = LEDColor_GREEN;
 80002f6:	f88d 2013 	strb.w	r2, [sp, #19]
 80002fa:	e7b8      	b.n	800026e <TASK_ManagerPoint+0x5a>
 80002fc:	20000000 	.word	0x20000000
 8000300:	200007f4 	.word	0x200007f4
 8000304:	200007fc 	.word	0x200007fc
 8000308:	20000800 	.word	0x20000800
 800030c:	20000804 	.word	0x20000804
 8000310:	20000808 	.word	0x20000808

08000314 <TASK_LEDColor_Control>:
void TASK_LEDColor_Control(void *pvParams) {
 8000314:	b580      	push	{r7, lr}
 8000316:	4c19      	ldr	r4, [pc, #100]	@ (800037c <TASK_LEDColor_Control+0x68>)
 8000318:	f8df 8064 	ldr.w	r8, [pc, #100]	@ 8000380 <TASK_LEDColor_Control+0x6c>
	HAL_GPIO_WritePin(LED_PORT, RED_LED_PIN,
 800031c:	4e19      	ldr	r6, [pc, #100]	@ (8000384 <TASK_LEDColor_Control+0x70>)
			SEGGER_SYSVIEW_PrintfTarget("hehehe");
 800031e:	4f1a      	ldr	r7, [pc, #104]	@ (8000388 <TASK_LEDColor_Control+0x74>)
void TASK_LEDColor_Control(void *pvParams) {
 8000320:	b082      	sub	sp, #8
		if (xQueueReceive(xQueue_LEDColor, &color, portMAX_DELAY) == pdPASS) {
 8000322:	f04f 32ff 	mov.w	r2, #4294967295
 8000326:	6820      	ldr	r0, [r4, #0]
 8000328:	f10d 0107 	add.w	r1, sp, #7
 800032c:	f002 fa34 	bl	8002798 <xQueueReceive>
 8000330:	2801      	cmp	r0, #1
 8000332:	d1f6      	bne.n	8000322 <TASK_LEDColor_Control+0xe>
			LED_SetColor(color);
 8000334:	f89d 5007 	ldrb.w	r5, [sp, #7]
	HAL_GPIO_WritePin(LED_PORT, RED_LED_PIN,
 8000338:	2108      	movs	r1, #8
 800033a:	f1a5 0201 	sub.w	r2, r5, #1
 800033e:	fab2 f282 	clz	r2, r2
 8000342:	4630      	mov	r0, r6
 8000344:	0952      	lsrs	r2, r2, #5
 8000346:	f001 fa3b 	bl	80017c0 <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(LED_PORT, YELLOW_LED_PIN,
 800034a:	2102      	movs	r1, #2
 800034c:	1a6a      	subs	r2, r5, r1
 800034e:	fab2 f282 	clz	r2, r2
 8000352:	4630      	mov	r0, r6
 8000354:	0952      	lsrs	r2, r2, #5
 8000356:	f001 fa33 	bl	80017c0 <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(LED_PORT, GREEN_LED_PIN,
 800035a:	f1a5 0203 	sub.w	r2, r5, #3
 800035e:	fab2 f282 	clz	r2, r2
 8000362:	2104      	movs	r1, #4
 8000364:	4630      	mov	r0, r6
 8000366:	0952      	lsrs	r2, r2, #5
 8000368:	f001 fa2a 	bl	80017c0 <HAL_GPIO_WritePin>
			SEGGER_SYSVIEW_PrintfTarget("hehehe");
 800036c:	4638      	mov	r0, r7
 800036e:	f006 fbf3 	bl	8006b58 <SEGGER_SYSVIEW_PrintfTarget>
			station.currentColor = color;
 8000372:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8000376:	f888 3000 	strb.w	r3, [r8]
 800037a:	e7d2      	b.n	8000322 <TASK_LEDColor_Control+0xe>
 800037c:	20000808 	.word	0x20000808
 8000380:	20000000 	.word	0x20000000
 8000384:	40010800 	.word	0x40010800
 8000388:	08006e20 	.word	0x08006e20

0800038c <CAN_RequestCallback>:
	canTxData[2] = (led_color >> 8) & 0xFF;
 800038c:	2000      	movs	r0, #0
	if (station.remainSeconds != 0xFFFFFFFF)
		CAN_SendMessage(CMD_CYCLE, station.currentColor,
				(uint32_t) station.remainSeconds);
}

void CAN_RequestCallback(TimerHandle_t xTimer) {
 800038e:	b510      	push	{r4, lr}
	canTxData[0] = (cmd >> 8) & 0xFF;
 8000390:	f44f 7480 	mov.w	r4, #256	@ 0x100
	CAN_SendMessage(CMD_REQUEST, station.currentColor,
 8000394:	4a0e      	ldr	r2, [pc, #56]	@ (80003d0 <CAN_RequestCallback+0x44>)
			(uint32_t) station.remainSeconds);
 8000396:	6853      	ldr	r3, [r2, #4]
	CAN_SendMessage(CMD_REQUEST, station.currentColor,
 8000398:	f892 e000 	ldrb.w	lr, [r2]
	canTxData[0] = (cmd >> 8) & 0xFF;
 800039c:	4a0d      	ldr	r2, [pc, #52]	@ (80003d4 <CAN_RequestCallback+0x48>)
	canTxData[4] = (time_counter >> 24) & 0xFF;
 800039e:	ea4f 6c13 	mov.w	ip, r3, lsr #24
	canTxData[2] = (led_color >> 8) & 0xFF;
 80003a2:	7090      	strb	r0, [r2, #2]
	canTxData[3] = led_color & 0xFF;
 80003a4:	f36e 0007 	bfi	r0, lr, #0, #8
	canTxData[5] = (time_counter >> 16) & 0xFF;
 80003a8:	0c19      	lsrs	r1, r3, #16
	canTxData[3] = led_color & 0xFF;
 80003aa:	f36c 200f 	bfi	r0, ip, #8, #8
	canTxData[7] = time_counter & 0xFF;
 80003ae:	71d3      	strb	r3, [r2, #7]
	canTxData[3] = led_color & 0xFF;
 80003b0:	f361 4017 	bfi	r0, r1, #16, #8
	canTxData[6] = (time_counter >> 8) & 0xFF;
 80003b4:	0a1b      	lsrs	r3, r3, #8
	canTxData[3] = led_color & 0xFF;
 80003b6:	f363 601f 	bfi	r0, r3, #24, #8
 80003ba:	f8c2 0003 	str.w	r0, [r2, #3]
	canTxData[0] = (cmd >> 8) & 0xFF;
 80003be:	8014      	strh	r4, [r2, #0]
	HAL_CAN_AddTxMessage(&hcan, &txHeader, canTxData, &canMailbox);
 80003c0:	4b05      	ldr	r3, [pc, #20]	@ (80003d8 <CAN_RequestCallback+0x4c>)
 80003c2:	4906      	ldr	r1, [pc, #24]	@ (80003dc <CAN_RequestCallback+0x50>)
 80003c4:	4806      	ldr	r0, [pc, #24]	@ (80003e0 <CAN_RequestCallback+0x54>)
}
 80003c6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	HAL_CAN_AddTxMessage(&hcan, &txHeader, canTxData, &canMailbox);
 80003ca:	f000 bd4d 	b.w	8000e68 <HAL_CAN_AddTxMessage>
 80003ce:	bf00      	nop
 80003d0:	20000000 	.word	0x20000000
 80003d4:	20000874 	.word	0x20000874
 80003d8:	2000080c 	.word	0x2000080c
 80003dc:	20000840 	.word	0x20000840
 80003e0:	200008c4 	.word	0x200008c4

080003e4 <CAN_CycleCallback>:
	if (station.remainSeconds != 0xFFFFFFFF)
 80003e4:	4a11      	ldr	r2, [pc, #68]	@ (800042c <CAN_CycleCallback+0x48>)
 80003e6:	6853      	ldr	r3, [r2, #4]
 80003e8:	1c59      	adds	r1, r3, #1
 80003ea:	d100      	bne.n	80003ee <CAN_CycleCallback+0xa>
 80003ec:	4770      	bx	lr
void CAN_CycleCallback(TimerHandle_t xTimer) {
 80003ee:	b570      	push	{r4, r5, r6, lr}
	canTxData[0] = (cmd >> 8) & 0xFF;
 80003f0:	f04f 0e00 	mov.w	lr, #0
		CAN_SendMessage(CMD_CYCLE, station.currentColor,
 80003f4:	7816      	ldrb	r6, [r2, #0]
	canTxData[0] = (cmd >> 8) & 0xFF;
 80003f6:	4a0e      	ldr	r2, [pc, #56]	@ (8000430 <CAN_CycleCallback+0x4c>)
	canTxData[4] = (time_counter >> 24) & 0xFF;
 80003f8:	0e1d      	lsrs	r5, r3, #24
	canTxData[0] = (cmd >> 8) & 0xFF;
 80003fa:	f8a2 e000 	strh.w	lr, [r2]
	canTxData[2] = (led_color >> 8) & 0xFF;
 80003fe:	f882 e002 	strb.w	lr, [r2, #2]
	canTxData[3] = led_color & 0xFF;
 8000402:	f366 0e07 	bfi	lr, r6, #0, #8
	canTxData[5] = (time_counter >> 16) & 0xFF;
 8000406:	0c1c      	lsrs	r4, r3, #16
	canTxData[3] = led_color & 0xFF;
 8000408:	f365 2e0f 	bfi	lr, r5, #8, #8
	canTxData[6] = (time_counter >> 8) & 0xFF;
 800040c:	ea4f 2c13 	mov.w	ip, r3, lsr #8
	canTxData[3] = led_color & 0xFF;
 8000410:	f364 4e17 	bfi	lr, r4, #16, #8
 8000414:	f36c 6e1f 	bfi	lr, ip, #24, #8
	canTxData[7] = time_counter & 0xFF;
 8000418:	71d3      	strb	r3, [r2, #7]
	canTxData[3] = led_color & 0xFF;
 800041a:	f8c2 e003 	str.w	lr, [r2, #3]
	HAL_CAN_AddTxMessage(&hcan, &txHeader, canTxData, &canMailbox);
 800041e:	4b05      	ldr	r3, [pc, #20]	@ (8000434 <CAN_CycleCallback+0x50>)
 8000420:	4905      	ldr	r1, [pc, #20]	@ (8000438 <CAN_CycleCallback+0x54>)
 8000422:	4806      	ldr	r0, [pc, #24]	@ (800043c <CAN_CycleCallback+0x58>)
}
 8000424:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	HAL_CAN_AddTxMessage(&hcan, &txHeader, canTxData, &canMailbox);
 8000428:	f000 bd1e 	b.w	8000e68 <HAL_CAN_AddTxMessage>
 800042c:	20000000 	.word	0x20000000
 8000430:	20000874 	.word	0x20000874
 8000434:	2000080c 	.word	0x2000080c
 8000438:	20000840 	.word	0x20000840
 800043c:	200008c4 	.word	0x200008c4

08000440 <SystemClock_Config>:
	RCC_OscInitTypeDef RCC_OscInitStruct = { 0 };
 8000440:	2300      	movs	r3, #0
	RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 8000442:	2201      	movs	r2, #1
void SystemClock_Config(void) {
 8000444:	b530      	push	{r4, r5, lr}
	RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 8000446:	2001      	movs	r0, #1
void SystemClock_Config(void) {
 8000448:	b091      	sub	sp, #68	@ 0x44
	RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 800044a:	f44f 3180 	mov.w	r1, #65536	@ 0x10000
	RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 800044e:	2402      	movs	r4, #2
	RCC_OscInitTypeDef RCC_OscInitStruct = { 0 };
 8000450:	e9cd 330b 	strd	r3, r3, [sp, #44]	@ 0x2c
	RCC_ClkInitTypeDef RCC_ClkInitStruct = { 0 };
 8000454:	e9cd 3302 	strd	r3, r3, [sp, #8]
 8000458:	e9cd 3304 	strd	r3, r3, [sp, #16]
	RCC_OscInitTypeDef RCC_OscInitStruct = { 0 };
 800045c:	9308      	str	r3, [sp, #32]
	RCC_ClkInitTypeDef RCC_ClkInitStruct = { 0 };
 800045e:	9301      	str	r3, [sp, #4]
	RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 8000460:	920a      	str	r2, [sp, #40]	@ 0x28
	RCC_OscInitTypeDef RCC_OscInitStruct = { 0 };
 8000462:	9309      	str	r3, [sp, #36]	@ 0x24
	RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8000464:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
	RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;
 8000468:	f44f 13e0 	mov.w	r3, #1835008	@ 0x1c0000
	RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 800046c:	e9cd 0106 	strd	r0, r1, [sp, #24]
	if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) {
 8000470:	a806      	add	r0, sp, #24
	RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;
 8000472:	e9cd 230e 	strd	r2, r3, [sp, #56]	@ 0x38
	RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8000476:	940d      	str	r4, [sp, #52]	@ 0x34
	if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) {
 8000478:	f001 f9a6 	bl	80017c8 <HAL_RCC_OscConfig>
 800047c:	b108      	cbz	r0, 8000482 <SystemClock_Config+0x42>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800047e:	b672      	cpsid	i
 */
void Error_Handler(void) {
	/* USER CODE BEGIN Error_Handler_Debug */
	/* User can add his own implementation to report the HAL error return state */
	__disable_irq();
	while (1) {
 8000480:	e7fe      	b.n	8000480 <SystemClock_Config+0x40>
	RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK
 8000482:	4603      	mov	r3, r0
 8000484:	250f      	movs	r5, #15
	RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
 8000486:	f44f 6280 	mov.w	r2, #1024	@ 0x400
	if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK) {
 800048a:	4621      	mov	r1, r4
 800048c:	a801      	add	r0, sp, #4
	RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 800048e:	9402      	str	r4, [sp, #8]
	RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8000490:	9303      	str	r3, [sp, #12]
	RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 8000492:	9305      	str	r3, [sp, #20]
	RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK
 8000494:	9501      	str	r5, [sp, #4]
	RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
 8000496:	9204      	str	r2, [sp, #16]
	if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK) {
 8000498:	f001 fb84 	bl	8001ba4 <HAL_RCC_ClockConfig>
 800049c:	b108      	cbz	r0, 80004a2 <SystemClock_Config+0x62>
 800049e:	b672      	cpsid	i
	while (1) {
 80004a0:	e7fe      	b.n	80004a0 <SystemClock_Config+0x60>
}
 80004a2:	b011      	add	sp, #68	@ 0x44
 80004a4:	bd30      	pop	{r4, r5, pc}
 80004a6:	bf00      	nop

080004a8 <main>:
	GPIO_InitTypeDef GPIO_InitStruct = { 0 };
 80004a8:	2400      	movs	r4, #0
int main(void) {
 80004aa:	b580      	push	{r7, lr}
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 80004ac:	2601      	movs	r6, #1
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80004ae:	2702      	movs	r7, #2
	GPIO_InitStruct.Pin = GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_3;
 80004b0:	f04f 080e 	mov.w	r8, #14
int main(void) {
 80004b4:	b08a      	sub	sp, #40	@ 0x28
	HAL_Init();
 80004b6:	f000 fb75 	bl	8000ba4 <HAL_Init>
	HAL_Delay(360);
 80004ba:	f44f 70b4 	mov.w	r0, #360	@ 0x168
 80004be:	f000 fb95 	bl	8000bec <HAL_Delay>
	SystemClock_Config();
 80004c2:	f7ff ffbd 	bl	8000440 <SystemClock_Config>
	GPIO_InitTypeDef GPIO_InitStruct = { 0 };
 80004c6:	e9cd 4406 	strd	r4, r4, [sp, #24]
 80004ca:	e9cd 4408 	strd	r4, r4, [sp, #32]
	__HAL_RCC_GPIOD_CLK_ENABLE();
 80004ce:	4b77      	ldr	r3, [pc, #476]	@ (80006ac <main+0x204>)
	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_3,
 80004d0:	210e      	movs	r1, #14
	__HAL_RCC_GPIOD_CLK_ENABLE();
 80004d2:	699a      	ldr	r2, [r3, #24]
	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_3,
 80004d4:	4876      	ldr	r0, [pc, #472]	@ (80006b0 <main+0x208>)
	__HAL_RCC_GPIOD_CLK_ENABLE();
 80004d6:	f042 0220 	orr.w	r2, r2, #32
 80004da:	619a      	str	r2, [r3, #24]
 80004dc:	699a      	ldr	r2, [r3, #24]
	hcan.Instance = CAN1;
 80004de:	4d75      	ldr	r5, [pc, #468]	@ (80006b4 <main+0x20c>)
	__HAL_RCC_GPIOD_CLK_ENABLE();
 80004e0:	f002 0220 	and.w	r2, r2, #32
 80004e4:	9203      	str	r2, [sp, #12]
 80004e6:	9a03      	ldr	r2, [sp, #12]
	__HAL_RCC_GPIOA_CLK_ENABLE();
 80004e8:	699a      	ldr	r2, [r3, #24]
 80004ea:	f042 0204 	orr.w	r2, r2, #4
 80004ee:	619a      	str	r2, [r3, #24]
 80004f0:	699a      	ldr	r2, [r3, #24]
 80004f2:	f002 0204 	and.w	r2, r2, #4
 80004f6:	9204      	str	r2, [sp, #16]
 80004f8:	9a04      	ldr	r2, [sp, #16]
	__HAL_RCC_GPIOB_CLK_ENABLE();
 80004fa:	699a      	ldr	r2, [r3, #24]
 80004fc:	f042 0208 	orr.w	r2, r2, #8
 8000500:	619a      	str	r2, [r3, #24]
 8000502:	699b      	ldr	r3, [r3, #24]
	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_3,
 8000504:	4622      	mov	r2, r4
	__HAL_RCC_GPIOB_CLK_ENABLE();
 8000506:	f003 0308 	and.w	r3, r3, #8
 800050a:	9305      	str	r3, [sp, #20]
 800050c:	9b05      	ldr	r3, [sp, #20]
	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_3,
 800050e:	f001 f957 	bl	80017c0 <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(GPIOB, GPIO_PIN_6 | GPIO_PIN_7 | GPIO_PIN_8,
 8000512:	4622      	mov	r2, r4
 8000514:	f44f 71e0 	mov.w	r1, #448	@ 0x1c0
 8000518:	4867      	ldr	r0, [pc, #412]	@ (80006b8 <main+0x210>)
 800051a:	f001 f951 	bl	80017c0 <HAL_GPIO_WritePin>
	HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800051e:	4864      	ldr	r0, [pc, #400]	@ (80006b0 <main+0x208>)
 8000520:	a906      	add	r1, sp, #24
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8000522:	e9cd 8606 	strd	r8, r6, [sp, #24]
	GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000526:	9408      	str	r4, [sp, #32]
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8000528:	9709      	str	r7, [sp, #36]	@ 0x24
	HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800052a:	f000 ff4f 	bl	80013cc <HAL_GPIO_Init>
	GPIO_InitStruct.Pin = GPIO_PIN_6 | GPIO_PIN_7 | GPIO_PIN_8;
 800052e:	f44f 73e0 	mov.w	r3, #448	@ 0x1c0
	HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8000532:	4861      	ldr	r0, [pc, #388]	@ (80006b8 <main+0x210>)
 8000534:	a906      	add	r1, sp, #24
	GPIO_InitStruct.Pin = GPIO_PIN_6 | GPIO_PIN_7 | GPIO_PIN_8;
 8000536:	9306      	str	r3, [sp, #24]
	GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000538:	e9cd 6407 	strd	r6, r4, [sp, #28]
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800053c:	9709      	str	r7, [sp, #36]	@ 0x24
	HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800053e:	f000 ff45 	bl	80013cc <HAL_GPIO_Init>
	hcan.Init.Prescaler = 9;
 8000542:	2309      	movs	r3, #9
	hcan.Init.TimeSeg2 = CAN_BS2_4TQ;
 8000544:	f44f 3200 	mov.w	r2, #131072	@ 0x20000
	hcan.Init.Mode = CAN_MODE_NORMAL;
 8000548:	e9c5 3401 	strd	r3, r4, [r5, #4]
	hcan.Init.TimeSeg2 = CAN_BS2_4TQ;
 800054c:	f44f 1340 	mov.w	r3, #3145728	@ 0x300000
 8000550:	e9c5 2304 	strd	r2, r3, [r5, #16]
	hcan.Instance = CAN1;
 8000554:	4b59      	ldr	r3, [pc, #356]	@ (80006bc <main+0x214>)
	if (HAL_CAN_Init(&hcan) != HAL_OK) {
 8000556:	4628      	mov	r0, r5
	hcan.Init.SyncJumpWidth = CAN_SJW_1TQ;
 8000558:	60ec      	str	r4, [r5, #12]
	hcan.Init.TimeTriggeredMode = DISABLE;
 800055a:	61ac      	str	r4, [r5, #24]
	hcan.Init.ReceiveFifoLocked = DISABLE;
 800055c:	83ac      	strh	r4, [r5, #28]
	hcan.Instance = CAN1;
 800055e:	602b      	str	r3, [r5, #0]
	if (HAL_CAN_Init(&hcan) != HAL_OK) {
 8000560:	f000 fb56 	bl	8000c10 <HAL_CAN_Init>
 8000564:	b108      	cbz	r0, 800056a <main+0xc2>
 8000566:	b672      	cpsid	i
	while (1) {
 8000568:	e7fe      	b.n	8000568 <main+0xc0>
	huart1.Instance = USART1;
 800056a:	4603      	mov	r3, r0
	huart1.Init.BaudRate = 115200;
 800056c:	f44f 31e1 	mov.w	r1, #115200	@ 0x1c200
	huart1.Init.Mode = UART_MODE_TX_RX;
 8000570:	220c      	movs	r2, #12
	huart1.Instance = USART1;
 8000572:	4853      	ldr	r0, [pc, #332]	@ (80006c0 <main+0x218>)
	huart1.Init.StopBits = UART_STOPBITS_1;
 8000574:	e9c0 3302 	strd	r3, r3, [r0, #8]
	huart1.Init.OverSampling = UART_OVERSAMPLING_16;
 8000578:	e9c0 3306 	strd	r3, r3, [r0, #24]
	huart1.Init.Parity = UART_PARITY_NONE;
 800057c:	6103      	str	r3, [r0, #16]
	huart1.Instance = USART1;
 800057e:	4b51      	ldr	r3, [pc, #324]	@ (80006c4 <main+0x21c>)
	huart1.Init.BaudRate = 115200;
 8000580:	6041      	str	r1, [r0, #4]
	huart1.Init.Mode = UART_MODE_TX_RX;
 8000582:	6142      	str	r2, [r0, #20]
	huart1.Instance = USART1;
 8000584:	6003      	str	r3, [r0, #0]
	if (HAL_UART_Init(&huart1) != HAL_OK) {
 8000586:	f001 fd49 	bl	800201c <HAL_UART_Init>
 800058a:	4604      	mov	r4, r0
 800058c:	b108      	cbz	r0, 8000592 <main+0xea>
 800058e:	b672      	cpsid	i
	while (1) {
 8000590:	e7fe      	b.n	8000590 <main+0xe8>
	txHeader.ExtId = (CONTROLLER_ADDR << 8) | MY_ADDR;
 8000592:	f64a 7201 	movw	r2, #44801	@ 0xaf01
	txHeader.IDE = CAN_ID_EXT;
 8000596:	2004      	movs	r0, #4
	txHeader.DLC = 8;
 8000598:	f04f 0c08 	mov.w	ip, #8
 800059c:	4b4a      	ldr	r3, [pc, #296]	@ (80006c8 <main+0x220>)
	canfil.FilterBank = 0;
 800059e:	494b      	ldr	r1, [pc, #300]	@ (80006cc <main+0x224>)
	txHeader.ExtId = (CONTROLLER_ADDR << 8) | MY_ADDR;
 80005a0:	e9c3 2001 	strd	r2, r0, [r3, #4]
	HAL_CAN_ConfigFilter(&hcan, &canfil); //Initialize CAN Filter
 80005a4:	4628      	mov	r0, r5
	txHeader.DLC = 8;
 80005a6:	f8c3 c010 	str.w	ip, [r3, #16]
	txHeader.RTR = CAN_RTR_DATA;
 80005aa:	60dc      	str	r4, [r3, #12]
	txHeader.StdId = 0x01;
 80005ac:	601e      	str	r6, [r3, #0]
	txHeader.TransmitGlobalTime = DISABLE;
 80005ae:	751c      	strb	r4, [r3, #20]
	canfil.FilterMode = CAN_FILTERMODE_IDMASK;
 80005b0:	e9c1 4405 	strd	r4, r4, [r1, #20]
	canfil.FilterIdLow = 0;
 80005b4:	e9c1 4400 	strd	r4, r4, [r1]
	canfil.FilterMaskIdLow = 0;
 80005b8:	e9c1 4402 	strd	r4, r4, [r1, #8]
	canfil.FilterActivation = ENABLE;
 80005bc:	e9c1 6607 	strd	r6, r6, [r1, #28]
	canfil.SlaveStartFilterBank = 14;
 80005c0:	f8c1 8024 	str.w	r8, [r1, #36]	@ 0x24
	canfil.FilterFIFOAssignment = CAN_RX_FIFO0;
 80005c4:	610c      	str	r4, [r1, #16]
	HAL_CAN_ConfigFilter(&hcan, &canfil); //Initialize CAN Filter
 80005c6:	f000 fba5 	bl	8000d14 <HAL_CAN_ConfigFilter>
	HAL_CAN_Start(&hcan); //Initialize CAN Bus
 80005ca:	4628      	mov	r0, r5
 80005cc:	f000 fc1e 	bl	8000e0c <HAL_CAN_Start>
	HAL_CAN_ActivateNotification(&hcan, CAN_IT_RX_FIFO0_MSG_PENDING); // Initialize CAN Bus Rx Interrupt
 80005d0:	4639      	mov	r1, r7
 80005d2:	4628      	mov	r0, r5
 80005d4:	f000 fd1e 	bl	8001014 <HAL_CAN_ActivateNotification>
	DWT->CYCCNT = 0;
 80005d8:	4b3d      	ldr	r3, [pc, #244]	@ (80006d0 <main+0x228>)
	SEGGER_UART_init(500000);
 80005da:	483e      	ldr	r0, [pc, #248]	@ (80006d4 <main+0x22c>)
	DWT->CYCCNT = 0;
 80005dc:	605c      	str	r4, [r3, #4]
	DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 80005de:	681a      	ldr	r2, [r3, #0]
	xCANCycle = xTimerCreate("CANCycle", pdMS_TO_TICKS(100), pdTRUE, (void*) 0,
 80005e0:	4d3d      	ldr	r5, [pc, #244]	@ (80006d8 <main+0x230>)
	DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 80005e2:	f042 0201 	orr.w	r2, r2, #1
 80005e6:	601a      	str	r2, [r3, #0]
	SEGGER_UART_init(500000);
 80005e8:	f004 f9f6 	bl	80049d8 <SEGGER_UART_init>
	SEGGER_SYSVIEW_Conf();
 80005ec:	f004 f940 	bl	8004870 <SEGGER_SYSVIEW_Conf>
	vSetVarulMaxPRIGROUPValue();
 80005f0:	f003 ffc2 	bl	8004578 <vSetVarulMaxPRIGROUPValue>
	xChangeState = xSemaphoreCreateBinary();
 80005f4:	2203      	movs	r2, #3
 80005f6:	4621      	mov	r1, r4
 80005f8:	4630      	mov	r0, r6
 80005fa:	f001 fe79 	bl	80022f0 <xQueueGenericCreate>
 80005fe:	4b37      	ldr	r3, [pc, #220]	@ (80006dc <main+0x234>)
	xGetReq = xSemaphoreCreateBinary();
 8000600:	2203      	movs	r2, #3
	xChangeState = xSemaphoreCreateBinary();
 8000602:	6018      	str	r0, [r3, #0]
	xGetReq = xSemaphoreCreateBinary();
 8000604:	4621      	mov	r1, r4
 8000606:	4630      	mov	r0, r6
 8000608:	f001 fe72 	bl	80022f0 <xQueueGenericCreate>
 800060c:	4602      	mov	r2, r0
 800060e:	4b34      	ldr	r3, [pc, #208]	@ (80006e0 <main+0x238>)
	xCANCycle = xTimerCreate("CANCycle", pdMS_TO_TICKS(100), pdTRUE, (void*) 0,
 8000610:	9500      	str	r5, [sp, #0]
 8000612:	2164      	movs	r1, #100	@ 0x64
	xGetReq = xSemaphoreCreateBinary();
 8000614:	601a      	str	r2, [r3, #0]
	xCANCycle = xTimerCreate("CANCycle", pdMS_TO_TICKS(100), pdTRUE, (void*) 0,
 8000616:	4833      	ldr	r0, [pc, #204]	@ (80006e4 <main+0x23c>)
 8000618:	4623      	mov	r3, r4
 800061a:	4632      	mov	r2, r6
 800061c:	f003 fd86 	bl	800412c <xTimerCreate>
 8000620:	4b31      	ldr	r3, [pc, #196]	@ (80006e8 <main+0x240>)
 8000622:	4605      	mov	r5, r0
 8000624:	6018      	str	r0, [r3, #0]
	if (xCANCycle != NULL) {
 8000626:	b140      	cbz	r0, 800063a <main+0x192>
		xTimerStart(xCANCycle, 0);
 8000628:	f003 f8f2 	bl	8003810 <xTaskGetTickCount>
 800062c:	4623      	mov	r3, r4
 800062e:	4602      	mov	r2, r0
 8000630:	4631      	mov	r1, r6
 8000632:	4628      	mov	r0, r5
 8000634:	9400      	str	r4, [sp, #0]
 8000636:	f003 fde1 	bl	80041fc <xTimerGenericCommand>
	xCANRequest = xTimerCreate("CANRequest", pdMS_TO_TICKS(100), pdTRUE,
 800063a:	4c2c      	ldr	r4, [pc, #176]	@ (80006ec <main+0x244>)
 800063c:	2300      	movs	r3, #0
 800063e:	2201      	movs	r2, #1
 8000640:	2164      	movs	r1, #100	@ 0x64
 8000642:	9400      	str	r4, [sp, #0]
 8000644:	482a      	ldr	r0, [pc, #168]	@ (80006f0 <main+0x248>)
 8000646:	f003 fd71 	bl	800412c <xTimerCreate>
	xQueue_LEDColor = xQueueCreate(1, sizeof(LED_COLOR));
 800064a:	2101      	movs	r1, #1
	xCANRequest = xTimerCreate("CANRequest", pdMS_TO_TICKS(100), pdTRUE,
 800064c:	4b29      	ldr	r3, [pc, #164]	@ (80006f4 <main+0x24c>)
	xQueue_LEDColor = xQueueCreate(1, sizeof(LED_COLOR));
 800064e:	2200      	movs	r2, #0
	xCANRequest = xTimerCreate("CANRequest", pdMS_TO_TICKS(100), pdTRUE,
 8000650:	6018      	str	r0, [r3, #0]
	xQueue_LEDColor = xQueueCreate(1, sizeof(LED_COLOR));
 8000652:	4608      	mov	r0, r1
 8000654:	f001 fe4c 	bl	80022f0 <xQueueGenericCreate>
 8000658:	4604      	mov	r4, r0
 800065a:	4b27      	ldr	r3, [pc, #156]	@ (80006f8 <main+0x250>)
	xQueue_LED7Seg = xQueueCreate(1, sizeof(int32_t));
 800065c:	2200      	movs	r2, #0
 800065e:	2104      	movs	r1, #4
 8000660:	2001      	movs	r0, #1
	xQueue_LEDColor = xQueueCreate(1, sizeof(LED_COLOR));
 8000662:	601c      	str	r4, [r3, #0]
	xQueue_LED7Seg = xQueueCreate(1, sizeof(int32_t));
 8000664:	f001 fe44 	bl	80022f0 <xQueueGenericCreate>
 8000668:	4606      	mov	r6, r0
 800066a:	4d24      	ldr	r5, [pc, #144]	@ (80006fc <main+0x254>)
	xTaskCreate(TASK_LED7_DisplayValue, "LED7", 128, NULL, 1, NULL);
 800066c:	2400      	movs	r4, #0
 800066e:	2301      	movs	r3, #1
	xQueue_LED7Seg = xQueueCreate(1, sizeof(int32_t));
 8000670:	602e      	str	r6, [r5, #0]
	xTaskCreate(TASK_LEDColor_Control, "LEDColor", 128, NULL, 2, NULL);
 8000672:	2502      	movs	r5, #2
	xTaskCreate(TASK_LED7_DisplayValue, "LED7", 128, NULL, 1, NULL);
 8000674:	2280      	movs	r2, #128	@ 0x80
 8000676:	e9cd 3400 	strd	r3, r4, [sp]
 800067a:	4921      	ldr	r1, [pc, #132]	@ (8000700 <main+0x258>)
 800067c:	4623      	mov	r3, r4
 800067e:	4821      	ldr	r0, [pc, #132]	@ (8000704 <main+0x25c>)
 8000680:	f002 ffba 	bl	80035f8 <xTaskCreate>
	xTaskCreate(TASK_LEDColor_Control, "LEDColor", 128, NULL, 2, NULL);
 8000684:	e9cd 5400 	strd	r5, r4, [sp]
	xTaskCreate(TASK_ManagerPoint, "Manager", 128, NULL, 3, NULL);
 8000688:	2503      	movs	r5, #3
	xTaskCreate(TASK_LEDColor_Control, "LEDColor", 128, NULL, 2, NULL);
 800068a:	2280      	movs	r2, #128	@ 0x80
 800068c:	4623      	mov	r3, r4
 800068e:	491e      	ldr	r1, [pc, #120]	@ (8000708 <main+0x260>)
 8000690:	481e      	ldr	r0, [pc, #120]	@ (800070c <main+0x264>)
 8000692:	f002 ffb1 	bl	80035f8 <xTaskCreate>
	xTaskCreate(TASK_ManagerPoint, "Manager", 128, NULL, 3, NULL);
 8000696:	2280      	movs	r2, #128	@ 0x80
 8000698:	4623      	mov	r3, r4
 800069a:	491d      	ldr	r1, [pc, #116]	@ (8000710 <main+0x268>)
 800069c:	e9cd 5400 	strd	r5, r4, [sp]
 80006a0:	481c      	ldr	r0, [pc, #112]	@ (8000714 <main+0x26c>)
 80006a2:	f002 ffa9 	bl	80035f8 <xTaskCreate>
	vTaskStartScheduler();
 80006a6:	f003 f80f 	bl	80036c8 <vTaskStartScheduler>
	while (1) {
 80006aa:	e7fe      	b.n	80006aa <main+0x202>
 80006ac:	40021000 	.word	0x40021000
 80006b0:	40010800 	.word	0x40010800
 80006b4:	200008c4 	.word	0x200008c4
 80006b8:	40010c00 	.word	0x40010c00
 80006bc:	40006400 	.word	0x40006400
 80006c0:	2000087c 	.word	0x2000087c
 80006c4:	40013800 	.word	0x40013800
 80006c8:	20000840 	.word	0x20000840
 80006cc:	20000810 	.word	0x20000810
 80006d0:	e0001000 	.word	0xe0001000
 80006d4:	0007a120 	.word	0x0007a120
 80006d8:	080003e5 	.word	0x080003e5
 80006dc:	20000800 	.word	0x20000800
 80006e0:	200007fc 	.word	0x200007fc
 80006e4:	08006e28 	.word	0x08006e28
 80006e8:	200007f8 	.word	0x200007f8
 80006ec:	0800038d 	.word	0x0800038d
 80006f0:	08006e34 	.word	0x08006e34
 80006f4:	200007f4 	.word	0x200007f4
 80006f8:	20000808 	.word	0x20000808
 80006fc:	20000804 	.word	0x20000804
 8000700:	08006e40 	.word	0x08006e40
 8000704:	080007c9 	.word	0x080007c9
 8000708:	08006e48 	.word	0x08006e48
 800070c:	08000315 	.word	0x08000315
 8000710:	08006e54 	.word	0x08006e54
 8000714:	08000215 	.word	0x08000215

08000718 <LED7_Display>:
void LED7_Display(int32_t value) {
 8000718:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800071c:	4606      	mov	r6, r0
	uint8_t tens = value / 10;
 800071e:	4b27      	ldr	r3, [pc, #156]	@ (80007bc <LED7_Display+0xa4>)
 8000720:	17f7      	asrs	r7, r6, #31
 8000722:	fb83 4306 	smull	r4, r3, r3, r6
	for (int i = 7; i >= 0; i--) {
 8000726:	2407      	movs	r4, #7
	uint8_t tens = value / 10;
 8000728:	ebc7 07a3 	rsb	r7, r7, r3, asr #2
	HAL_GPIO_WritePin(LED7_PORT, LATCH_PIN, GPIO_PIN_RESET);
 800072c:	2200      	movs	r2, #0
 800072e:	2180      	movs	r1, #128	@ 0x80
 8000730:	4823      	ldr	r0, [pc, #140]	@ (80007c0 <LED7_Display+0xa8>)
 8000732:	f001 f845 	bl	80017c0 <HAL_GPIO_WritePin>
	uint8_t units = value % 10;
 8000736:	eb07 0387 	add.w	r3, r7, r7, lsl #2
		HAL_GPIO_WritePin(LED7_PORT, DATA_PIN, (Seg[units] >> i) & 0x01);
 800073a:	f8df 8088 	ldr.w	r8, [pc, #136]	@ 80007c4 <LED7_Display+0xac>
	uint8_t units = value % 10;
 800073e:	eba6 0643 	sub.w	r6, r6, r3, lsl #1
		HAL_GPIO_WritePin(LED7_PORT, DATA_PIN, (Seg[units] >> i) & 0x01);
 8000742:	b2f6      	uxtb	r6, r6
 8000744:	4d1e      	ldr	r5, [pc, #120]	@ (80007c0 <LED7_Display+0xa8>)
 8000746:	f818 6006 	ldrb.w	r6, [r8, r6]
 800074a:	fa46 f204 	asr.w	r2, r6, r4
 800074e:	2140      	movs	r1, #64	@ 0x40
 8000750:	4628      	mov	r0, r5
 8000752:	f002 0201 	and.w	r2, r2, #1
 8000756:	f001 f833 	bl	80017c0 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(LED7_PORT, CLOCK_PIN, GPIO_PIN_SET);
 800075a:	2201      	movs	r2, #1
 800075c:	f44f 7180 	mov.w	r1, #256	@ 0x100
 8000760:	4628      	mov	r0, r5
 8000762:	f001 f82d 	bl	80017c0 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(LED7_PORT, CLOCK_PIN, GPIO_PIN_RESET);
 8000766:	2200      	movs	r2, #0
 8000768:	f44f 7180 	mov.w	r1, #256	@ 0x100
 800076c:	4628      	mov	r0, r5
 800076e:	f001 f827 	bl	80017c0 <HAL_GPIO_WritePin>
	for (int i = 7; i >= 0; i--) {
 8000772:	3c01      	subs	r4, #1
 8000774:	d2e9      	bcs.n	800074a <LED7_Display+0x32>
	for (int i = 7; i >= 0; i--) {
 8000776:	2407      	movs	r4, #7
		HAL_GPIO_WritePin(LED7_PORT, DATA_PIN, (Seg[tens] >> i) & 0x01);
 8000778:	b2ff      	uxtb	r7, r7
 800077a:	f818 6007 	ldrb.w	r6, [r8, r7]
 800077e:	4d10      	ldr	r5, [pc, #64]	@ (80007c0 <LED7_Display+0xa8>)
 8000780:	fa46 f204 	asr.w	r2, r6, r4
 8000784:	2140      	movs	r1, #64	@ 0x40
 8000786:	4628      	mov	r0, r5
 8000788:	f002 0201 	and.w	r2, r2, #1
 800078c:	f001 f818 	bl	80017c0 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(LED7_PORT, CLOCK_PIN, GPIO_PIN_SET);
 8000790:	2201      	movs	r2, #1
 8000792:	f44f 7180 	mov.w	r1, #256	@ 0x100
 8000796:	4628      	mov	r0, r5
 8000798:	f001 f812 	bl	80017c0 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(LED7_PORT, CLOCK_PIN, GPIO_PIN_RESET);
 800079c:	2200      	movs	r2, #0
 800079e:	f44f 7180 	mov.w	r1, #256	@ 0x100
 80007a2:	4628      	mov	r0, r5
 80007a4:	f001 f80c 	bl	80017c0 <HAL_GPIO_WritePin>
	for (int i = 7; i >= 0; i--) {
 80007a8:	3c01      	subs	r4, #1
 80007aa:	d2e9      	bcs.n	8000780 <LED7_Display+0x68>
}
 80007ac:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	HAL_GPIO_WritePin(LED7_PORT, LATCH_PIN, GPIO_PIN_SET);
 80007b0:	2201      	movs	r2, #1
 80007b2:	2180      	movs	r1, #128	@ 0x80
 80007b4:	4802      	ldr	r0, [pc, #8]	@ (80007c0 <LED7_Display+0xa8>)
 80007b6:	f001 b803 	b.w	80017c0 <HAL_GPIO_WritePin>
 80007ba:	bf00      	nop
 80007bc:	66666667 	.word	0x66666667
 80007c0:	40010c00 	.word	0x40010c00
 80007c4:	08006f1c 	.word	0x08006f1c

080007c8 <TASK_LED7_DisplayValue>:
	int32_t LED7_Val = -1;
 80007c8:	f04f 32ff 	mov.w	r2, #4294967295
void TASK_LED7_DisplayValue(void *pvParams) {
 80007cc:	b580      	push	{r7, lr}
 80007ce:	b082      	sub	sp, #8
	int32_t LED7_Val = -1;
 80007d0:	4613      	mov	r3, r2
 80007d2:	4f1b      	ldr	r7, [pc, #108]	@ (8000840 <TASK_LED7_DisplayValue+0x78>)
 80007d4:	4e1b      	ldr	r6, [pc, #108]	@ (8000844 <TASK_LED7_DisplayValue+0x7c>)
 80007d6:	f8df 8070 	ldr.w	r8, [pc, #112]	@ 8000848 <TASK_LED7_DisplayValue+0x80>
 80007da:	4c1c      	ldr	r4, [pc, #112]	@ (800084c <TASK_LED7_DisplayValue+0x84>)
			SEGGER_SYSVIEW_PrintfTarget("abc");
 80007dc:	4d1c      	ldr	r5, [pc, #112]	@ (8000850 <TASK_LED7_DisplayValue+0x88>)
	int32_t LED7_Val = -1;
 80007de:	9201      	str	r2, [sp, #4]
 80007e0:	e010      	b.n	8000804 <TASK_LED7_DisplayValue+0x3c>
		if (LED7_Val == 5)
 80007e2:	2b05      	cmp	r3, #5
 80007e4:	d022      	beq.n	800082c <TASK_LED7_DisplayValue+0x64>
			SEGGER_SYSVIEW_PrintfTarget("abc");
 80007e6:	4628      	mov	r0, r5
 80007e8:	f006 f9b6 	bl	8006b58 <SEGGER_SYSVIEW_PrintfTarget>
			LED7_Display(LED7_Val--);
 80007ec:	9801      	ldr	r0, [sp, #4]
 80007ee:	1e43      	subs	r3, r0, #1
 80007f0:	9301      	str	r3, [sp, #4]
 80007f2:	f7ff ff91 	bl	8000718 <LED7_Display>
		station.remainSeconds = LED7_Val;
 80007f6:	9b01      	ldr	r3, [sp, #4]
		vTaskDelay(pdMS_TO_TICKS(1000));
 80007f8:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
		station.remainSeconds = LED7_Val;
 80007fc:	6063      	str	r3, [r4, #4]
		vTaskDelay(pdMS_TO_TICKS(1000));
 80007fe:	f002 ff2b 	bl	8003658 <vTaskDelay>
		if (LED7_Val < 0) {
 8000802:	9b01      	ldr	r3, [sp, #4]
 8000804:	2b00      	cmp	r3, #0
 8000806:	daec      	bge.n	80007e2 <TASK_LED7_DisplayValue+0x1a>
			xSemaphoreGive(xChangeState);
 8000808:	2300      	movs	r3, #0
 800080a:	6838      	ldr	r0, [r7, #0]
 800080c:	461a      	mov	r2, r3
 800080e:	4619      	mov	r1, r3
 8000810:	f001 fdb6 	bl	8002380 <xQueueGenericSend>
			xQueueReceive(xQueue_LED7Seg, &LED7_Val, portMAX_DELAY);
 8000814:	f04f 32ff 	mov.w	r2, #4294967295
 8000818:	6830      	ldr	r0, [r6, #0]
 800081a:	a901      	add	r1, sp, #4
 800081c:	f001 ffbc 	bl	8002798 <xQueueReceive>
		if (LED7_Val == 5)
 8000820:	9b01      	ldr	r3, [sp, #4]
 8000822:	2b05      	cmp	r3, #5
 8000824:	d002      	beq.n	800082c <TASK_LED7_DisplayValue+0x64>
		if (LED7_Val >= 0) {
 8000826:	2b00      	cmp	r3, #0
 8000828:	dbe6      	blt.n	80007f8 <TASK_LED7_DisplayValue+0x30>
 800082a:	e7dc      	b.n	80007e6 <TASK_LED7_DisplayValue+0x1e>
			xSemaphoreGive(xGetReq);
 800082c:	2300      	movs	r3, #0
 800082e:	f8d8 0000 	ldr.w	r0, [r8]
 8000832:	461a      	mov	r2, r3
 8000834:	4619      	mov	r1, r3
 8000836:	f001 fda3 	bl	8002380 <xQueueGenericSend>
		if (LED7_Val >= 0) {
 800083a:	9b01      	ldr	r3, [sp, #4]
 800083c:	e7f3      	b.n	8000826 <TASK_LED7_DisplayValue+0x5e>
 800083e:	bf00      	nop
 8000840:	20000800 	.word	0x20000800
 8000844:	20000804 	.word	0x20000804
 8000848:	200007fc 	.word	0x200007fc
 800084c:	20000000 	.word	0x20000000
 8000850:	08006e5c 	.word	0x08006e5c

08000854 <HAL_CAN_RxFifo0MsgPendingCallback>:
void HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef *hcan1) {
 8000854:	b5f0      	push	{r4, r5, r6, r7, lr}
	HAL_CAN_GetRxMessage(hcan1, CAN_RX_FIFO0, &rxHeader, canRX);
 8000856:	4c2c      	ldr	r4, [pc, #176]	@ (8000908 <HAL_CAN_RxFifo0MsgPendingCallback+0xb4>)
 8000858:	4d2c      	ldr	r5, [pc, #176]	@ (800090c <HAL_CAN_RxFifo0MsgPendingCallback+0xb8>)
 800085a:	4622      	mov	r2, r4
 800085c:	462b      	mov	r3, r5
 800085e:	2100      	movs	r1, #0
void HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef *hcan1) {
 8000860:	b085      	sub	sp, #20
	HAL_CAN_GetRxMessage(hcan1, CAN_RX_FIFO0, &rxHeader, canRX);
 8000862:	f000 fb53 	bl	8000f0c <HAL_CAN_GetRxMessage>
	uint8_t destAddr = (rxHeader.StdId >> 8) & 0xFF;
 8000866:	6822      	ldr	r2, [r4, #0]
	if (destAddr != MY_ADDR || srcAddr != CONTROLLER_ADDR)
 8000868:	f3c2 2307 	ubfx	r3, r2, #8, #8
 800086c:	2b01      	cmp	r3, #1
 800086e:	d102      	bne.n	8000876 <HAL_CAN_RxFifo0MsgPendingCallback+0x22>
 8000870:	b2d2      	uxtb	r2, r2
 8000872:	2aaf      	cmp	r2, #175	@ 0xaf
 8000874:	d001      	beq.n	800087a <HAL_CAN_RxFifo0MsgPendingCallback+0x26>
}
 8000876:	b005      	add	sp, #20
 8000878:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (cmd != CMD_RESPONSE)
 800087a:	882e      	ldrh	r6, [r5, #0]
 800087c:	886b      	ldrh	r3, [r5, #2]
 800087e:	2e01      	cmp	r6, #1
 8000880:	686f      	ldr	r7, [r5, #4]
 8000882:	d1f8      	bne.n	8000876 <HAL_CAN_RxFifo0MsgPendingCallback+0x22>
	BaseType_t xHigherPriorityTaskWoken = pdFALSE;
 8000884:	2500      	movs	r5, #0
	xTimerStopFromISR(xCANRequest, &xHigherPriorityTaskWoken);
 8000886:	4a22      	ldr	r2, [pc, #136]	@ (8000910 <HAL_CAN_RxFifo0MsgPendingCallback+0xbc>)
 8000888:	ba5b      	rev16	r3, r3
 800088a:	6810      	ldr	r0, [r2, #0]
 800088c:	b29c      	uxth	r4, r3
 800088e:	2108      	movs	r1, #8
 8000890:	ab03      	add	r3, sp, #12
 8000892:	462a      	mov	r2, r5
 8000894:	9500      	str	r5, [sp, #0]
	BaseType_t xHigherPriorityTaskWoken = pdFALSE;
 8000896:	9503      	str	r5, [sp, #12]
	xTimerStopFromISR(xCANRequest, &xHigherPriorityTaskWoken);
 8000898:	f003 fcb0 	bl	80041fc <xTimerGenericCommand>
	if (ledColor < LEDColor_RED || ledColor > LEDColor_GREEN)
 800089c:	1e63      	subs	r3, r4, #1
 800089e:	2b02      	cmp	r3, #2
 80008a0:	d8e9      	bhi.n	8000876 <HAL_CAN_RxFifo0MsgPendingCallback+0x22>
	canTxData[3] = led_color & 0xFF;
 80008a2:	4628      	mov	r0, r5
	station.isResp = true;
 80008a4:	4a1b      	ldr	r2, [pc, #108]	@ (8000914 <HAL_CAN_RxFifo0MsgPendingCallback+0xc0>)
	station.initSeconds[ledColor] = timeCounter;
 80008a6:	3402      	adds	r4, #2
 80008a8:	ba3f      	rev	r7, r7
 80008aa:	f842 7024 	str.w	r7, [r2, r4, lsl #2]
	canTxData[0] = (cmd >> 8) & 0xFF;
 80008ae:	f44f 7400 	mov.w	r4, #512	@ 0x200
			(uint32_t) station.remainSeconds);
 80008b2:	6853      	ldr	r3, [r2, #4]
	CAN_SendMessage(CMD_ACK, station.currentColor,
 80008b4:	7811      	ldrb	r1, [r2, #0]
	station.isResp = true;
 80008b6:	7616      	strb	r6, [r2, #24]
	canTxData[3] = led_color & 0xFF;
 80008b8:	f361 0007 	bfi	r0, r1, #0, #8
	canTxData[0] = (cmd >> 8) & 0xFF;
 80008bc:	4a16      	ldr	r2, [pc, #88]	@ (8000918 <HAL_CAN_RxFifo0MsgPendingCallback+0xc4>)
	canTxData[4] = (time_counter >> 24) & 0xFF;
 80008be:	0e19      	lsrs	r1, r3, #24
	canTxData[3] = led_color & 0xFF;
 80008c0:	f361 200f 	bfi	r0, r1, #8, #8
	canTxData[5] = (time_counter >> 16) & 0xFF;
 80008c4:	0c19      	lsrs	r1, r3, #16
	canTxData[7] = time_counter & 0xFF;
 80008c6:	71d3      	strb	r3, [r2, #7]
	canTxData[3] = led_color & 0xFF;
 80008c8:	f361 4017 	bfi	r0, r1, #16, #8
	canTxData[6] = (time_counter >> 8) & 0xFF;
 80008cc:	0a1b      	lsrs	r3, r3, #8
	canTxData[3] = led_color & 0xFF;
 80008ce:	f363 601f 	bfi	r0, r3, #24, #8
 80008d2:	f8c2 0003 	str.w	r0, [r2, #3]
	HAL_CAN_AddTxMessage(&hcan, &txHeader, canTxData, &canMailbox);
 80008d6:	4b11      	ldr	r3, [pc, #68]	@ (800091c <HAL_CAN_RxFifo0MsgPendingCallback+0xc8>)
 80008d8:	4911      	ldr	r1, [pc, #68]	@ (8000920 <HAL_CAN_RxFifo0MsgPendingCallback+0xcc>)
 80008da:	4812      	ldr	r0, [pc, #72]	@ (8000924 <HAL_CAN_RxFifo0MsgPendingCallback+0xd0>)
	canTxData[2] = (led_color >> 8) & 0xFF;
 80008dc:	7095      	strb	r5, [r2, #2]
	canTxData[0] = (cmd >> 8) & 0xFF;
 80008de:	8014      	strh	r4, [r2, #0]
	HAL_CAN_AddTxMessage(&hcan, &txHeader, canTxData, &canMailbox);
 80008e0:	f000 fac2 	bl	8000e68 <HAL_CAN_AddTxMessage>
	portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
 80008e4:	9b03      	ldr	r3, [sp, #12]
 80008e6:	b163      	cbz	r3, 8000902 <HAL_CAN_RxFifo0MsgPendingCallback+0xae>
 80008e8:	f005 ff3c 	bl	8006764 <SEGGER_SYSVIEW_RecordExitISRToScheduler>
 80008ec:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 80008f0:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 80008f4:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 80008f8:	f3bf 8f4f 	dsb	sy
 80008fc:	f3bf 8f6f 	isb	sy
 8000900:	e7b9      	b.n	8000876 <HAL_CAN_RxFifo0MsgPendingCallback+0x22>
 8000902:	f005 fea1 	bl	8006648 <SEGGER_SYSVIEW_RecordExitISR>
 8000906:	e7b6      	b.n	8000876 <HAL_CAN_RxFifo0MsgPendingCallback+0x22>
 8000908:	20000858 	.word	0x20000858
 800090c:	20000838 	.word	0x20000838
 8000910:	200007f4 	.word	0x200007f4
 8000914:	20000000 	.word	0x20000000
 8000918:	20000874 	.word	0x20000874
 800091c:	2000080c 	.word	0x2000080c
 8000920:	20000840 	.word	0x20000840
 8000924:	200008c4 	.word	0x200008c4

08000928 <HAL_TIM_PeriodElapsedCallback>:
	if (htim->Instance == TIM1) {
 8000928:	4b03      	ldr	r3, [pc, #12]	@ (8000938 <HAL_TIM_PeriodElapsedCallback+0x10>)
 800092a:	6802      	ldr	r2, [r0, #0]
 800092c:	429a      	cmp	r2, r3
 800092e:	d000      	beq.n	8000932 <HAL_TIM_PeriodElapsedCallback+0xa>
}
 8000930:	4770      	bx	lr
		HAL_IncTick();
 8000932:	f000 b949 	b.w	8000bc8 <HAL_IncTick>
 8000936:	bf00      	nop
 8000938:	40012c00 	.word	0x40012c00

0800093c <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 800093c:	b510      	push	{r4, lr}

  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_AFIO_CLK_ENABLE();
 800093e:	4b11      	ldr	r3, [pc, #68]	@ (8000984 <HAL_MspInit+0x48>)
{
 8000940:	b082      	sub	sp, #8
  __HAL_RCC_AFIO_CLK_ENABLE();
 8000942:	6998      	ldr	r0, [r3, #24]
  __HAL_RCC_PWR_CLK_ENABLE();

  /* System interrupt init*/
  /* PendSV_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PendSV_IRQn, 15, 0);
 8000944:	2200      	movs	r2, #0
  __HAL_RCC_AFIO_CLK_ENABLE();
 8000946:	f040 0001 	orr.w	r0, r0, #1
 800094a:	6198      	str	r0, [r3, #24]
 800094c:	699c      	ldr	r4, [r3, #24]
  HAL_NVIC_SetPriority(PendSV_IRQn, 15, 0);
 800094e:	210f      	movs	r1, #15
  __HAL_RCC_AFIO_CLK_ENABLE();
 8000950:	f004 0401 	and.w	r4, r4, #1
 8000954:	9400      	str	r4, [sp, #0]
 8000956:	9c00      	ldr	r4, [sp, #0]
  __HAL_RCC_PWR_CLK_ENABLE();
 8000958:	69dc      	ldr	r4, [r3, #28]
  HAL_NVIC_SetPriority(PendSV_IRQn, 15, 0);
 800095a:	f06f 0001 	mvn.w	r0, #1
  __HAL_RCC_PWR_CLK_ENABLE();
 800095e:	f044 5480 	orr.w	r4, r4, #268435456	@ 0x10000000
 8000962:	61dc      	str	r4, [r3, #28]
 8000964:	69db      	ldr	r3, [r3, #28]
 8000966:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 800096a:	9301      	str	r3, [sp, #4]
 800096c:	9b01      	ldr	r3, [sp, #4]
  HAL_NVIC_SetPriority(PendSV_IRQn, 15, 0);
 800096e:	f000 fce3 	bl	8001338 <HAL_NVIC_SetPriority>

  /** NOJTAG: JTAG-DP Disabled and SW-DP Enabled
  */
  __HAL_AFIO_REMAP_SWJ_NOJTAG();
 8000972:	4a05      	ldr	r2, [pc, #20]	@ (8000988 <HAL_MspInit+0x4c>)
 8000974:	6853      	ldr	r3, [r2, #4]
 8000976:	f023 63e0 	bic.w	r3, r3, #117440512	@ 0x7000000
 800097a:	f043 7300 	orr.w	r3, r3, #33554432	@ 0x2000000
 800097e:	6053      	str	r3, [r2, #4]

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 8000980:	b002      	add	sp, #8
 8000982:	bd10      	pop	{r4, pc}
 8000984:	40021000 	.word	0x40021000
 8000988:	40010000 	.word	0x40010000

0800098c <HAL_CAN_MspInit>:
  * This function configures the hardware resources used in this example
  * @param hcan: CAN handle pointer
  * @retval None
  */
void HAL_CAN_MspInit(CAN_HandleTypeDef* hcan)
{
 800098c:	b5d0      	push	{r4, r6, r7, lr}
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800098e:	2400      	movs	r4, #0
  if(hcan->Instance==CAN1)
 8000990:	4b1e      	ldr	r3, [pc, #120]	@ (8000a0c <HAL_CAN_MspInit+0x80>)
 8000992:	6802      	ldr	r2, [r0, #0]
{
 8000994:	b086      	sub	sp, #24
  if(hcan->Instance==CAN1)
 8000996:	429a      	cmp	r2, r3
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8000998:	e9cd 4402 	strd	r4, r4, [sp, #8]
 800099c:	e9cd 4404 	strd	r4, r4, [sp, #16]
  if(hcan->Instance==CAN1)
 80009a0:	d001      	beq.n	80009a6 <HAL_CAN_MspInit+0x1a>

    /* USER CODE END CAN1_MspInit 1 */

  }

}
 80009a2:	b006      	add	sp, #24
 80009a4:	bdd0      	pop	{r4, r6, r7, pc}
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 80009a6:	2001      	movs	r0, #1
    GPIO_InitStruct.Pin = GPIO_PIN_11;
 80009a8:	f44f 6600 	mov.w	r6, #2048	@ 0x800
    __HAL_RCC_CAN1_CLK_ENABLE();
 80009ac:	f503 33d6 	add.w	r3, r3, #109568	@ 0x1ac00
 80009b0:	69da      	ldr	r2, [r3, #28]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80009b2:	a902      	add	r1, sp, #8
    __HAL_RCC_CAN1_CLK_ENABLE();
 80009b4:	f042 7200 	orr.w	r2, r2, #33554432	@ 0x2000000
 80009b8:	61da      	str	r2, [r3, #28]
 80009ba:	69da      	ldr	r2, [r3, #28]
    GPIO_InitStruct.Pin = GPIO_PIN_12;
 80009bc:	2702      	movs	r7, #2
    __HAL_RCC_CAN1_CLK_ENABLE();
 80009be:	f002 7200 	and.w	r2, r2, #33554432	@ 0x2000000
 80009c2:	9200      	str	r2, [sp, #0]
 80009c4:	9a00      	ldr	r2, [sp, #0]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80009c6:	699a      	ldr	r2, [r3, #24]
 80009c8:	f042 0204 	orr.w	r2, r2, #4
 80009cc:	619a      	str	r2, [r3, #24]
 80009ce:	699b      	ldr	r3, [r3, #24]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 80009d0:	9004      	str	r0, [sp, #16]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80009d2:	f003 0304 	and.w	r3, r3, #4
 80009d6:	9301      	str	r3, [sp, #4]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80009d8:	480d      	ldr	r0, [pc, #52]	@ (8000a10 <HAL_CAN_MspInit+0x84>)
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80009da:	9b01      	ldr	r3, [sp, #4]
    GPIO_InitStruct.Pin = GPIO_PIN_11;
 80009dc:	9602      	str	r6, [sp, #8]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80009de:	f000 fcf5 	bl	80013cc <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_12;
 80009e2:	f44f 5680 	mov.w	r6, #4096	@ 0x1000
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 80009e6:	2303      	movs	r3, #3
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80009e8:	a902      	add	r1, sp, #8
 80009ea:	4809      	ldr	r0, [pc, #36]	@ (8000a10 <HAL_CAN_MspInit+0x84>)
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 80009ec:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Pin = GPIO_PIN_12;
 80009ee:	e9cd 6702 	strd	r6, r7, [sp, #8]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80009f2:	f000 fceb 	bl	80013cc <HAL_GPIO_Init>
    HAL_NVIC_SetPriority(USB_LP_CAN1_RX0_IRQn, 5, 0);
 80009f6:	4622      	mov	r2, r4
 80009f8:	2105      	movs	r1, #5
 80009fa:	2014      	movs	r0, #20
 80009fc:	f000 fc9c 	bl	8001338 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USB_LP_CAN1_RX0_IRQn);
 8000a00:	2014      	movs	r0, #20
 8000a02:	f000 fcd5 	bl	80013b0 <HAL_NVIC_EnableIRQ>
}
 8000a06:	b006      	add	sp, #24
 8000a08:	bdd0      	pop	{r4, r6, r7, pc}
 8000a0a:	bf00      	nop
 8000a0c:	40006400 	.word	0x40006400
 8000a10:	40010800 	.word	0x40010800

08000a14 <HAL_UART_MspInit>:
  * This function configures the hardware resources used in this example
  * @param huart: UART handle pointer
  * @retval None
  */
void HAL_UART_MspInit(UART_HandleTypeDef* huart)
{
 8000a14:	b5d0      	push	{r4, r6, r7, lr}
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8000a16:	2400      	movs	r4, #0
  if(huart->Instance==USART1)
 8000a18:	4b1a      	ldr	r3, [pc, #104]	@ (8000a84 <HAL_UART_MspInit+0x70>)
 8000a1a:	6802      	ldr	r2, [r0, #0]
{
 8000a1c:	b086      	sub	sp, #24
  if(huart->Instance==USART1)
 8000a1e:	429a      	cmp	r2, r3
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8000a20:	e9cd 4402 	strd	r4, r4, [sp, #8]
 8000a24:	e9cd 4404 	strd	r4, r4, [sp, #16]
  if(huart->Instance==USART1)
 8000a28:	d001      	beq.n	8000a2e <HAL_UART_MspInit+0x1a>

    /* USER CODE END USART1_MspInit 1 */

  }

}
 8000a2a:	b006      	add	sp, #24
 8000a2c:	bdd0      	pop	{r4, r6, r7, pc}
    __HAL_RCC_USART1_CLK_ENABLE();
 8000a2e:	f503 4358 	add.w	r3, r3, #55296	@ 0xd800
 8000a32:	699a      	ldr	r2, [r3, #24]
    GPIO_InitStruct.Pin = GPIO_PIN_9;
 8000a34:	f44f 7600 	mov.w	r6, #512	@ 0x200
    __HAL_RCC_USART1_CLK_ENABLE();
 8000a38:	f442 4280 	orr.w	r2, r2, #16384	@ 0x4000
 8000a3c:	619a      	str	r2, [r3, #24]
 8000a3e:	699a      	ldr	r2, [r3, #24]
    GPIO_InitStruct.Pin = GPIO_PIN_9;
 8000a40:	2702      	movs	r7, #2
    __HAL_RCC_USART1_CLK_ENABLE();
 8000a42:	f402 4280 	and.w	r2, r2, #16384	@ 0x4000
 8000a46:	9200      	str	r2, [sp, #0]
 8000a48:	9a00      	ldr	r2, [sp, #0]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8000a4a:	699a      	ldr	r2, [r3, #24]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8000a4c:	a902      	add	r1, sp, #8
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8000a4e:	f042 0204 	orr.w	r2, r2, #4
 8000a52:	619a      	str	r2, [r3, #24]
 8000a54:	699b      	ldr	r3, [r3, #24]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8000a56:	480c      	ldr	r0, [pc, #48]	@ (8000a88 <HAL_UART_MspInit+0x74>)
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8000a58:	f003 0304 	and.w	r3, r3, #4
 8000a5c:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8000a5e:	2303      	movs	r3, #3
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8000a60:	9a01      	ldr	r2, [sp, #4]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8000a62:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Pin = GPIO_PIN_9;
 8000a64:	e9cd 6702 	strd	r6, r7, [sp, #8]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8000a68:	f000 fcb0 	bl	80013cc <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_10;
 8000a6c:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 8000a70:	2300      	movs	r3, #0
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8000a72:	4805      	ldr	r0, [pc, #20]	@ (8000a88 <HAL_UART_MspInit+0x74>)
 8000a74:	a902      	add	r1, sp, #8
    GPIO_InitStruct.Pin = GPIO_PIN_10;
 8000a76:	e9cd 2302 	strd	r2, r3, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000a7a:	9404      	str	r4, [sp, #16]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8000a7c:	f000 fca6 	bl	80013cc <HAL_GPIO_Init>
}
 8000a80:	b006      	add	sp, #24
 8000a82:	bdd0      	pop	{r4, r6, r7, pc}
 8000a84:	40013800 	.word	0x40013800
 8000a88:	40010800 	.word	0x40010800

08000a8c <HAL_InitTick>:
  *         reset by HAL_Init() or at any time when clock is configured, by HAL_RCC_ClockConfig().
  * @param  TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8000a8c:	b570      	push	{r4, r5, r6, lr}
  uint32_t              pFLatency;

  HAL_StatusTypeDef     status = HAL_OK;

  /* Enable TIM1 clock */
  __HAL_RCC_TIM1_CLK_ENABLE();
 8000a8e:	4b20      	ldr	r3, [pc, #128]	@ (8000b10 <HAL_InitTick+0x84>)
{
 8000a90:	b088      	sub	sp, #32
  __HAL_RCC_TIM1_CLK_ENABLE();
 8000a92:	699a      	ldr	r2, [r3, #24]

  /* Get clock configuration */
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 8000a94:	a901      	add	r1, sp, #4
  __HAL_RCC_TIM1_CLK_ENABLE();
 8000a96:	f442 6200 	orr.w	r2, r2, #2048	@ 0x800
 8000a9a:	619a      	str	r2, [r3, #24]
 8000a9c:	699b      	ldr	r3, [r3, #24]
{
 8000a9e:	4606      	mov	r6, r0
  __HAL_RCC_TIM1_CLK_ENABLE();
 8000aa0:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 8000aa4:	a803      	add	r0, sp, #12
  __HAL_RCC_TIM1_CLK_ENABLE();
 8000aa6:	9302      	str	r3, [sp, #8]
 8000aa8:	9b02      	ldr	r3, [sp, #8]
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 8000aaa:	f001 f95d 	bl	8001d68 <HAL_RCC_GetClockConfig>

  /* Compute TIM1 clock */
      uwTimclock = HAL_RCC_GetPCLK2Freq();
 8000aae:	f001 f94b 	bl	8001d48 <HAL_RCC_GetPCLK2Freq>
 8000ab2:	4603      	mov	r3, r0
   * ClockDivision = 0
   * Counter direction = Up
   */
  htim1.Init.Period = (1000000U / 1000U) - 1U;
  htim1.Init.Prescaler = uwPrescalerValue;
  htim1.Init.ClockDivision = 0;
 8000ab4:	2200      	movs	r2, #0
  htim1.Init.Period = (1000000U / 1000U) - 1U;
 8000ab6:	f240 30e7 	movw	r0, #999	@ 0x3e7
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);
 8000aba:	4916      	ldr	r1, [pc, #88]	@ (8000b14 <HAL_InitTick+0x88>)
  htim1.Instance = TIM1;
 8000abc:	4c16      	ldr	r4, [pc, #88]	@ (8000b18 <HAL_InitTick+0x8c>)
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);
 8000abe:	fba1 1303 	umull	r1, r3, r1, r3
  htim1.Init.ClockDivision = 0;
 8000ac2:	e9c4 0203 	strd	r0, r2, [r4, #12]
  htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
 8000ac6:	60a2      	str	r2, [r4, #8]
  htim1.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 8000ac8:	61a2      	str	r2, [r4, #24]
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);
 8000aca:	0c9b      	lsrs	r3, r3, #18
  htim1.Instance = TIM1;
 8000acc:	4a13      	ldr	r2, [pc, #76]	@ (8000b1c <HAL_InitTick+0x90>)
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);
 8000ace:	3b01      	subs	r3, #1

  status = HAL_TIM_Base_Init(&htim1);
 8000ad0:	4620      	mov	r0, r4
  htim1.Instance = TIM1;
 8000ad2:	6022      	str	r2, [r4, #0]
  htim1.Init.Prescaler = uwPrescalerValue;
 8000ad4:	6063      	str	r3, [r4, #4]
  status = HAL_TIM_Base_Init(&htim1);
 8000ad6:	f001 f969 	bl	8001dac <HAL_TIM_Base_Init>
  if (status == HAL_OK)
 8000ada:	4605      	mov	r5, r0
 8000adc:	b110      	cbz	r0, 8000ae4 <HAL_InitTick+0x58>
    }
  }

 /* Return function status */
  return status;
}
 8000ade:	4628      	mov	r0, r5
 8000ae0:	b008      	add	sp, #32
 8000ae2:	bd70      	pop	{r4, r5, r6, pc}
    status = HAL_TIM_Base_Start_IT(&htim1);
 8000ae4:	4620      	mov	r0, r4
 8000ae6:	f001 f9c9 	bl	8001e7c <HAL_TIM_Base_Start_IT>
    if (status == HAL_OK)
 8000aea:	4605      	mov	r5, r0
 8000aec:	2800      	cmp	r0, #0
 8000aee:	d1f6      	bne.n	8000ade <HAL_InitTick+0x52>
        HAL_NVIC_EnableIRQ(TIM1_UP_IRQn);
 8000af0:	2019      	movs	r0, #25
 8000af2:	f000 fc5d 	bl	80013b0 <HAL_NVIC_EnableIRQ>
      if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 8000af6:	2e0f      	cmp	r6, #15
 8000af8:	d901      	bls.n	8000afe <HAL_InitTick+0x72>
        status = HAL_ERROR;
 8000afa:	2501      	movs	r5, #1
 8000afc:	e7ef      	b.n	8000ade <HAL_InitTick+0x52>
        HAL_NVIC_SetPriority(TIM1_UP_IRQn, TickPriority, 0U);
 8000afe:	462a      	mov	r2, r5
 8000b00:	4631      	mov	r1, r6
 8000b02:	2019      	movs	r0, #25
 8000b04:	f000 fc18 	bl	8001338 <HAL_NVIC_SetPriority>
        uwTickPrio = TickPriority;
 8000b08:	4b05      	ldr	r3, [pc, #20]	@ (8000b20 <HAL_InitTick+0x94>)
 8000b0a:	601e      	str	r6, [r3, #0]
 8000b0c:	e7e7      	b.n	8000ade <HAL_InitTick+0x52>
 8000b0e:	bf00      	nop
 8000b10:	40021000 	.word	0x40021000
 8000b14:	431bde83 	.word	0x431bde83
 8000b18:	200008ec 	.word	0x200008ec
 8000b1c:	40012c00 	.word	0x40012c00
 8000b20:	20000024 	.word	0x20000024

08000b24 <NMI_Handler>:
{
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
   while (1)
 8000b24:	e7fe      	b.n	8000b24 <NMI_Handler>
 8000b26:	bf00      	nop

08000b28 <HardFault_Handler>:
void HardFault_Handler(void)
{
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 8000b28:	e7fe      	b.n	8000b28 <HardFault_Handler>
 8000b2a:	bf00      	nop

08000b2c <MemManage_Handler>:
void MemManage_Handler(void)
{
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 8000b2c:	e7fe      	b.n	8000b2c <MemManage_Handler>
 8000b2e:	bf00      	nop

08000b30 <BusFault_Handler>:
void BusFault_Handler(void)
{
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 8000b30:	e7fe      	b.n	8000b30 <BusFault_Handler>
 8000b32:	bf00      	nop

08000b34 <UsageFault_Handler>:
void UsageFault_Handler(void)
{
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 8000b34:	e7fe      	b.n	8000b34 <UsageFault_Handler>
 8000b36:	bf00      	nop

08000b38 <DebugMon_Handler>:

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
 8000b38:	4770      	bx	lr
 8000b3a:	bf00      	nop

08000b3c <USB_LP_CAN1_RX0_IRQHandler>:
void USB_LP_CAN1_RX0_IRQHandler(void)
{
  /* USER CODE BEGIN USB_LP_CAN1_RX0_IRQn 0 */

  /* USER CODE END USB_LP_CAN1_RX0_IRQn 0 */
  HAL_CAN_IRQHandler(&hcan);
 8000b3c:	4801      	ldr	r0, [pc, #4]	@ (8000b44 <USB_LP_CAN1_RX0_IRQHandler+0x8>)
 8000b3e:	f000 ba93 	b.w	8001068 <HAL_CAN_IRQHandler>
 8000b42:	bf00      	nop
 8000b44:	200008c4 	.word	0x200008c4

08000b48 <TIM1_UP_IRQHandler>:
void TIM1_UP_IRQHandler(void)
{
  /* USER CODE BEGIN TIM1_UP_IRQn 0 */

  /* USER CODE END TIM1_UP_IRQn 0 */
  HAL_TIM_IRQHandler(&htim1);
 8000b48:	4801      	ldr	r0, [pc, #4]	@ (8000b50 <TIM1_UP_IRQHandler+0x8>)
 8000b4a:	f001 b9c7 	b.w	8001edc <HAL_TIM_IRQHandler>
 8000b4e:	bf00      	nop
 8000b50:	200008ec 	.word	0x200008ec

08000b54 <SystemInit>:

  /* Configure the Vector Table location -------------------------------------*/
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */
#endif /* USER_VECT_TAB_ADDRESS */
}
 8000b54:	4770      	bx	lr
 8000b56:	bf00      	nop

08000b58 <Reset_Handler>:
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:

/* Call the clock system initialization function.*/
    bl  SystemInit
 8000b58:	f7ff fffc 	bl	8000b54 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 8000b5c:	480b      	ldr	r0, [pc, #44]	@ (8000b8c <LoopFillZerobss+0xe>)
  ldr r1, =_edata
 8000b5e:	490c      	ldr	r1, [pc, #48]	@ (8000b90 <LoopFillZerobss+0x12>)
  ldr r2, =_sidata
 8000b60:	4a0c      	ldr	r2, [pc, #48]	@ (8000b94 <LoopFillZerobss+0x16>)
  movs r3, #0
 8000b62:	2300      	movs	r3, #0
  b LoopCopyDataInit
 8000b64:	e002      	b.n	8000b6c <LoopCopyDataInit>

08000b66 <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 8000b66:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8000b68:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 8000b6a:	3304      	adds	r3, #4

08000b6c <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 8000b6c:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 8000b6e:	428c      	cmp	r4, r1
  bcc CopyDataInit
 8000b70:	d3f9      	bcc.n	8000b66 <CopyDataInit>
  
/* Zero fill the bss segment. */
  ldr r2, =_sbss
 8000b72:	4a09      	ldr	r2, [pc, #36]	@ (8000b98 <LoopFillZerobss+0x1a>)
  ldr r4, =_ebss
 8000b74:	4c09      	ldr	r4, [pc, #36]	@ (8000b9c <LoopFillZerobss+0x1e>)
  movs r3, #0
 8000b76:	2300      	movs	r3, #0
  b LoopFillZerobss
 8000b78:	e001      	b.n	8000b7e <LoopFillZerobss>

08000b7a <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 8000b7a:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 8000b7c:	3204      	adds	r2, #4

08000b7e <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 8000b7e:	42a2      	cmp	r2, r4
  bcc FillZerobss
 8000b80:	d3fb      	bcc.n	8000b7a <FillZerobss>

/* Call static constructors */
    bl __libc_init_array
 8000b82:	f006 f8b9 	bl	8006cf8 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 8000b86:	f7ff fc8f 	bl	80004a8 <main>
  bx lr
 8000b8a:	4770      	bx	lr
  ldr r0, =_sdata
 8000b8c:	20000000 	.word	0x20000000
  ldr r1, =_edata
 8000b90:	20000084 	.word	0x20000084
  ldr r2, =_sidata
 8000b94:	08006f84 	.word	0x08006f84
  ldr r2, =_sbss
 8000b98:	20000088 	.word	0x20000088
  ldr r4, =_ebss
 8000b9c:	20001f8c 	.word	0x20001f8c

08000ba0 <ADC1_2_IRQHandler>:
 * @retval : None
*/
    .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 8000ba0:	e7fe      	b.n	8000ba0 <ADC1_2_IRQHandler>
	...

08000ba4 <HAL_Init>:
    defined(STM32F102x6) || defined(STM32F102xB) || \
    defined(STM32F103x6) || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG) || \
    defined(STM32F105xC) || defined(STM32F107xC)

  /* Prefetch buffer is not available on value line devices */
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8000ba4:	4a07      	ldr	r2, [pc, #28]	@ (8000bc4 <HAL_Init+0x20>)
{
 8000ba6:	b508      	push	{r3, lr}
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8000ba8:	6813      	ldr	r3, [r2, #0]
#endif
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8000baa:	2003      	movs	r0, #3
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8000bac:	f043 0310 	orr.w	r3, r3, #16
 8000bb0:	6013      	str	r3, [r2, #0]
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8000bb2:	f000 fbaf 	bl	8001314 <HAL_NVIC_SetPriorityGrouping>

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
 8000bb6:	200f      	movs	r0, #15
 8000bb8:	f7ff ff68 	bl	8000a8c <HAL_InitTick>

  /* Init the low level hardware */
  HAL_MspInit();
 8000bbc:	f7ff febe 	bl	800093c <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
}
 8000bc0:	2000      	movs	r0, #0
 8000bc2:	bd08      	pop	{r3, pc}
 8000bc4:	40022000 	.word	0x40022000

08000bc8 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += uwTickFreq;
 8000bc8:	4a03      	ldr	r2, [pc, #12]	@ (8000bd8 <HAL_IncTick+0x10>)
 8000bca:	4b04      	ldr	r3, [pc, #16]	@ (8000bdc <HAL_IncTick+0x14>)
 8000bcc:	6811      	ldr	r1, [r2, #0]
 8000bce:	781b      	ldrb	r3, [r3, #0]
 8000bd0:	440b      	add	r3, r1
 8000bd2:	6013      	str	r3, [r2, #0]
}
 8000bd4:	4770      	bx	lr
 8000bd6:	bf00      	nop
 8000bd8:	20000934 	.word	0x20000934
 8000bdc:	20000020 	.word	0x20000020

08000be0 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8000be0:	4b01      	ldr	r3, [pc, #4]	@ (8000be8 <HAL_GetTick+0x8>)
 8000be2:	6818      	ldr	r0, [r3, #0]
}
 8000be4:	4770      	bx	lr
 8000be6:	bf00      	nop
 8000be8:	20000934 	.word	0x20000934

08000bec <HAL_Delay>:
  *       implementations in user file.
  * @param Delay specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 8000bec:	b538      	push	{r3, r4, r5, lr}
 8000bee:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 8000bf0:	f7ff fff6 	bl	8000be0 <HAL_GetTick>
  uint32_t wait = Delay;

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 8000bf4:	1c63      	adds	r3, r4, #1
  uint32_t tickstart = HAL_GetTick();
 8000bf6:	4605      	mov	r5, r0
  if (wait < HAL_MAX_DELAY)
 8000bf8:	d002      	beq.n	8000c00 <HAL_Delay+0x14>
  {
    wait += (uint32_t)(uwTickFreq);
 8000bfa:	4b04      	ldr	r3, [pc, #16]	@ (8000c0c <HAL_Delay+0x20>)
 8000bfc:	781b      	ldrb	r3, [r3, #0]
 8000bfe:	441c      	add	r4, r3
  }

  while ((HAL_GetTick() - tickstart) < wait)
 8000c00:	f7ff ffee 	bl	8000be0 <HAL_GetTick>
 8000c04:	1b40      	subs	r0, r0, r5
 8000c06:	42a0      	cmp	r0, r4
 8000c08:	d3fa      	bcc.n	8000c00 <HAL_Delay+0x14>
  {
  }
}
 8000c0a:	bd38      	pop	{r3, r4, r5, pc}
 8000c0c:	20000020 	.word	0x20000020

08000c10 <HAL_CAN_Init>:
HAL_StatusTypeDef HAL_CAN_Init(CAN_HandleTypeDef *hcan)
{
  uint32_t tickstart;

  /* Check CAN handle */
  if (hcan == NULL)
 8000c10:	2800      	cmp	r0, #0
 8000c12:	d07d      	beq.n	8000d10 <HAL_CAN_Init+0x100>
{
 8000c14:	b538      	push	{r3, r4, r5, lr}
    /* Init the low level hardware: CLOCK, NVIC */
    hcan->MspInitCallback(hcan);
  }

#else
  if (hcan->State == HAL_CAN_STATE_RESET)
 8000c16:	f890 3020 	ldrb.w	r3, [r0, #32]
 8000c1a:	4604      	mov	r4, r0
 8000c1c:	2b00      	cmp	r3, #0
 8000c1e:	d074      	beq.n	8000d0a <HAL_CAN_Init+0xfa>
    HAL_CAN_MspInit(hcan);
  }
#endif /* USE_HAL_CAN_REGISTER_CALLBACKS */

  /* Request initialisation */
  SET_BIT(hcan->Instance->MCR, CAN_MCR_INRQ);
 8000c20:	6822      	ldr	r2, [r4, #0]
 8000c22:	6813      	ldr	r3, [r2, #0]
 8000c24:	f043 0301 	orr.w	r3, r3, #1
 8000c28:	6013      	str	r3, [r2, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
 8000c2a:	f7ff ffd9 	bl	8000be0 <HAL_GetTick>
 8000c2e:	4605      	mov	r5, r0

  /* Wait initialisation acknowledge */
  while ((hcan->Instance->MSR & CAN_MSR_INAK) == 0U)
 8000c30:	e004      	b.n	8000c3c <HAL_CAN_Init+0x2c>
  {
    if ((HAL_GetTick() - tickstart) > CAN_TIMEOUT_VALUE)
 8000c32:	f7ff ffd5 	bl	8000be0 <HAL_GetTick>
 8000c36:	1b40      	subs	r0, r0, r5
 8000c38:	280a      	cmp	r0, #10
 8000c3a:	d85d      	bhi.n	8000cf8 <HAL_CAN_Init+0xe8>
  while ((hcan->Instance->MSR & CAN_MSR_INAK) == 0U)
 8000c3c:	6823      	ldr	r3, [r4, #0]
 8000c3e:	685a      	ldr	r2, [r3, #4]
 8000c40:	07d1      	lsls	r1, r2, #31
 8000c42:	d5f6      	bpl.n	8000c32 <HAL_CAN_Init+0x22>
      return HAL_ERROR;
    }
  }

  /* Exit from sleep mode */
  CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_SLEEP);
 8000c44:	681a      	ldr	r2, [r3, #0]
 8000c46:	f022 0202 	bic.w	r2, r2, #2
 8000c4a:	601a      	str	r2, [r3, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
 8000c4c:	f7ff ffc8 	bl	8000be0 <HAL_GetTick>
 8000c50:	4605      	mov	r5, r0

  /* Check Sleep mode leave acknowledge */
  while ((hcan->Instance->MSR & CAN_MSR_SLAK) != 0U)
 8000c52:	e004      	b.n	8000c5e <HAL_CAN_Init+0x4e>
  {
    if ((HAL_GetTick() - tickstart) > CAN_TIMEOUT_VALUE)
 8000c54:	f7ff ffc4 	bl	8000be0 <HAL_GetTick>
 8000c58:	1b40      	subs	r0, r0, r5
 8000c5a:	280a      	cmp	r0, #10
 8000c5c:	d84c      	bhi.n	8000cf8 <HAL_CAN_Init+0xe8>
  while ((hcan->Instance->MSR & CAN_MSR_SLAK) != 0U)
 8000c5e:	6823      	ldr	r3, [r4, #0]
 8000c60:	685a      	ldr	r2, [r3, #4]
 8000c62:	0792      	lsls	r2, r2, #30
 8000c64:	d4f6      	bmi.n	8000c54 <HAL_CAN_Init+0x44>
      return HAL_ERROR;
    }
  }

  /* Set the time triggered communication mode */
  if (hcan->Init.TimeTriggeredMode == ENABLE)
 8000c66:	7e22      	ldrb	r2, [r4, #24]
                                            hcan->Init.TimeSeg1       |
                                            hcan->Init.TimeSeg2       |
                                            (hcan->Init.Prescaler - 1U)));

  /* Initialize the error code */
  hcan->ErrorCode = HAL_CAN_ERROR_NONE;
 8000c68:	2500      	movs	r5, #0
  if (hcan->Init.TimeTriggeredMode == ENABLE)
 8000c6a:	2a01      	cmp	r2, #1
    SET_BIT(hcan->Instance->MCR, CAN_MCR_TTCM);
 8000c6c:	681a      	ldr	r2, [r3, #0]

  /* Initialize the CAN state */
  hcan->State = HAL_CAN_STATE_READY;
 8000c6e:	f04f 0c01 	mov.w	ip, #1
    SET_BIT(hcan->Instance->MCR, CAN_MCR_TTCM);
 8000c72:	bf0c      	ite	eq
 8000c74:	f042 0280 	orreq.w	r2, r2, #128	@ 0x80
    CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_TTCM);
 8000c78:	f022 0280 	bicne.w	r2, r2, #128	@ 0x80
 8000c7c:	601a      	str	r2, [r3, #0]
  if (hcan->Init.AutoBusOff == ENABLE)
 8000c7e:	7e62      	ldrb	r2, [r4, #25]

  /* Return function status */
  return HAL_OK;
 8000c80:	4628      	mov	r0, r5
  if (hcan->Init.AutoBusOff == ENABLE)
 8000c82:	2a01      	cmp	r2, #1
    SET_BIT(hcan->Instance->MCR, CAN_MCR_ABOM);
 8000c84:	681a      	ldr	r2, [r3, #0]
 8000c86:	bf0c      	ite	eq
 8000c88:	f042 0240 	orreq.w	r2, r2, #64	@ 0x40
    CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_ABOM);
 8000c8c:	f022 0240 	bicne.w	r2, r2, #64	@ 0x40
 8000c90:	601a      	str	r2, [r3, #0]
  if (hcan->Init.AutoWakeUp == ENABLE)
 8000c92:	7ea2      	ldrb	r2, [r4, #26]
 8000c94:	2a01      	cmp	r2, #1
    SET_BIT(hcan->Instance->MCR, CAN_MCR_AWUM);
 8000c96:	681a      	ldr	r2, [r3, #0]
 8000c98:	bf0c      	ite	eq
 8000c9a:	f042 0220 	orreq.w	r2, r2, #32
    CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_AWUM);
 8000c9e:	f022 0220 	bicne.w	r2, r2, #32
 8000ca2:	601a      	str	r2, [r3, #0]
  if (hcan->Init.AutoRetransmission == ENABLE)
 8000ca4:	7ee2      	ldrb	r2, [r4, #27]
 8000ca6:	2a01      	cmp	r2, #1
    CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_NART);
 8000ca8:	681a      	ldr	r2, [r3, #0]
 8000caa:	bf0c      	ite	eq
 8000cac:	f022 0210 	biceq.w	r2, r2, #16
    SET_BIT(hcan->Instance->MCR, CAN_MCR_NART);
 8000cb0:	f042 0210 	orrne.w	r2, r2, #16
 8000cb4:	601a      	str	r2, [r3, #0]
  if (hcan->Init.ReceiveFifoLocked == ENABLE)
 8000cb6:	7f22      	ldrb	r2, [r4, #28]
 8000cb8:	2a01      	cmp	r2, #1
    SET_BIT(hcan->Instance->MCR, CAN_MCR_RFLM);
 8000cba:	681a      	ldr	r2, [r3, #0]
 8000cbc:	bf0c      	ite	eq
 8000cbe:	f042 0208 	orreq.w	r2, r2, #8
    CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_RFLM);
 8000cc2:	f022 0208 	bicne.w	r2, r2, #8
 8000cc6:	601a      	str	r2, [r3, #0]
  if (hcan->Init.TransmitFifoPriority == ENABLE)
 8000cc8:	7f62      	ldrb	r2, [r4, #29]
 8000cca:	2a01      	cmp	r2, #1
    SET_BIT(hcan->Instance->MCR, CAN_MCR_TXFP);
 8000ccc:	681a      	ldr	r2, [r3, #0]
 8000cce:	bf0c      	ite	eq
 8000cd0:	f042 0204 	orreq.w	r2, r2, #4
    CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_TXFP);
 8000cd4:	f022 0204 	bicne.w	r2, r2, #4
 8000cd8:	601a      	str	r2, [r3, #0]
  WRITE_REG(hcan->Instance->BTR, (uint32_t)(hcan->Init.Mode           |
 8000cda:	e9d4 2102 	ldrd	r2, r1, [r4, #8]
 8000cde:	430a      	orrs	r2, r1
 8000ce0:	6921      	ldr	r1, [r4, #16]
 8000ce2:	430a      	orrs	r2, r1
 8000ce4:	6961      	ldr	r1, [r4, #20]
 8000ce6:	430a      	orrs	r2, r1
 8000ce8:	6861      	ldr	r1, [r4, #4]
 8000cea:	3901      	subs	r1, #1
 8000cec:	430a      	orrs	r2, r1
 8000cee:	61da      	str	r2, [r3, #28]
  hcan->ErrorCode = HAL_CAN_ERROR_NONE;
 8000cf0:	6265      	str	r5, [r4, #36]	@ 0x24
  hcan->State = HAL_CAN_STATE_READY;
 8000cf2:	f884 c020 	strb.w	ip, [r4, #32]
}
 8000cf6:	bd38      	pop	{r3, r4, r5, pc}
      hcan->State = HAL_CAN_STATE_ERROR;
 8000cf8:	2205      	movs	r2, #5
      hcan->ErrorCode |= HAL_CAN_ERROR_TIMEOUT;
 8000cfa:	6a63      	ldr	r3, [r4, #36]	@ 0x24
    return HAL_ERROR;
 8000cfc:	2001      	movs	r0, #1
      hcan->ErrorCode |= HAL_CAN_ERROR_TIMEOUT;
 8000cfe:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8000d02:	6263      	str	r3, [r4, #36]	@ 0x24
      hcan->State = HAL_CAN_STATE_ERROR;
 8000d04:	f884 2020 	strb.w	r2, [r4, #32]
}
 8000d08:	bd38      	pop	{r3, r4, r5, pc}
    HAL_CAN_MspInit(hcan);
 8000d0a:	f7ff fe3f 	bl	800098c <HAL_CAN_MspInit>
 8000d0e:	e787      	b.n	8000c20 <HAL_CAN_Init+0x10>
    return HAL_ERROR;
 8000d10:	2001      	movs	r0, #1
}
 8000d12:	4770      	bx	lr

08000d14 <HAL_CAN_ConfigFilter>:
  * @param  sFilterConfig pointer to a CAN_FilterTypeDef structure that
  *         contains the filter configuration information.
  * @retval None
  */
HAL_StatusTypeDef HAL_CAN_ConfigFilter(CAN_HandleTypeDef *hcan, const CAN_FilterTypeDef *sFilterConfig)
{
 8000d14:	b430      	push	{r4, r5}
  uint32_t filternbrbitpos;
  CAN_TypeDef *can_ip = hcan->Instance;
  HAL_CAN_StateTypeDef state = hcan->State;
 8000d16:	f890 2020 	ldrb.w	r2, [r0, #32]
  CAN_TypeDef *can_ip = hcan->Instance;
 8000d1a:	6804      	ldr	r4, [r0, #0]

  if ((state == HAL_CAN_STATE_READY) ||
 8000d1c:	3a01      	subs	r2, #1
 8000d1e:	2a01      	cmp	r2, #1
 8000d20:	d907      	bls.n	8000d32 <HAL_CAN_ConfigFilter+0x1e>
    /* Update error code */
    hcan->ErrorCode |= HAL_CAN_ERROR_NOT_INITIALIZED;

    return HAL_ERROR;
  }
}
 8000d22:	bc30      	pop	{r4, r5}
 8000d24:	4603      	mov	r3, r0
    hcan->ErrorCode |= HAL_CAN_ERROR_NOT_INITIALIZED;
 8000d26:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
    return HAL_ERROR;
 8000d28:	2001      	movs	r0, #1
    hcan->ErrorCode |= HAL_CAN_ERROR_NOT_INITIALIZED;
 8000d2a:	f442 2280 	orr.w	r2, r2, #262144	@ 0x40000
 8000d2e:	625a      	str	r2, [r3, #36]	@ 0x24
}
 8000d30:	4770      	bx	lr
    filternbrbitpos = (uint32_t)1 << (sFilterConfig->FilterBank & 0x1FU);
 8000d32:	2301      	movs	r3, #1
    SET_BIT(can_ip->FMR, CAN_FMR_FINIT);
 8000d34:	f8d4 0200 	ldr.w	r0, [r4, #512]	@ 0x200
    filternbrbitpos = (uint32_t)1 << (sFilterConfig->FilterBank & 0x1FU);
 8000d38:	694a      	ldr	r2, [r1, #20]
    SET_BIT(can_ip->FMR, CAN_FMR_FINIT);
 8000d3a:	4318      	orrs	r0, r3
 8000d3c:	f8c4 0200 	str.w	r0, [r4, #512]	@ 0x200
    CLEAR_BIT(can_ip->FA1R, filternbrbitpos);
 8000d40:	f8d4 021c 	ldr.w	r0, [r4, #540]	@ 0x21c
    filternbrbitpos = (uint32_t)1 << (sFilterConfig->FilterBank & 0x1FU);
 8000d44:	f002 051f 	and.w	r5, r2, #31
 8000d48:	40ab      	lsls	r3, r5
    if (sFilterConfig->FilterScale == CAN_FILTERSCALE_16BIT)
 8000d4a:	69cd      	ldr	r5, [r1, #28]
    CLEAR_BIT(can_ip->FA1R, filternbrbitpos);
 8000d4c:	ea20 0003 	bic.w	r0, r0, r3
 8000d50:	f8c4 021c 	str.w	r0, [r4, #540]	@ 0x21c
 8000d54:	43d8      	mvns	r0, r3
    if (sFilterConfig->FilterScale == CAN_FILTERSCALE_16BIT)
 8000d56:	2d00      	cmp	r5, #0
 8000d58:	d13f      	bne.n	8000dda <HAL_CAN_ConfigFilter+0xc6>
      CLEAR_BIT(can_ip->FS1R, filternbrbitpos);
 8000d5a:	f8d4 520c 	ldr.w	r5, [r4, #524]	@ 0x20c
        ((0x0000FFFFU & (uint32_t)sFilterConfig->FilterMaskIdLow) << 16U) |
 8000d5e:	f8d1 c00c 	ldr.w	ip, [r1, #12]
      CLEAR_BIT(can_ip->FS1R, filternbrbitpos);
 8000d62:	4005      	ands	r5, r0
 8000d64:	f8c4 520c 	str.w	r5, [r4, #524]	@ 0x20c
        (0x0000FFFFU & (uint32_t)sFilterConfig->FilterIdLow);
 8000d68:	888d      	ldrh	r5, [r1, #4]
 8000d6a:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
        ((0x0000FFFFU & (uint32_t)sFilterConfig->FilterMaskIdLow) << 16U) |
 8000d6e:	ea45 450c 	orr.w	r5, r5, ip, lsl #16
      can_ip->sFilterRegister[sFilterConfig->FilterBank].FR1 =
 8000d72:	f8c2 5240 	str.w	r5, [r2, #576]	@ 0x240
        ((0x0000FFFFU & (uint32_t)sFilterConfig->FilterMaskIdHigh) << 16U) |
 8000d76:	f8d1 c008 	ldr.w	ip, [r1, #8]
        (0x0000FFFFU & (uint32_t)sFilterConfig->FilterIdHigh);
 8000d7a:	880d      	ldrh	r5, [r1, #0]
        ((0x0000FFFFU & (uint32_t)sFilterConfig->FilterMaskIdHigh) << 16U) |
 8000d7c:	ea45 450c 	orr.w	r5, r5, ip, lsl #16
      can_ip->sFilterRegister[sFilterConfig->FilterBank].FR2 =
 8000d80:	f8c2 5244 	str.w	r5, [r2, #580]	@ 0x244
    if (sFilterConfig->FilterMode == CAN_FILTERMODE_IDMASK)
 8000d84:	698a      	ldr	r2, [r1, #24]
 8000d86:	bb12      	cbnz	r2, 8000dce <HAL_CAN_ConfigFilter+0xba>
      CLEAR_BIT(can_ip->FM1R, filternbrbitpos);
 8000d88:	f8d4 2204 	ldr.w	r2, [r4, #516]	@ 0x204
 8000d8c:	4002      	ands	r2, r0
 8000d8e:	f8c4 2204 	str.w	r2, [r4, #516]	@ 0x204
    if (sFilterConfig->FilterFIFOAssignment == CAN_FILTER_FIFO0)
 8000d92:	690a      	ldr	r2, [r1, #16]
 8000d94:	b9aa      	cbnz	r2, 8000dc2 <HAL_CAN_ConfigFilter+0xae>
      CLEAR_BIT(can_ip->FFA1R, filternbrbitpos);
 8000d96:	f8d4 2214 	ldr.w	r2, [r4, #532]	@ 0x214
 8000d9a:	4010      	ands	r0, r2
 8000d9c:	f8c4 0214 	str.w	r0, [r4, #532]	@ 0x214
    if (sFilterConfig->FilterActivation == CAN_FILTER_ENABLE)
 8000da0:	6a0a      	ldr	r2, [r1, #32]
 8000da2:	2a01      	cmp	r2, #1
 8000da4:	d104      	bne.n	8000db0 <HAL_CAN_ConfigFilter+0x9c>
      SET_BIT(can_ip->FA1R, filternbrbitpos);
 8000da6:	f8d4 221c 	ldr.w	r2, [r4, #540]	@ 0x21c
 8000daa:	4313      	orrs	r3, r2
 8000dac:	f8c4 321c 	str.w	r3, [r4, #540]	@ 0x21c
    CLEAR_BIT(can_ip->FMR, CAN_FMR_FINIT);
 8000db0:	f8d4 3200 	ldr.w	r3, [r4, #512]	@ 0x200
    return HAL_OK;
 8000db4:	2000      	movs	r0, #0
    CLEAR_BIT(can_ip->FMR, CAN_FMR_FINIT);
 8000db6:	f023 0301 	bic.w	r3, r3, #1
 8000dba:	f8c4 3200 	str.w	r3, [r4, #512]	@ 0x200
}
 8000dbe:	bc30      	pop	{r4, r5}
 8000dc0:	4770      	bx	lr
      SET_BIT(can_ip->FFA1R, filternbrbitpos);
 8000dc2:	f8d4 2214 	ldr.w	r2, [r4, #532]	@ 0x214
 8000dc6:	431a      	orrs	r2, r3
 8000dc8:	f8c4 2214 	str.w	r2, [r4, #532]	@ 0x214
 8000dcc:	e7e8      	b.n	8000da0 <HAL_CAN_ConfigFilter+0x8c>
      SET_BIT(can_ip->FM1R, filternbrbitpos);
 8000dce:	f8d4 2204 	ldr.w	r2, [r4, #516]	@ 0x204
 8000dd2:	431a      	orrs	r2, r3
 8000dd4:	f8c4 2204 	str.w	r2, [r4, #516]	@ 0x204
 8000dd8:	e7db      	b.n	8000d92 <HAL_CAN_ConfigFilter+0x7e>
    if (sFilterConfig->FilterScale == CAN_FILTERSCALE_32BIT)
 8000dda:	2d01      	cmp	r5, #1
 8000ddc:	d1d2      	bne.n	8000d84 <HAL_CAN_ConfigFilter+0x70>
      SET_BIT(can_ip->FS1R, filternbrbitpos);
 8000dde:	f8d4 520c 	ldr.w	r5, [r4, #524]	@ 0x20c
        ((0x0000FFFFU & (uint32_t)sFilterConfig->FilterIdHigh) << 16U) |
 8000de2:	f8d1 c000 	ldr.w	ip, [r1]
      SET_BIT(can_ip->FS1R, filternbrbitpos);
 8000de6:	431d      	orrs	r5, r3
 8000de8:	f8c4 520c 	str.w	r5, [r4, #524]	@ 0x20c
        (0x0000FFFFU & (uint32_t)sFilterConfig->FilterIdLow);
 8000dec:	888d      	ldrh	r5, [r1, #4]
 8000dee:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
        ((0x0000FFFFU & (uint32_t)sFilterConfig->FilterIdHigh) << 16U) |
 8000df2:	ea45 450c 	orr.w	r5, r5, ip, lsl #16
      can_ip->sFilterRegister[sFilterConfig->FilterBank].FR1 =
 8000df6:	f8c2 5240 	str.w	r5, [r2, #576]	@ 0x240
        ((0x0000FFFFU & (uint32_t)sFilterConfig->FilterMaskIdHigh) << 16U) |
 8000dfa:	f8d1 c008 	ldr.w	ip, [r1, #8]
        (0x0000FFFFU & (uint32_t)sFilterConfig->FilterMaskIdLow);
 8000dfe:	898d      	ldrh	r5, [r1, #12]
        ((0x0000FFFFU & (uint32_t)sFilterConfig->FilterMaskIdHigh) << 16U) |
 8000e00:	ea45 450c 	orr.w	r5, r5, ip, lsl #16
      can_ip->sFilterRegister[sFilterConfig->FilterBank].FR2 =
 8000e04:	f8c2 5244 	str.w	r5, [r2, #580]	@ 0x244
 8000e08:	e7bc      	b.n	8000d84 <HAL_CAN_ConfigFilter+0x70>
 8000e0a:	bf00      	nop

08000e0c <HAL_CAN_Start>:
  * @param  hcan pointer to an CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CAN_Start(CAN_HandleTypeDef *hcan)
{
 8000e0c:	b538      	push	{r3, r4, r5, lr}
  uint32_t tickstart;

  if (hcan->State == HAL_CAN_STATE_READY)
 8000e0e:	f890 3020 	ldrb.w	r3, [r0, #32]
{
 8000e12:	4604      	mov	r4, r0
  if (hcan->State == HAL_CAN_STATE_READY)
 8000e14:	2b01      	cmp	r3, #1
 8000e16:	d005      	beq.n	8000e24 <HAL_CAN_Start+0x18>
    return HAL_OK;
  }
  else
  {
    /* Update error code */
    hcan->ErrorCode |= HAL_CAN_ERROR_NOT_READY;
 8000e18:	6a43      	ldr	r3, [r0, #36]	@ 0x24
 8000e1a:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
 8000e1e:	6243      	str	r3, [r0, #36]	@ 0x24
        return HAL_ERROR;
 8000e20:	2001      	movs	r0, #1

    return HAL_ERROR;
  }
}
 8000e22:	bd38      	pop	{r3, r4, r5, pc}
    hcan->State = HAL_CAN_STATE_LISTENING;
 8000e24:	2302      	movs	r3, #2
    CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_INRQ);
 8000e26:	6802      	ldr	r2, [r0, #0]
    hcan->State = HAL_CAN_STATE_LISTENING;
 8000e28:	f880 3020 	strb.w	r3, [r0, #32]
    CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_INRQ);
 8000e2c:	6813      	ldr	r3, [r2, #0]
 8000e2e:	f023 0301 	bic.w	r3, r3, #1
 8000e32:	6013      	str	r3, [r2, #0]
    tickstart = HAL_GetTick();
 8000e34:	f7ff fed4 	bl	8000be0 <HAL_GetTick>
 8000e38:	4605      	mov	r5, r0
    while ((hcan->Instance->MSR & CAN_MSR_INAK) != 0U)
 8000e3a:	e004      	b.n	8000e46 <HAL_CAN_Start+0x3a>
      if ((HAL_GetTick() - tickstart) > CAN_TIMEOUT_VALUE)
 8000e3c:	f7ff fed0 	bl	8000be0 <HAL_GetTick>
 8000e40:	1b43      	subs	r3, r0, r5
 8000e42:	2b0a      	cmp	r3, #10
 8000e44:	d807      	bhi.n	8000e56 <HAL_CAN_Start+0x4a>
    while ((hcan->Instance->MSR & CAN_MSR_INAK) != 0U)
 8000e46:	6823      	ldr	r3, [r4, #0]
 8000e48:	685b      	ldr	r3, [r3, #4]
 8000e4a:	f013 0301 	ands.w	r3, r3, #1
 8000e4e:	d1f5      	bne.n	8000e3c <HAL_CAN_Start+0x30>
    return HAL_OK;
 8000e50:	4618      	mov	r0, r3
    hcan->ErrorCode = HAL_CAN_ERROR_NONE;
 8000e52:	6263      	str	r3, [r4, #36]	@ 0x24
}
 8000e54:	bd38      	pop	{r3, r4, r5, pc}
        hcan->State = HAL_CAN_STATE_ERROR;
 8000e56:	2205      	movs	r2, #5
        hcan->ErrorCode |= HAL_CAN_ERROR_TIMEOUT;
 8000e58:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 8000e5a:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8000e5e:	6263      	str	r3, [r4, #36]	@ 0x24
        hcan->State = HAL_CAN_STATE_ERROR;
 8000e60:	f884 2020 	strb.w	r2, [r4, #32]
        return HAL_ERROR;
 8000e64:	e7dc      	b.n	8000e20 <HAL_CAN_Start+0x14>
 8000e66:	bf00      	nop

08000e68 <HAL_CAN_AddTxMessage>:
  *         This parameter can be a value of @arg CAN_Tx_Mailboxes.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CAN_AddTxMessage(CAN_HandleTypeDef *hcan, const CAN_TxHeaderTypeDef *pHeader,
                                       const uint8_t aData[], uint32_t *pTxMailbox)
{
 8000e68:	b430      	push	{r4, r5}
  uint32_t transmitmailbox;
  HAL_CAN_StateTypeDef state = hcan->State;
 8000e6a:	f890 c020 	ldrb.w	ip, [r0, #32]
  uint32_t tsr = READ_REG(hcan->Instance->TSR);
 8000e6e:	6805      	ldr	r5, [r0, #0]
  {
    assert_param(IS_CAN_EXTID(pHeader->ExtId));
  }
  assert_param(IS_FUNCTIONAL_STATE(pHeader->TransmitGlobalTime));

  if ((state == HAL_CAN_STATE_READY) ||
 8000e70:	f10c 3cff 	add.w	ip, ip, #4294967295
 8000e74:	f1bc 0f01 	cmp.w	ip, #1
  uint32_t tsr = READ_REG(hcan->Instance->TSR);
 8000e78:	68ac      	ldr	r4, [r5, #8]
  if ((state == HAL_CAN_STATE_READY) ||
 8000e7a:	d838      	bhi.n	8000eee <HAL_CAN_AddTxMessage+0x86>
      (state == HAL_CAN_STATE_LISTENING))
  {
    /* Check that all the Tx mailboxes are not full */
    if (((tsr & CAN_TSR_TME0) != 0U) ||
 8000e7c:	f014 5fe0 	tst.w	r4, #469762048	@ 0x1c000000
 8000e80:	d106      	bne.n	8000e90 <HAL_CAN_AddTxMessage+0x28>
      return HAL_OK;
    }
    else
    {
      /* Update error code */
      hcan->ErrorCode |= HAL_CAN_ERROR_PARAM;
 8000e82:	6a43      	ldr	r3, [r0, #36]	@ 0x24
 8000e84:	f443 1300 	orr.w	r3, r3, #2097152	@ 0x200000
 8000e88:	6243      	str	r3, [r0, #36]	@ 0x24

      return HAL_ERROR;
 8000e8a:	2001      	movs	r0, #1
    /* Update error code */
    hcan->ErrorCode |= HAL_CAN_ERROR_NOT_INITIALIZED;

    return HAL_ERROR;
  }
}
 8000e8c:	bc30      	pop	{r4, r5}
 8000e8e:	4770      	bx	lr
      *pTxMailbox = (uint32_t)1 << transmitmailbox;
 8000e90:	2001      	movs	r0, #1
      transmitmailbox = (tsr & CAN_TSR_CODE) >> CAN_TSR_CODE_Pos;
 8000e92:	f3c4 6401 	ubfx	r4, r4, #24, #2
      *pTxMailbox = (uint32_t)1 << transmitmailbox;
 8000e96:	40a0      	lsls	r0, r4
 8000e98:	6018      	str	r0, [r3, #0]
      if (pHeader->IDE == CAN_ID_STD)
 8000e9a:	688b      	ldr	r3, [r1, #8]
 8000e9c:	b363      	cbz	r3, 8000ef8 <HAL_CAN_AddTxMessage+0x90>
                                                           pHeader->IDE |
 8000e9e:	68c8      	ldr	r0, [r1, #12]
 8000ea0:	4303      	orrs	r3, r0
        hcan->Instance->sTxMailBox[transmitmailbox].TIR = ((pHeader->ExtId << CAN_TI0R_EXID_Pos) |
 8000ea2:	6848      	ldr	r0, [r1, #4]
                                                           pHeader->IDE |
 8000ea4:	ea43 03c0 	orr.w	r3, r3, r0, lsl #3
        hcan->Instance->sTxMailBox[transmitmailbox].TIR = ((pHeader->ExtId << CAN_TI0R_EXID_Pos) |
 8000ea8:	f104 0018 	add.w	r0, r4, #24
 8000eac:	0100      	lsls	r0, r0, #4
 8000eae:	502b      	str	r3, [r5, r0]
      hcan->Instance->sTxMailBox[transmitmailbox].TDTR = (pHeader->DLC);
 8000eb0:	690b      	ldr	r3, [r1, #16]
 8000eb2:	eb05 1c04 	add.w	ip, r5, r4, lsl #4
 8000eb6:	f8cc 3184 	str.w	r3, [ip, #388]	@ 0x184
      if (pHeader->TransmitGlobalTime == ENABLE)
 8000eba:	7d0b      	ldrb	r3, [r1, #20]
 8000ebc:	0121      	lsls	r1, r4, #4
 8000ebe:	2b01      	cmp	r3, #1
 8000ec0:	d105      	bne.n	8000ece <HAL_CAN_AddTxMessage+0x66>
        SET_BIT(hcan->Instance->sTxMailBox[transmitmailbox].TDTR, CAN_TDT0R_TGT);
 8000ec2:	f8dc 3184 	ldr.w	r3, [ip, #388]	@ 0x184
 8000ec6:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8000eca:	f8cc 3184 	str.w	r3, [ip, #388]	@ 0x184
      WRITE_REG(hcan->Instance->sTxMailBox[transmitmailbox].TDHR,
 8000ece:	6850      	ldr	r0, [r2, #4]
 8000ed0:	186b      	adds	r3, r5, r1
 8000ed2:	f8c3 018c 	str.w	r0, [r3, #396]	@ 0x18c
      WRITE_REG(hcan->Instance->sTxMailBox[transmitmailbox].TDLR,
 8000ed6:	6812      	ldr	r2, [r2, #0]
      return HAL_OK;
 8000ed8:	2000      	movs	r0, #0
}
 8000eda:	bc30      	pop	{r4, r5}
      WRITE_REG(hcan->Instance->sTxMailBox[transmitmailbox].TDLR,
 8000edc:	f8c3 2188 	str.w	r2, [r3, #392]	@ 0x188
      SET_BIT(hcan->Instance->sTxMailBox[transmitmailbox].TIR, CAN_TI0R_TXRQ);
 8000ee0:	f8dc 3180 	ldr.w	r3, [ip, #384]	@ 0x180
 8000ee4:	f043 0301 	orr.w	r3, r3, #1
 8000ee8:	f8cc 3180 	str.w	r3, [ip, #384]	@ 0x180
}
 8000eec:	4770      	bx	lr
    hcan->ErrorCode |= HAL_CAN_ERROR_NOT_INITIALIZED;
 8000eee:	6a43      	ldr	r3, [r0, #36]	@ 0x24
 8000ef0:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
 8000ef4:	6243      	str	r3, [r0, #36]	@ 0x24
    return HAL_ERROR;
 8000ef6:	e7c8      	b.n	8000e8a <HAL_CAN_AddTxMessage+0x22>
        hcan->Instance->sTxMailBox[transmitmailbox].TIR = ((pHeader->StdId << CAN_TI0R_STID_Pos) |
 8000ef8:	68cb      	ldr	r3, [r1, #12]
 8000efa:	6808      	ldr	r0, [r1, #0]
 8000efc:	ea43 5040 	orr.w	r0, r3, r0, lsl #21
 8000f00:	f104 0318 	add.w	r3, r4, #24
 8000f04:	011b      	lsls	r3, r3, #4
 8000f06:	50e8      	str	r0, [r5, r3]
 8000f08:	e7d2      	b.n	8000eb0 <HAL_CAN_AddTxMessage+0x48>
 8000f0a:	bf00      	nop

08000f0c <HAL_CAN_GetRxMessage>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CAN_GetRxMessage(CAN_HandleTypeDef *hcan, uint32_t RxFifo,
                                       CAN_RxHeaderTypeDef *pHeader, uint8_t aData[])
{
  HAL_CAN_StateTypeDef state = hcan->State;
 8000f0c:	f890 c020 	ldrb.w	ip, [r0, #32]

  assert_param(IS_CAN_RX_FIFO(RxFifo));

  if ((state == HAL_CAN_STATE_READY) ||
 8000f10:	f10c 3cff 	add.w	ip, ip, #4294967295
 8000f14:	f1bc 0f01 	cmp.w	ip, #1
 8000f18:	d86b      	bhi.n	8000ff2 <HAL_CAN_GetRxMessage+0xe6>
{
 8000f1a:	b5f0      	push	{r4, r5, r6, r7, lr}
  {
    /* Check the Rx FIFO */
    if (RxFifo == CAN_RX_FIFO0) /* Rx element is assigned to Rx FIFO 0 */
    {
      /* Check that the Rx FIFO 0 is not empty */
      if ((hcan->Instance->RF0R & CAN_RF0R_FMP0) == 0U)
 8000f1c:	6804      	ldr	r4, [r0, #0]
    if (RxFifo == CAN_RX_FIFO0) /* Rx element is assigned to Rx FIFO 0 */
 8000f1e:	b941      	cbnz	r1, 8000f32 <HAL_CAN_GetRxMessage+0x26>
      if ((hcan->Instance->RF0R & CAN_RF0R_FMP0) == 0U)
 8000f20:	68e5      	ldr	r5, [r4, #12]
 8000f22:	07af      	lsls	r7, r5, #30
 8000f24:	d108      	bne.n	8000f38 <HAL_CAN_GetRxMessage+0x2c>
    {
      /* Check that the Rx FIFO 1 is not empty */
      if ((hcan->Instance->RF1R & CAN_RF1R_FMP1) == 0U)
      {
        /* Update error code */
        hcan->ErrorCode |= HAL_CAN_ERROR_PARAM;
 8000f26:	6a43      	ldr	r3, [r0, #36]	@ 0x24
 8000f28:	f443 1300 	orr.w	r3, r3, #2097152	@ 0x200000
 8000f2c:	6243      	str	r3, [r0, #36]	@ 0x24
        return HAL_ERROR;
 8000f2e:	2001      	movs	r0, #1
    /* Update error code */
    hcan->ErrorCode |= HAL_CAN_ERROR_NOT_INITIALIZED;

    return HAL_ERROR;
  }
}
 8000f30:	bdf0      	pop	{r4, r5, r6, r7, pc}
      if ((hcan->Instance->RF1R & CAN_RF1R_FMP1) == 0U)
 8000f32:	6925      	ldr	r5, [r4, #16]
 8000f34:	07ae      	lsls	r6, r5, #30
 8000f36:	d0f6      	beq.n	8000f26 <HAL_CAN_GetRxMessage+0x1a>
    pHeader->IDE = CAN_RI0R_IDE & hcan->Instance->sFIFOMailBox[RxFifo].RIR;
 8000f38:	eb04 1c01 	add.w	ip, r4, r1, lsl #4
 8000f3c:	f8dc 51b0 	ldr.w	r5, [ip, #432]	@ 0x1b0
 8000f40:	ea4f 1e01 	mov.w	lr, r1, lsl #4
 8000f44:	f005 0504 	and.w	r5, r5, #4
 8000f48:	6095      	str	r5, [r2, #8]
    if (pHeader->IDE == CAN_ID_STD)
 8000f4a:	2d00      	cmp	r5, #0
 8000f4c:	d057      	beq.n	8000ffe <HAL_CAN_GetRxMessage+0xf2>
                        hcan->Instance->sFIFOMailBox[RxFifo].RIR) >> CAN_RI0R_EXID_Pos;
 8000f4e:	f8dc 51b0 	ldr.w	r5, [ip, #432]	@ 0x1b0
 8000f52:	08ed      	lsrs	r5, r5, #3
      pHeader->ExtId = ((CAN_RI0R_EXID | CAN_RI0R_STID) &
 8000f54:	6055      	str	r5, [r2, #4]
    pHeader->RTR = (CAN_RI0R_RTR & hcan->Instance->sFIFOMailBox[RxFifo].RIR);
 8000f56:	f8dc 51b0 	ldr.w	r5, [ip, #432]	@ 0x1b0
    aData[0] = (uint8_t)((CAN_RDL0R_DATA0 & hcan->Instance->sFIFOMailBox[RxFifo].RDLR) >> CAN_RDL0R_DATA0_Pos);
 8000f5a:	4474      	add	r4, lr
    pHeader->RTR = (CAN_RI0R_RTR & hcan->Instance->sFIFOMailBox[RxFifo].RIR);
 8000f5c:	f005 0502 	and.w	r5, r5, #2
 8000f60:	60d5      	str	r5, [r2, #12]
    if (((CAN_RDT0R_DLC & hcan->Instance->sFIFOMailBox[RxFifo].RDTR) >> CAN_RDT0R_DLC_Pos) >= 8U)
 8000f62:	f8dc 51b4 	ldr.w	r5, [ip, #436]	@ 0x1b4
 8000f66:	072d      	lsls	r5, r5, #28
      pHeader->DLC = 8U;
 8000f68:	bf4c      	ite	mi
 8000f6a:	2508      	movmi	r5, #8
      pHeader->DLC = (CAN_RDT0R_DLC & hcan->Instance->sFIFOMailBox[RxFifo].RDTR) >> CAN_RDT0R_DLC_Pos;
 8000f6c:	f8dc 51b4 	ldrpl.w	r5, [ip, #436]	@ 0x1b4
    pHeader->FilterMatchIndex = (CAN_RDT0R_FMI & hcan->Instance->sFIFOMailBox[RxFifo].RDTR) >> CAN_RDT0R_FMI_Pos;
 8000f70:	f8dc 61b4 	ldr.w	r6, [ip, #436]	@ 0x1b4
      pHeader->DLC = (CAN_RDT0R_DLC & hcan->Instance->sFIFOMailBox[RxFifo].RDTR) >> CAN_RDT0R_DLC_Pos;
 8000f74:	bf58      	it	pl
 8000f76:	f005 050f 	andpl.w	r5, r5, #15
 8000f7a:	6115      	str	r5, [r2, #16]
    pHeader->Timestamp = (CAN_RDT0R_TIME & hcan->Instance->sFIFOMailBox[RxFifo].RDTR) >> CAN_RDT0R_TIME_Pos;
 8000f7c:	f8dc 51b4 	ldr.w	r5, [ip, #436]	@ 0x1b4
    aData[0] = (uint8_t)((CAN_RDL0R_DATA0 & hcan->Instance->sFIFOMailBox[RxFifo].RDLR) >> CAN_RDL0R_DATA0_Pos);
 8000f80:	f8d4 71b8 	ldr.w	r7, [r4, #440]	@ 0x1b8
    pHeader->FilterMatchIndex = (CAN_RDT0R_FMI & hcan->Instance->sFIFOMailBox[RxFifo].RDTR) >> CAN_RDT0R_FMI_Pos;
 8000f84:	f3c6 2607 	ubfx	r6, r6, #8, #8
    pHeader->Timestamp = (CAN_RDT0R_TIME & hcan->Instance->sFIFOMailBox[RxFifo].RDTR) >> CAN_RDT0R_TIME_Pos;
 8000f88:	0c2d      	lsrs	r5, r5, #16
    pHeader->FilterMatchIndex = (CAN_RDT0R_FMI & hcan->Instance->sFIFOMailBox[RxFifo].RDTR) >> CAN_RDT0R_FMI_Pos;
 8000f8a:	6196      	str	r6, [r2, #24]
    pHeader->Timestamp = (CAN_RDT0R_TIME & hcan->Instance->sFIFOMailBox[RxFifo].RDTR) >> CAN_RDT0R_TIME_Pos;
 8000f8c:	6155      	str	r5, [r2, #20]
    aData[0] = (uint8_t)((CAN_RDL0R_DATA0 & hcan->Instance->sFIFOMailBox[RxFifo].RDLR) >> CAN_RDL0R_DATA0_Pos);
 8000f8e:	701f      	strb	r7, [r3, #0]
    aData[1] = (uint8_t)((CAN_RDL0R_DATA1 & hcan->Instance->sFIFOMailBox[RxFifo].RDLR) >> CAN_RDL0R_DATA1_Pos);
 8000f90:	6802      	ldr	r2, [r0, #0]
 8000f92:	4472      	add	r2, lr
 8000f94:	f8d2 21b8 	ldr.w	r2, [r2, #440]	@ 0x1b8
 8000f98:	0a12      	lsrs	r2, r2, #8
 8000f9a:	705a      	strb	r2, [r3, #1]
    aData[2] = (uint8_t)((CAN_RDL0R_DATA2 & hcan->Instance->sFIFOMailBox[RxFifo].RDLR) >> CAN_RDL0R_DATA2_Pos);
 8000f9c:	6802      	ldr	r2, [r0, #0]
 8000f9e:	4472      	add	r2, lr
 8000fa0:	f8d2 21b8 	ldr.w	r2, [r2, #440]	@ 0x1b8
 8000fa4:	0c12      	lsrs	r2, r2, #16
 8000fa6:	709a      	strb	r2, [r3, #2]
    aData[3] = (uint8_t)((CAN_RDL0R_DATA3 & hcan->Instance->sFIFOMailBox[RxFifo].RDLR) >> CAN_RDL0R_DATA3_Pos);
 8000fa8:	6802      	ldr	r2, [r0, #0]
 8000faa:	4472      	add	r2, lr
 8000fac:	f8d2 21b8 	ldr.w	r2, [r2, #440]	@ 0x1b8
 8000fb0:	0e12      	lsrs	r2, r2, #24
 8000fb2:	70da      	strb	r2, [r3, #3]
    aData[4] = (uint8_t)((CAN_RDH0R_DATA4 & hcan->Instance->sFIFOMailBox[RxFifo].RDHR) >> CAN_RDH0R_DATA4_Pos);
 8000fb4:	6802      	ldr	r2, [r0, #0]
 8000fb6:	4472      	add	r2, lr
 8000fb8:	f8d2 21bc 	ldr.w	r2, [r2, #444]	@ 0x1bc
 8000fbc:	711a      	strb	r2, [r3, #4]
    aData[5] = (uint8_t)((CAN_RDH0R_DATA5 & hcan->Instance->sFIFOMailBox[RxFifo].RDHR) >> CAN_RDH0R_DATA5_Pos);
 8000fbe:	6802      	ldr	r2, [r0, #0]
 8000fc0:	4472      	add	r2, lr
 8000fc2:	f8d2 21bc 	ldr.w	r2, [r2, #444]	@ 0x1bc
 8000fc6:	0a12      	lsrs	r2, r2, #8
 8000fc8:	715a      	strb	r2, [r3, #5]
    aData[6] = (uint8_t)((CAN_RDH0R_DATA6 & hcan->Instance->sFIFOMailBox[RxFifo].RDHR) >> CAN_RDH0R_DATA6_Pos);
 8000fca:	6802      	ldr	r2, [r0, #0]
 8000fcc:	4472      	add	r2, lr
 8000fce:	f8d2 21bc 	ldr.w	r2, [r2, #444]	@ 0x1bc
 8000fd2:	0c12      	lsrs	r2, r2, #16
 8000fd4:	719a      	strb	r2, [r3, #6]
    aData[7] = (uint8_t)((CAN_RDH0R_DATA7 & hcan->Instance->sFIFOMailBox[RxFifo].RDHR) >> CAN_RDH0R_DATA7_Pos);
 8000fd6:	6802      	ldr	r2, [r0, #0]
 8000fd8:	4472      	add	r2, lr
 8000fda:	f8d2 21bc 	ldr.w	r2, [r2, #444]	@ 0x1bc
 8000fde:	0e12      	lsrs	r2, r2, #24
 8000fe0:	71da      	strb	r2, [r3, #7]
      SET_BIT(hcan->Instance->RF0R, CAN_RF0R_RFOM0);
 8000fe2:	6802      	ldr	r2, [r0, #0]
    if (RxFifo == CAN_RX_FIFO0) /* Rx element is assigned to Rx FIFO 0 */
 8000fe4:	b981      	cbnz	r1, 8001008 <HAL_CAN_GetRxMessage+0xfc>
      SET_BIT(hcan->Instance->RF0R, CAN_RF0R_RFOM0);
 8000fe6:	68d3      	ldr	r3, [r2, #12]
 8000fe8:	f043 0320 	orr.w	r3, r3, #32
 8000fec:	60d3      	str	r3, [r2, #12]
    return HAL_OK;
 8000fee:	2000      	movs	r0, #0
}
 8000ff0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    hcan->ErrorCode |= HAL_CAN_ERROR_NOT_INITIALIZED;
 8000ff2:	6a43      	ldr	r3, [r0, #36]	@ 0x24
 8000ff4:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
 8000ff8:	6243      	str	r3, [r0, #36]	@ 0x24
        return HAL_ERROR;
 8000ffa:	2001      	movs	r0, #1
}
 8000ffc:	4770      	bx	lr
      pHeader->StdId = (CAN_RI0R_STID & hcan->Instance->sFIFOMailBox[RxFifo].RIR) >> CAN_TI0R_STID_Pos;
 8000ffe:	f8dc 51b0 	ldr.w	r5, [ip, #432]	@ 0x1b0
 8001002:	0d6d      	lsrs	r5, r5, #21
 8001004:	6015      	str	r5, [r2, #0]
 8001006:	e7a6      	b.n	8000f56 <HAL_CAN_GetRxMessage+0x4a>
      SET_BIT(hcan->Instance->RF1R, CAN_RF1R_RFOM1);
 8001008:	6913      	ldr	r3, [r2, #16]
 800100a:	f043 0320 	orr.w	r3, r3, #32
 800100e:	6113      	str	r3, [r2, #16]
 8001010:	e7ed      	b.n	8000fee <HAL_CAN_GetRxMessage+0xe2>
 8001012:	bf00      	nop

08001014 <HAL_CAN_ActivateNotification>:
  *         This parameter can be any combination of @arg CAN_Interrupts.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CAN_ActivateNotification(CAN_HandleTypeDef *hcan, uint32_t ActiveITs)
{
  HAL_CAN_StateTypeDef state = hcan->State;
 8001014:	f890 2020 	ldrb.w	r2, [r0, #32]
{
 8001018:	4603      	mov	r3, r0

  /* Check function parameters */
  assert_param(IS_CAN_IT(ActiveITs));

  if ((state == HAL_CAN_STATE_READY) ||
 800101a:	3a01      	subs	r2, #1
 800101c:	2a01      	cmp	r2, #1
 800101e:	d905      	bls.n	800102c <HAL_CAN_ActivateNotification+0x18>
    return HAL_OK;
  }
  else
  {
    /* Update error code */
    hcan->ErrorCode |= HAL_CAN_ERROR_NOT_INITIALIZED;
 8001020:	6a5a      	ldr	r2, [r3, #36]	@ 0x24

    return HAL_ERROR;
 8001022:	2001      	movs	r0, #1
    hcan->ErrorCode |= HAL_CAN_ERROR_NOT_INITIALIZED;
 8001024:	f442 2280 	orr.w	r2, r2, #262144	@ 0x40000
 8001028:	625a      	str	r2, [r3, #36]	@ 0x24
  }
}
 800102a:	4770      	bx	lr
    __HAL_CAN_ENABLE_IT(hcan, ActiveITs);
 800102c:	6802      	ldr	r2, [r0, #0]
    return HAL_OK;
 800102e:	2000      	movs	r0, #0
    __HAL_CAN_ENABLE_IT(hcan, ActiveITs);
 8001030:	6953      	ldr	r3, [r2, #20]
 8001032:	430b      	orrs	r3, r1
 8001034:	6153      	str	r3, [r2, #20]
    return HAL_OK;
 8001036:	4770      	bx	lr

08001038 <HAL_CAN_TxMailbox0CompleteCallback>:
  * @brief  Transmission Mailbox 0 complete callback.
  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval None
  */
__weak void HAL_CAN_TxMailbox0CompleteCallback(CAN_HandleTypeDef *hcan)
 8001038:	4770      	bx	lr
 800103a:	bf00      	nop

0800103c <HAL_CAN_TxMailbox1CompleteCallback>:
  * @brief  Transmission Mailbox 1 complete callback.
  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval None
  */
__weak void HAL_CAN_TxMailbox1CompleteCallback(CAN_HandleTypeDef *hcan)
 800103c:	4770      	bx	lr
 800103e:	bf00      	nop

08001040 <HAL_CAN_TxMailbox2CompleteCallback>:
  * @brief  Transmission Mailbox 2 complete callback.
  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval None
  */
__weak void HAL_CAN_TxMailbox2CompleteCallback(CAN_HandleTypeDef *hcan)
 8001040:	4770      	bx	lr
 8001042:	bf00      	nop

08001044 <HAL_CAN_TxMailbox0AbortCallback>:
  * @brief  Transmission Mailbox 0 Cancellation callback.
  * @param  hcan pointer to an CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval None
  */
__weak void HAL_CAN_TxMailbox0AbortCallback(CAN_HandleTypeDef *hcan)
 8001044:	4770      	bx	lr
 8001046:	bf00      	nop

08001048 <HAL_CAN_TxMailbox1AbortCallback>:
  * @brief  Transmission Mailbox 1 Cancellation callback.
  * @param  hcan pointer to an CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval None
  */
__weak void HAL_CAN_TxMailbox1AbortCallback(CAN_HandleTypeDef *hcan)
 8001048:	4770      	bx	lr
 800104a:	bf00      	nop

0800104c <HAL_CAN_TxMailbox2AbortCallback>:
  * @brief  Transmission Mailbox 2 Cancellation callback.
  * @param  hcan pointer to an CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval None
  */
__weak void HAL_CAN_TxMailbox2AbortCallback(CAN_HandleTypeDef *hcan)
 800104c:	4770      	bx	lr
 800104e:	bf00      	nop

08001050 <HAL_CAN_RxFifo0FullCallback>:
  * @brief  Rx FIFO 0 full callback.
  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval None
  */
__weak void HAL_CAN_RxFifo0FullCallback(CAN_HandleTypeDef *hcan)
 8001050:	4770      	bx	lr
 8001052:	bf00      	nop

08001054 <HAL_CAN_RxFifo1MsgPendingCallback>:
  * @brief  Rx FIFO 1 message pending callback.
  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval None
  */
__weak void HAL_CAN_RxFifo1MsgPendingCallback(CAN_HandleTypeDef *hcan)
 8001054:	4770      	bx	lr
 8001056:	bf00      	nop

08001058 <HAL_CAN_RxFifo1FullCallback>:
  * @brief  Rx FIFO 1 full callback.
  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval None
  */
__weak void HAL_CAN_RxFifo1FullCallback(CAN_HandleTypeDef *hcan)
 8001058:	4770      	bx	lr
 800105a:	bf00      	nop

0800105c <HAL_CAN_SleepCallback>:
  * @brief  Sleep callback.
  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval None
  */
__weak void HAL_CAN_SleepCallback(CAN_HandleTypeDef *hcan)
 800105c:	4770      	bx	lr
 800105e:	bf00      	nop

08001060 <HAL_CAN_WakeUpFromRxMsgCallback>:
  * @brief  WakeUp from Rx message callback.
  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval None
  */
__weak void HAL_CAN_WakeUpFromRxMsgCallback(CAN_HandleTypeDef *hcan)
 8001060:	4770      	bx	lr
 8001062:	bf00      	nop

08001064 <HAL_CAN_ErrorCallback>:
  * @brief  Error CAN callback.
  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval None
  */
__weak void HAL_CAN_ErrorCallback(CAN_HandleTypeDef *hcan)
 8001064:	4770      	bx	lr
 8001066:	bf00      	nop

08001068 <HAL_CAN_IRQHandler>:
{
 8001068:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t interrupts = READ_REG(hcan->Instance->IER);
 800106c:	6803      	ldr	r3, [r0, #0]
{
 800106e:	4605      	mov	r5, r0
  uint32_t interrupts = READ_REG(hcan->Instance->IER);
 8001070:	695c      	ldr	r4, [r3, #20]
{
 8001072:	b083      	sub	sp, #12
  if ((interrupts & CAN_IT_TX_MAILBOX_EMPTY) != 0U)
 8001074:	f014 0601 	ands.w	r6, r4, #1
  uint32_t msrflags = READ_REG(hcan->Instance->MSR);
 8001078:	f8d3 8004 	ldr.w	r8, [r3, #4]
  uint32_t tsrflags = READ_REG(hcan->Instance->TSR);
 800107c:	689f      	ldr	r7, [r3, #8]
  uint32_t rf0rflags = READ_REG(hcan->Instance->RF0R);
 800107e:	f8d3 b00c 	ldr.w	fp, [r3, #12]
  uint32_t rf1rflags = READ_REG(hcan->Instance->RF1R);
 8001082:	f8d3 9010 	ldr.w	r9, [r3, #16]
  uint32_t esrflags = READ_REG(hcan->Instance->ESR);
 8001086:	f8d3 a018 	ldr.w	sl, [r3, #24]
  if ((interrupts & CAN_IT_TX_MAILBOX_EMPTY) != 0U)
 800108a:	d025      	beq.n	80010d8 <HAL_CAN_IRQHandler+0x70>
    if ((tsrflags & CAN_TSR_RQCP0) != 0U)
 800108c:	07fa      	lsls	r2, r7, #31
 800108e:	f100 8091 	bmi.w	80011b4 <HAL_CAN_IRQHandler+0x14c>
{
 8001092:	f44f 5600 	mov.w	r6, #8192	@ 0x2000
 8001096:	f44f 4080 	mov.w	r0, #16384	@ 0x4000
  uint32_t errorcode = HAL_CAN_ERROR_NONE;
 800109a:	2100      	movs	r1, #0
    if ((tsrflags & CAN_TSR_RQCP1) != 0U)
 800109c:	05fb      	lsls	r3, r7, #23
 800109e:	f140 809d 	bpl.w	80011dc <HAL_CAN_IRQHandler+0x174>
      __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_RQCP1);
 80010a2:	f44f 7280 	mov.w	r2, #256	@ 0x100
 80010a6:	682b      	ldr	r3, [r5, #0]
 80010a8:	609a      	str	r2, [r3, #8]
      if ((tsrflags & CAN_TSR_TXOK1) != 0U)
 80010aa:	05ba      	lsls	r2, r7, #22
 80010ac:	f100 8091 	bmi.w	80011d2 <HAL_CAN_IRQHandler+0x16a>
        if ((tsrflags & CAN_TSR_ALST1) != 0U)
 80010b0:	057b      	lsls	r3, r7, #21
 80010b2:	d403      	bmi.n	80010bc <HAL_CAN_IRQHandler+0x54>
        else if ((tsrflags & CAN_TSR_TERR1) != 0U)
 80010b4:	053e      	lsls	r6, r7, #20
 80010b6:	f140 80f9 	bpl.w	80012ac <HAL_CAN_IRQHandler+0x244>
          errorcode |= HAL_CAN_ERROR_TX_TERR1;
 80010ba:	4606      	mov	r6, r0
    if ((tsrflags & CAN_TSR_RQCP2) != 0U)
 80010bc:	03f9      	lsls	r1, r7, #15
 80010be:	d50b      	bpl.n	80010d8 <HAL_CAN_IRQHandler+0x70>
      __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_RQCP2);
 80010c0:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
 80010c4:	682b      	ldr	r3, [r5, #0]
 80010c6:	609a      	str	r2, [r3, #8]
      if ((tsrflags & CAN_TSR_TXOK2) != 0U)
 80010c8:	03ba      	lsls	r2, r7, #14
 80010ca:	f100 80d9 	bmi.w	8001280 <HAL_CAN_IRQHandler+0x218>
        if ((tsrflags & CAN_TSR_ALST2) != 0U)
 80010ce:	037b      	lsls	r3, r7, #13
 80010d0:	f140 80d1 	bpl.w	8001276 <HAL_CAN_IRQHandler+0x20e>
          errorcode |= HAL_CAN_ERROR_TX_ALST2;
 80010d4:	f446 4600 	orr.w	r6, r6, #32768	@ 0x8000
  if ((interrupts & CAN_IT_RX_FIFO0_OVERRUN) != 0U)
 80010d8:	0721      	lsls	r1, r4, #28
 80010da:	d502      	bpl.n	80010e2 <HAL_CAN_IRQHandler+0x7a>
    if ((rf0rflags & CAN_RF0R_FOVR0) != 0U)
 80010dc:	f01b 0f10 	tst.w	fp, #16
 80010e0:	d162      	bne.n	80011a8 <HAL_CAN_IRQHandler+0x140>
  if ((interrupts & CAN_IT_RX_FIFO0_FULL) != 0U)
 80010e2:	0762      	lsls	r2, r4, #29
 80010e4:	d502      	bpl.n	80010ec <HAL_CAN_IRQHandler+0x84>
    if ((rf0rflags & CAN_RF0R_FULL0) != 0U)
 80010e6:	f01b 0f08 	tst.w	fp, #8
 80010ea:	d179      	bne.n	80011e0 <HAL_CAN_IRQHandler+0x178>
  if ((interrupts & CAN_IT_RX_FIFO0_MSG_PENDING) != 0U)
 80010ec:	07a3      	lsls	r3, r4, #30
 80010ee:	d504      	bpl.n	80010fa <HAL_CAN_IRQHandler+0x92>
    if ((hcan->Instance->RF0R & CAN_RF0R_FMP0) != 0U)
 80010f0:	682b      	ldr	r3, [r5, #0]
 80010f2:	68db      	ldr	r3, [r3, #12]
 80010f4:	079f      	lsls	r7, r3, #30
 80010f6:	f040 8093 	bne.w	8001220 <HAL_CAN_IRQHandler+0x1b8>
  if ((interrupts & CAN_IT_RX_FIFO1_OVERRUN) != 0U)
 80010fa:	0660      	lsls	r0, r4, #25
 80010fc:	d502      	bpl.n	8001104 <HAL_CAN_IRQHandler+0x9c>
    if ((rf1rflags & CAN_RF1R_FOVR1) != 0U)
 80010fe:	f019 0f10 	tst.w	r9, #16
 8001102:	d14b      	bne.n	800119c <HAL_CAN_IRQHandler+0x134>
  if ((interrupts & CAN_IT_RX_FIFO1_FULL) != 0U)
 8001104:	06a1      	lsls	r1, r4, #26
 8001106:	d502      	bpl.n	800110e <HAL_CAN_IRQHandler+0xa6>
    if ((rf1rflags & CAN_RF1R_FULL1) != 0U)
 8001108:	f019 0f08 	tst.w	r9, #8
 800110c:	d16f      	bne.n	80011ee <HAL_CAN_IRQHandler+0x186>
  if ((interrupts & CAN_IT_RX_FIFO1_MSG_PENDING) != 0U)
 800110e:	06e2      	lsls	r2, r4, #27
 8001110:	d503      	bpl.n	800111a <HAL_CAN_IRQHandler+0xb2>
    if ((hcan->Instance->RF1R & CAN_RF1R_FMP1) != 0U)
 8001112:	682b      	ldr	r3, [r5, #0]
 8001114:	691b      	ldr	r3, [r3, #16]
 8001116:	079b      	lsls	r3, r3, #30
 8001118:	d177      	bne.n	800120a <HAL_CAN_IRQHandler+0x1a2>
  if ((interrupts & CAN_IT_SLEEP_ACK) != 0U)
 800111a:	03a7      	lsls	r7, r4, #14
 800111c:	d502      	bpl.n	8001124 <HAL_CAN_IRQHandler+0xbc>
    if ((msrflags & CAN_MSR_SLAKI) != 0U)
 800111e:	f018 0f10 	tst.w	r8, #16
 8001122:	d176      	bne.n	8001212 <HAL_CAN_IRQHandler+0x1aa>
  if ((interrupts & CAN_IT_WAKEUP) != 0U)
 8001124:	03e0      	lsls	r0, r4, #15
 8001126:	d502      	bpl.n	800112e <HAL_CAN_IRQHandler+0xc6>
    if ((msrflags & CAN_MSR_WKUI) != 0U)
 8001128:	f018 0f08 	tst.w	r8, #8
 800112c:	d166      	bne.n	80011fc <HAL_CAN_IRQHandler+0x194>
  if ((interrupts & CAN_IT_ERROR) != 0U)
 800112e:	0421      	lsls	r1, r4, #16
 8001130:	d52f      	bpl.n	8001192 <HAL_CAN_IRQHandler+0x12a>
    if ((msrflags & CAN_MSR_ERRI) != 0U)
 8001132:	f018 0f04 	tst.w	r8, #4
    __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_ERRI);
 8001136:	682b      	ldr	r3, [r5, #0]
    if ((msrflags & CAN_MSR_ERRI) != 0U)
 8001138:	d029      	beq.n	800118e <HAL_CAN_IRQHandler+0x126>
      if (((interrupts & CAN_IT_ERROR_WARNING) != 0U) &&
 800113a:	05e2      	lsls	r2, r4, #23
 800113c:	bf44      	itt	mi
 800113e:	f00a 0201 	andmi.w	r2, sl, #1
 8001142:	4316      	orrmi	r6, r2
      if (((interrupts & CAN_IT_ERROR_PASSIVE) != 0U) &&
 8001144:	05a7      	lsls	r7, r4, #22
 8001146:	d517      	bpl.n	8001178 <HAL_CAN_IRQHandler+0x110>
 8001148:	f01a 0f02 	tst.w	sl, #2
 800114c:	d014      	beq.n	8001178 <HAL_CAN_IRQHandler+0x110>
      if (((interrupts & CAN_IT_BUSOFF) != 0U) &&
 800114e:	0560      	lsls	r0, r4, #21
        errorcode |= HAL_CAN_ERROR_EPV;
 8001150:	f046 0602 	orr.w	r6, r6, #2
      if (((interrupts & CAN_IT_LAST_ERROR_CODE) != 0U) &&
 8001154:	f404 6200 	and.w	r2, r4, #2048	@ 0x800
      if (((interrupts & CAN_IT_BUSOFF) != 0U) &&
 8001158:	d56b      	bpl.n	8001232 <HAL_CAN_IRQHandler+0x1ca>
 800115a:	f01a 0f04 	tst.w	sl, #4
 800115e:	d166      	bne.n	800122e <HAL_CAN_IRQHandler+0x1c6>
      if (((interrupts & CAN_IT_LAST_ERROR_CODE) != 0U) &&
 8001160:	b992      	cbnz	r2, 8001188 <HAL_CAN_IRQHandler+0x120>
    __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_ERRI);
 8001162:	2204      	movs	r2, #4
 8001164:	605a      	str	r2, [r3, #4]
    hcan->ErrorCode |= errorcode;
 8001166:	6a6b      	ldr	r3, [r5, #36]	@ 0x24
    HAL_CAN_ErrorCallback(hcan);
 8001168:	4628      	mov	r0, r5
    hcan->ErrorCode |= errorcode;
 800116a:	4333      	orrs	r3, r6
 800116c:	626b      	str	r3, [r5, #36]	@ 0x24
    HAL_CAN_ErrorCallback(hcan);
 800116e:	f7ff ff79 	bl	8001064 <HAL_CAN_ErrorCallback>
}
 8001172:	b003      	add	sp, #12
 8001174:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      if (((interrupts & CAN_IT_BUSOFF) != 0U) &&
 8001178:	0561      	lsls	r1, r4, #21
      if (((interrupts & CAN_IT_LAST_ERROR_CODE) != 0U) &&
 800117a:	f404 6200 	and.w	r2, r4, #2048	@ 0x800
      if (((interrupts & CAN_IT_BUSOFF) != 0U) &&
 800117e:	d502      	bpl.n	8001186 <HAL_CAN_IRQHandler+0x11e>
 8001180:	f01a 0f04 	tst.w	sl, #4
 8001184:	d153      	bne.n	800122e <HAL_CAN_IRQHandler+0x1c6>
      if (((interrupts & CAN_IT_LAST_ERROR_CODE) != 0U) &&
 8001186:	b112      	cbz	r2, 800118e <HAL_CAN_IRQHandler+0x126>
 8001188:	f01a 0a70 	ands.w	sl, sl, #112	@ 0x70
 800118c:	d156      	bne.n	800123c <HAL_CAN_IRQHandler+0x1d4>
    __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_ERRI);
 800118e:	2204      	movs	r2, #4
 8001190:	605a      	str	r2, [r3, #4]
  if (errorcode != HAL_CAN_ERROR_NONE)
 8001192:	2e00      	cmp	r6, #0
 8001194:	d1e7      	bne.n	8001166 <HAL_CAN_IRQHandler+0xfe>
}
 8001196:	b003      	add	sp, #12
 8001198:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_FOV1);
 800119c:	2210      	movs	r2, #16
 800119e:	682b      	ldr	r3, [r5, #0]
      errorcode |= HAL_CAN_ERROR_RX_FOV1;
 80011a0:	f446 6680 	orr.w	r6, r6, #1024	@ 0x400
      __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_FOV1);
 80011a4:	611a      	str	r2, [r3, #16]
 80011a6:	e7ad      	b.n	8001104 <HAL_CAN_IRQHandler+0x9c>
      __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_FOV0);
 80011a8:	2210      	movs	r2, #16
 80011aa:	682b      	ldr	r3, [r5, #0]
      errorcode |= HAL_CAN_ERROR_RX_FOV0;
 80011ac:	f446 7600 	orr.w	r6, r6, #512	@ 0x200
      __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_FOV0);
 80011b0:	60da      	str	r2, [r3, #12]
 80011b2:	e796      	b.n	80010e2 <HAL_CAN_IRQHandler+0x7a>
      __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_RQCP0);
 80011b4:	2201      	movs	r2, #1
      if ((tsrflags & CAN_TSR_TXOK0) != 0U)
 80011b6:	07be      	lsls	r6, r7, #30
      __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_RQCP0);
 80011b8:	609a      	str	r2, [r3, #8]
      if ((tsrflags & CAN_TSR_TXOK0) != 0U)
 80011ba:	d435      	bmi.n	8001228 <HAL_CAN_IRQHandler+0x1c0>
        if ((tsrflags & CAN_TSR_ALST0) != 0U)
 80011bc:	0779      	lsls	r1, r7, #29
 80011be:	d453      	bmi.n	8001268 <HAL_CAN_IRQHandler+0x200>
        else if ((tsrflags & CAN_TSR_TERR0) != 0U)
 80011c0:	073a      	lsls	r2, r7, #28
 80011c2:	d570      	bpl.n	80012a6 <HAL_CAN_IRQHandler+0x23e>
 80011c4:	f44f 5640 	mov.w	r6, #12288	@ 0x3000
 80011c8:	f44f 40a0 	mov.w	r0, #20480	@ 0x5000
          errorcode |= HAL_CAN_ERROR_TX_TERR0;
 80011cc:	f44f 5180 	mov.w	r1, #4096	@ 0x1000
 80011d0:	e764      	b.n	800109c <HAL_CAN_IRQHandler+0x34>
        HAL_CAN_TxMailbox1CompleteCallback(hcan);
 80011d2:	4628      	mov	r0, r5
 80011d4:	9101      	str	r1, [sp, #4]
 80011d6:	f7ff ff31 	bl	800103c <HAL_CAN_TxMailbox1CompleteCallback>
 80011da:	9901      	ldr	r1, [sp, #4]
          errorcode |= HAL_CAN_ERROR_TX_ALST0;
 80011dc:	460e      	mov	r6, r1
 80011de:	e76d      	b.n	80010bc <HAL_CAN_IRQHandler+0x54>
      __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_FF0);
 80011e0:	2208      	movs	r2, #8
 80011e2:	682b      	ldr	r3, [r5, #0]
      HAL_CAN_RxFifo0FullCallback(hcan);
 80011e4:	4628      	mov	r0, r5
      __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_FF0);
 80011e6:	60da      	str	r2, [r3, #12]
      HAL_CAN_RxFifo0FullCallback(hcan);
 80011e8:	f7ff ff32 	bl	8001050 <HAL_CAN_RxFifo0FullCallback>
 80011ec:	e77e      	b.n	80010ec <HAL_CAN_IRQHandler+0x84>
      __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_FF1);
 80011ee:	2208      	movs	r2, #8
 80011f0:	682b      	ldr	r3, [r5, #0]
      HAL_CAN_RxFifo1FullCallback(hcan);
 80011f2:	4628      	mov	r0, r5
      __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_FF1);
 80011f4:	611a      	str	r2, [r3, #16]
      HAL_CAN_RxFifo1FullCallback(hcan);
 80011f6:	f7ff ff2f 	bl	8001058 <HAL_CAN_RxFifo1FullCallback>
 80011fa:	e788      	b.n	800110e <HAL_CAN_IRQHandler+0xa6>
      __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_WKU);
 80011fc:	2208      	movs	r2, #8
 80011fe:	682b      	ldr	r3, [r5, #0]
      HAL_CAN_WakeUpFromRxMsgCallback(hcan);
 8001200:	4628      	mov	r0, r5
      __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_WKU);
 8001202:	605a      	str	r2, [r3, #4]
      HAL_CAN_WakeUpFromRxMsgCallback(hcan);
 8001204:	f7ff ff2c 	bl	8001060 <HAL_CAN_WakeUpFromRxMsgCallback>
 8001208:	e791      	b.n	800112e <HAL_CAN_IRQHandler+0xc6>
      HAL_CAN_RxFifo1MsgPendingCallback(hcan);
 800120a:	4628      	mov	r0, r5
 800120c:	f7ff ff22 	bl	8001054 <HAL_CAN_RxFifo1MsgPendingCallback>
 8001210:	e783      	b.n	800111a <HAL_CAN_IRQHandler+0xb2>
      __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_SLAKI);
 8001212:	2210      	movs	r2, #16
 8001214:	682b      	ldr	r3, [r5, #0]
      HAL_CAN_SleepCallback(hcan);
 8001216:	4628      	mov	r0, r5
      __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_SLAKI);
 8001218:	605a      	str	r2, [r3, #4]
      HAL_CAN_SleepCallback(hcan);
 800121a:	f7ff ff1f 	bl	800105c <HAL_CAN_SleepCallback>
 800121e:	e781      	b.n	8001124 <HAL_CAN_IRQHandler+0xbc>
      HAL_CAN_RxFifo0MsgPendingCallback(hcan);
 8001220:	4628      	mov	r0, r5
 8001222:	f7ff fb17 	bl	8000854 <HAL_CAN_RxFifo0MsgPendingCallback>
 8001226:	e768      	b.n	80010fa <HAL_CAN_IRQHandler+0x92>
        HAL_CAN_TxMailbox0CompleteCallback(hcan);
 8001228:	f7ff ff06 	bl	8001038 <HAL_CAN_TxMailbox0CompleteCallback>
 800122c:	e731      	b.n	8001092 <HAL_CAN_IRQHandler+0x2a>
        errorcode |= HAL_CAN_ERROR_BOF;
 800122e:	f046 0604 	orr.w	r6, r6, #4
      if (((interrupts & CAN_IT_LAST_ERROR_CODE) != 0U) &&
 8001232:	2a00      	cmp	r2, #0
 8001234:	d095      	beq.n	8001162 <HAL_CAN_IRQHandler+0xfa>
 8001236:	f01a 0a70 	ands.w	sl, sl, #112	@ 0x70
 800123a:	d092      	beq.n	8001162 <HAL_CAN_IRQHandler+0xfa>
        switch (esrflags & CAN_ESR_LEC)
 800123c:	f1ba 0f40 	cmp.w	sl, #64	@ 0x40
 8001240:	d044      	beq.n	80012cc <HAL_CAN_IRQHandler+0x264>
 8001242:	d821      	bhi.n	8001288 <HAL_CAN_IRQHandler+0x220>
 8001244:	f1ba 0f20 	cmp.w	sl, #32
 8001248:	d05b      	beq.n	8001302 <HAL_CAN_IRQHandler+0x29a>
 800124a:	f1ba 0f30 	cmp.w	sl, #48	@ 0x30
 800124e:	d04f      	beq.n	80012f0 <HAL_CAN_IRQHandler+0x288>
 8001250:	f1ba 0f10 	cmp.w	sl, #16
 8001254:	d135      	bne.n	80012c2 <HAL_CAN_IRQHandler+0x25a>
    __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_ERRI);
 8001256:	2104      	movs	r1, #4
        CLEAR_BIT(hcan->Instance->ESR, CAN_ESR_LEC);
 8001258:	699a      	ldr	r2, [r3, #24]
            errorcode |= HAL_CAN_ERROR_STF;
 800125a:	f046 0608 	orr.w	r6, r6, #8
        CLEAR_BIT(hcan->Instance->ESR, CAN_ESR_LEC);
 800125e:	f022 0270 	bic.w	r2, r2, #112	@ 0x70
 8001262:	619a      	str	r2, [r3, #24]
    __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_ERRI);
 8001264:	6059      	str	r1, [r3, #4]
  if (errorcode != HAL_CAN_ERROR_NONE)
 8001266:	e77e      	b.n	8001166 <HAL_CAN_IRQHandler+0xfe>
 8001268:	f44f 5620 	mov.w	r6, #10240	@ 0x2800
 800126c:	f44f 4090 	mov.w	r0, #18432	@ 0x4800
          errorcode |= HAL_CAN_ERROR_TX_ALST0;
 8001270:	f44f 6100 	mov.w	r1, #2048	@ 0x800
 8001274:	e712      	b.n	800109c <HAL_CAN_IRQHandler+0x34>
        else if ((tsrflags & CAN_TSR_TERR2) != 0U)
 8001276:	0338      	lsls	r0, r7, #12
 8001278:	d51f      	bpl.n	80012ba <HAL_CAN_IRQHandler+0x252>
          errorcode |= HAL_CAN_ERROR_TX_TERR2;
 800127a:	f446 3680 	orr.w	r6, r6, #65536	@ 0x10000
 800127e:	e72b      	b.n	80010d8 <HAL_CAN_IRQHandler+0x70>
        HAL_CAN_TxMailbox2CompleteCallback(hcan);
 8001280:	4628      	mov	r0, r5
 8001282:	f7ff fedd 	bl	8001040 <HAL_CAN_TxMailbox2CompleteCallback>
 8001286:	e727      	b.n	80010d8 <HAL_CAN_IRQHandler+0x70>
        switch (esrflags & CAN_ESR_LEC)
 8001288:	f1ba 0f50 	cmp.w	sl, #80	@ 0x50
 800128c:	d027      	beq.n	80012de <HAL_CAN_IRQHandler+0x276>
 800128e:	f1ba 0f60 	cmp.w	sl, #96	@ 0x60
 8001292:	d116      	bne.n	80012c2 <HAL_CAN_IRQHandler+0x25a>
    __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_ERRI);
 8001294:	2104      	movs	r1, #4
        CLEAR_BIT(hcan->Instance->ESR, CAN_ESR_LEC);
 8001296:	699a      	ldr	r2, [r3, #24]
            errorcode |= HAL_CAN_ERROR_CRC;
 8001298:	f446 7680 	orr.w	r6, r6, #256	@ 0x100
        CLEAR_BIT(hcan->Instance->ESR, CAN_ESR_LEC);
 800129c:	f022 0270 	bic.w	r2, r2, #112	@ 0x70
 80012a0:	619a      	str	r2, [r3, #24]
    __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_ERRI);
 80012a2:	6059      	str	r1, [r3, #4]
  if (errorcode != HAL_CAN_ERROR_NONE)
 80012a4:	e75f      	b.n	8001166 <HAL_CAN_IRQHandler+0xfe>
          HAL_CAN_TxMailbox0AbortCallback(hcan);
 80012a6:	f7ff fecd 	bl	8001044 <HAL_CAN_TxMailbox0AbortCallback>
 80012aa:	e6f2      	b.n	8001092 <HAL_CAN_IRQHandler+0x2a>
          HAL_CAN_TxMailbox1AbortCallback(hcan);
 80012ac:	4628      	mov	r0, r5
 80012ae:	9101      	str	r1, [sp, #4]
 80012b0:	f7ff feca 	bl	8001048 <HAL_CAN_TxMailbox1AbortCallback>
 80012b4:	9901      	ldr	r1, [sp, #4]
          errorcode |= HAL_CAN_ERROR_TX_ALST0;
 80012b6:	460e      	mov	r6, r1
 80012b8:	e700      	b.n	80010bc <HAL_CAN_IRQHandler+0x54>
          HAL_CAN_TxMailbox2AbortCallback(hcan);
 80012ba:	4628      	mov	r0, r5
 80012bc:	f7ff fec6 	bl	800104c <HAL_CAN_TxMailbox2AbortCallback>
 80012c0:	e70a      	b.n	80010d8 <HAL_CAN_IRQHandler+0x70>
        CLEAR_BIT(hcan->Instance->ESR, CAN_ESR_LEC);
 80012c2:	699a      	ldr	r2, [r3, #24]
 80012c4:	f022 0270 	bic.w	r2, r2, #112	@ 0x70
 80012c8:	619a      	str	r2, [r3, #24]
 80012ca:	e760      	b.n	800118e <HAL_CAN_IRQHandler+0x126>
    __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_ERRI);
 80012cc:	2104      	movs	r1, #4
        CLEAR_BIT(hcan->Instance->ESR, CAN_ESR_LEC);
 80012ce:	699a      	ldr	r2, [r3, #24]
            errorcode |= HAL_CAN_ERROR_BR;
 80012d0:	f046 0640 	orr.w	r6, r6, #64	@ 0x40
        CLEAR_BIT(hcan->Instance->ESR, CAN_ESR_LEC);
 80012d4:	f022 0270 	bic.w	r2, r2, #112	@ 0x70
 80012d8:	619a      	str	r2, [r3, #24]
    __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_ERRI);
 80012da:	6059      	str	r1, [r3, #4]
  if (errorcode != HAL_CAN_ERROR_NONE)
 80012dc:	e743      	b.n	8001166 <HAL_CAN_IRQHandler+0xfe>
    __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_ERRI);
 80012de:	2104      	movs	r1, #4
        CLEAR_BIT(hcan->Instance->ESR, CAN_ESR_LEC);
 80012e0:	699a      	ldr	r2, [r3, #24]
            errorcode |= HAL_CAN_ERROR_BD;
 80012e2:	f046 0680 	orr.w	r6, r6, #128	@ 0x80
        CLEAR_BIT(hcan->Instance->ESR, CAN_ESR_LEC);
 80012e6:	f022 0270 	bic.w	r2, r2, #112	@ 0x70
 80012ea:	619a      	str	r2, [r3, #24]
    __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_ERRI);
 80012ec:	6059      	str	r1, [r3, #4]
  if (errorcode != HAL_CAN_ERROR_NONE)
 80012ee:	e73a      	b.n	8001166 <HAL_CAN_IRQHandler+0xfe>
    __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_ERRI);
 80012f0:	2104      	movs	r1, #4
        CLEAR_BIT(hcan->Instance->ESR, CAN_ESR_LEC);
 80012f2:	699a      	ldr	r2, [r3, #24]
            errorcode |= HAL_CAN_ERROR_ACK;
 80012f4:	f046 0620 	orr.w	r6, r6, #32
        CLEAR_BIT(hcan->Instance->ESR, CAN_ESR_LEC);
 80012f8:	f022 0270 	bic.w	r2, r2, #112	@ 0x70
 80012fc:	619a      	str	r2, [r3, #24]
    __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_ERRI);
 80012fe:	6059      	str	r1, [r3, #4]
  if (errorcode != HAL_CAN_ERROR_NONE)
 8001300:	e731      	b.n	8001166 <HAL_CAN_IRQHandler+0xfe>
    __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_ERRI);
 8001302:	2104      	movs	r1, #4
        CLEAR_BIT(hcan->Instance->ESR, CAN_ESR_LEC);
 8001304:	699a      	ldr	r2, [r3, #24]
            errorcode |= HAL_CAN_ERROR_FOR;
 8001306:	f046 0610 	orr.w	r6, r6, #16
        CLEAR_BIT(hcan->Instance->ESR, CAN_ESR_LEC);
 800130a:	f022 0270 	bic.w	r2, r2, #112	@ 0x70
 800130e:	619a      	str	r2, [r3, #24]
    __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_ERRI);
 8001310:	6059      	str	r1, [r3, #4]
  if (errorcode != HAL_CAN_ERROR_NONE)
 8001312:	e728      	b.n	8001166 <HAL_CAN_IRQHandler+0xfe>

08001314 <HAL_NVIC_SetPriorityGrouping>:
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8001314:	f64f 0cff 	movw	ip, #63743	@ 0xf8ff
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8001318:	4906      	ldr	r1, [pc, #24]	@ (8001334 <HAL_NVIC_SetPriorityGrouping+0x20>)
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos) );               /* Insert write key and priority group */
 800131a:	0203      	lsls	r3, r0, #8
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 800131c:	68ca      	ldr	r2, [r1, #12]
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos) );               /* Insert write key and priority group */
 800131e:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8001322:	ea02 020c 	and.w	r2, r2, ip
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8001326:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 8001328:	f043 63bf 	orr.w	r3, r3, #100139008	@ 0x5f80000
 800132c:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
  SCB->AIRCR =  reg_value;
 8001330:	60cb      	str	r3, [r1, #12]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 8001332:	4770      	bx	lr
 8001334:	e000ed00 	.word	0xe000ed00

08001338 <HAL_NVIC_SetPriority>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8001338:	4b1b      	ldr	r3, [pc, #108]	@ (80013a8 <HAL_NVIC_SetPriority+0x70>)
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 800133a:	b500      	push	{lr}
 800133c:	68db      	ldr	r3, [r3, #12]
 800133e:	f3c3 2302 	ubfx	r3, r3, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8001342:	f1c3 0e07 	rsb	lr, r3, #7
 8001346:	f1be 0f04 	cmp.w	lr, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800134a:	f103 0c04 	add.w	ip, r3, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800134e:	bf28      	it	cs
 8001350:	f04f 0e04 	movcs.w	lr, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8001354:	f1bc 0f06 	cmp.w	ip, #6
 8001358:	d91c      	bls.n	8001394 <HAL_NVIC_SetPriority+0x5c>
 800135a:	f1a3 0c03 	sub.w	ip, r3, #3

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 800135e:	f04f 33ff 	mov.w	r3, #4294967295
 8001362:	fa03 f30c 	lsl.w	r3, r3, ip
 8001366:	ea22 0203 	bic.w	r2, r2, r3
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800136a:	f04f 33ff 	mov.w	r3, #4294967295
 800136e:	fa03 f30e 	lsl.w	r3, r3, lr
 8001372:	ea21 0303 	bic.w	r3, r1, r3
 8001376:	fa03 f30c 	lsl.w	r3, r3, ip
 800137a:	4313      	orrs	r3, r2
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800137c:	011b      	lsls	r3, r3, #4
  if ((int32_t)(IRQn) >= 0)
 800137e:	2800      	cmp	r0, #0
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001380:	b2db      	uxtb	r3, r3
  if ((int32_t)(IRQn) >= 0)
 8001382:	db0a      	blt.n	800139a <HAL_NVIC_SetPriority+0x62>
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001384:	f100 4060 	add.w	r0, r0, #3758096384	@ 0xe0000000
 8001388:	f500 4061 	add.w	r0, r0, #57600	@ 0xe100
 800138c:	f880 3300 	strb.w	r3, [r0, #768]	@ 0x300
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 8001390:	f85d fb04 	ldr.w	pc, [sp], #4
 8001394:	2200      	movs	r2, #0
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8001396:	4694      	mov	ip, r2
 8001398:	e7e7      	b.n	800136a <HAL_NVIC_SetPriority+0x32>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800139a:	4a04      	ldr	r2, [pc, #16]	@ (80013ac <HAL_NVIC_SetPriority+0x74>)
 800139c:	f000 000f 	and.w	r0, r0, #15
 80013a0:	4402      	add	r2, r0
 80013a2:	7613      	strb	r3, [r2, #24]
 80013a4:	f85d fb04 	ldr.w	pc, [sp], #4
 80013a8:	e000ed00 	.word	0xe000ed00
 80013ac:	e000ecfc 	.word	0xe000ecfc

080013b0 <HAL_NVIC_EnableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 80013b0:	2800      	cmp	r0, #0
 80013b2:	db07      	blt.n	80013c4 <HAL_NVIC_EnableIRQ+0x14>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 80013b4:	2301      	movs	r3, #1
 80013b6:	f000 011f 	and.w	r1, r0, #31
 80013ba:	4a03      	ldr	r2, [pc, #12]	@ (80013c8 <HAL_NVIC_EnableIRQ+0x18>)
 80013bc:	0940      	lsrs	r0, r0, #5
 80013be:	408b      	lsls	r3, r1
 80013c0:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 80013c4:	4770      	bx	lr
 80013c6:	bf00      	nop
 80013c8:	e000e100 	.word	0xe000e100

080013cc <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 80013cc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 80013d0:	680c      	ldr	r4, [r1, #0]
{
 80013d2:	b085      	sub	sp, #20
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 80013d4:	2c00      	cmp	r4, #0
 80013d6:	f000 80a9 	beq.w	800152c <HAL_GPIO_Init+0x160>
 80013da:	4bb3      	ldr	r3, [pc, #716]	@ (80016a8 <HAL_GPIO_Init+0x2dc>)
 80013dc:	4298      	cmp	r0, r3
 80013de:	f000 80d3 	beq.w	8001588 <HAL_GPIO_Init+0x1bc>
 80013e2:	2200      	movs	r2, #0
          break;
      }

      /* Check if the current bit belongs to first half or last half of the pin count number
       in order to address CRH or CRL register*/
      configregister = (iocurrent < GPIO_PIN_8) ? &GPIOx->CRL     : &GPIOx->CRH;
 80013e4:	1d03      	adds	r3, r0, #4
 80013e6:	9301      	str	r3, [sp, #4]
    ioposition = (0x01uL << position);
 80013e8:	2501      	movs	r5, #1
      registeroffset = (iocurrent < GPIO_PIN_8) ? (position << 2u) : ((position - 8u) << 2u);

      /* Apply the new configuration of the pin to the register */
      MODIFY_REG((*configregister), ((GPIO_CRL_MODE0 | GPIO_CRL_CNF0) << registeroffset), (config << registeroffset));
 80013ea:	270f      	movs	r7, #15
  uint32_t config = 0x00u;
 80013ec:	4692      	mov	sl, r2
  uint32_t position = 0x00u;
 80013ee:	4613      	mov	r3, r2
 80013f0:	4683      	mov	fp, r0
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable AFIO Clock */
        __HAL_RCC_AFIO_CLK_ENABLE();
 80013f2:	f8df 82b8 	ldr.w	r8, [pc, #696]	@ 80016ac <HAL_GPIO_Init+0x2e0>
 80013f6:	e006      	b.n	8001406 <HAL_GPIO_Init+0x3a>
          CLEAR_BIT(EXTI->IMR, iocurrent);
        }
      }
    }

	position++;
 80013f8:	3301      	adds	r3, #1
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 80013fa:	fa34 f003 	lsrs.w	r0, r4, r3
 80013fe:	f102 0204 	add.w	r2, r2, #4
 8001402:	f000 8093 	beq.w	800152c <HAL_GPIO_Init+0x160>
    ioposition = (0x01uL << position);
 8001406:	fa05 f003 	lsl.w	r0, r5, r3
    if (iocurrent == ioposition)
 800140a:	ea30 0c04 	bics.w	ip, r0, r4
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 800140e:	ea00 0604 	and.w	r6, r0, r4
    if (iocurrent == ioposition)
 8001412:	d1f1      	bne.n	80013f8 <HAL_GPIO_Init+0x2c>
      switch (GPIO_Init->Mode)
 8001414:	684c      	ldr	r4, [r1, #4]
 8001416:	2c12      	cmp	r4, #18
 8001418:	f200 809c 	bhi.w	8001554 <HAL_GPIO_Init+0x188>
 800141c:	2c12      	cmp	r4, #18
 800141e:	d816      	bhi.n	800144e <HAL_GPIO_Init+0x82>
 8001420:	e8df f014 	tbh	[pc, r4, lsl #1]
 8001424:	001300ab 	.word	0x001300ab
 8001428:	01890094 	.word	0x01890094
 800142c:	00150015 	.word	0x00150015
 8001430:	00150015 	.word	0x00150015
 8001434:	00150015 	.word	0x00150015
 8001438:	00150015 	.word	0x00150015
 800143c:	00150015 	.word	0x00150015
 8001440:	00150015 	.word	0x00150015
 8001444:	00900015 	.word	0x00900015
 8001448:	008c      	.short	0x008c
          config = GPIO_Init->Speed + GPIO_CR_CNF_GP_OUTPUT_PP;
 800144a:	f8d1 a00c 	ldr.w	sl, [r1, #12]
      configregister = (iocurrent < GPIO_PIN_8) ? &GPIOx->CRL     : &GPIOx->CRH;
 800144e:	2eff      	cmp	r6, #255	@ 0xff
 8001450:	bf99      	ittee	ls
 8001452:	465c      	movls	r4, fp
      registeroffset = (iocurrent < GPIO_PIN_8) ? (position << 2u) : ((position - 8u) << 2u);
 8001454:	4694      	movls	ip, r2
      configregister = (iocurrent < GPIO_PIN_8) ? &GPIOx->CRL     : &GPIOx->CRH;
 8001456:	9c01      	ldrhi	r4, [sp, #4]
      registeroffset = (iocurrent < GPIO_PIN_8) ? (position << 2u) : ((position - 8u) << 2u);
 8001458:	f1a2 0c20 	subhi.w	ip, r2, #32
      MODIFY_REG((*configregister), ((GPIO_CRL_MODE0 | GPIO_CRL_CNF0) << registeroffset), (config << registeroffset));
 800145c:	6820      	ldr	r0, [r4, #0]
 800145e:	fa07 fe0c 	lsl.w	lr, r7, ip
 8001462:	ea20 000e 	bic.w	r0, r0, lr
 8001466:	fa0a fc0c 	lsl.w	ip, sl, ip
 800146a:	ea40 000c 	orr.w	r0, r0, ip
 800146e:	6020      	str	r0, [r4, #0]
      if ((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8001470:	684c      	ldr	r4, [r1, #4]
 8001472:	00e0      	lsls	r0, r4, #3
 8001474:	d560      	bpl.n	8001538 <HAL_GPIO_Init+0x16c>
        __HAL_RCC_AFIO_CLK_ENABLE();
 8001476:	f8d8 0018 	ldr.w	r0, [r8, #24]
 800147a:	f023 0c03 	bic.w	ip, r3, #3
 800147e:	f040 0001 	orr.w	r0, r0, #1
 8001482:	f8c8 0018 	str.w	r0, [r8, #24]
 8001486:	f8d8 0018 	ldr.w	r0, [r8, #24]
 800148a:	f10c 4c80 	add.w	ip, ip, #1073741824	@ 0x40000000
 800148e:	f000 0001 	and.w	r0, r0, #1
 8001492:	9003      	str	r0, [sp, #12]
 8001494:	f50c 3c80 	add.w	ip, ip, #65536	@ 0x10000
        CLEAR_BIT(temp, (0x0Fu) << (4u * (position & 0x03u)));
 8001498:	f003 0903 	and.w	r9, r3, #3
        __HAL_RCC_AFIO_CLK_ENABLE();
 800149c:	9803      	ldr	r0, [sp, #12]
        CLEAR_BIT(temp, (0x0Fu) << (4u * (position & 0x03u)));
 800149e:	ea4f 0989 	mov.w	r9, r9, lsl #2
        temp = AFIO->EXTICR[position >> 2u];
 80014a2:	f8dc 0008 	ldr.w	r0, [ip, #8]
        CLEAR_BIT(temp, (0x0Fu) << (4u * (position & 0x03u)));
 80014a6:	fa07 fe09 	lsl.w	lr, r7, r9
 80014aa:	ea20 0e0e 	bic.w	lr, r0, lr
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4u * (position & 0x03u)));
 80014ae:	4880      	ldr	r0, [pc, #512]	@ (80016b0 <HAL_GPIO_Init+0x2e4>)
 80014b0:	4583      	cmp	fp, r0
 80014b2:	f000 8126 	beq.w	8001702 <HAL_GPIO_Init+0x336>
 80014b6:	487f      	ldr	r0, [pc, #508]	@ (80016b4 <HAL_GPIO_Init+0x2e8>)
 80014b8:	4583      	cmp	fp, r0
 80014ba:	bf0c      	ite	eq
 80014bc:	2002      	moveq	r0, #2
 80014be:	2003      	movne	r0, #3
 80014c0:	fa00 f009 	lsl.w	r0, r0, r9
 80014c4:	ea40 000e 	orr.w	r0, r0, lr
        AFIO->EXTICR[position >> 2u] = temp;
 80014c8:	f8cc 0008 	str.w	r0, [ip, #8]
          SET_BIT(EXTI->RTSR, iocurrent);
 80014cc:	f8df c1e8 	ldr.w	ip, [pc, #488]	@ 80016b8 <HAL_GPIO_Init+0x2ec>
        if ((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 80014d0:	f414 1f80 	tst.w	r4, #1048576	@ 0x100000
          SET_BIT(EXTI->RTSR, iocurrent);
 80014d4:	f8dc 0008 	ldr.w	r0, [ip, #8]
 80014d8:	bf14      	ite	ne
 80014da:	4330      	orrne	r0, r6
          CLEAR_BIT(EXTI->RTSR, iocurrent);
 80014dc:	43b0      	biceq	r0, r6
 80014de:	f8cc 0008 	str.w	r0, [ip, #8]
          SET_BIT(EXTI->FTSR, iocurrent);
 80014e2:	f8df c1d4 	ldr.w	ip, [pc, #468]	@ 80016b8 <HAL_GPIO_Init+0x2ec>
        if ((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 80014e6:	f414 1f00 	tst.w	r4, #2097152	@ 0x200000
          SET_BIT(EXTI->FTSR, iocurrent);
 80014ea:	f8dc 000c 	ldr.w	r0, [ip, #12]
 80014ee:	bf14      	ite	ne
 80014f0:	4330      	orrne	r0, r6
          CLEAR_BIT(EXTI->FTSR, iocurrent);
 80014f2:	43b0      	biceq	r0, r6
 80014f4:	f8cc 000c 	str.w	r0, [ip, #12]
          SET_BIT(EXTI->EMR, iocurrent);
 80014f8:	f8df c1bc 	ldr.w	ip, [pc, #444]	@ 80016b8 <HAL_GPIO_Init+0x2ec>
        if ((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 80014fc:	f414 3f00 	tst.w	r4, #131072	@ 0x20000
          SET_BIT(EXTI->EMR, iocurrent);
 8001500:	f8dc 0004 	ldr.w	r0, [ip, #4]
 8001504:	bf14      	ite	ne
 8001506:	4330      	orrne	r0, r6
          CLEAR_BIT(EXTI->EMR, iocurrent);
 8001508:	43b0      	biceq	r0, r6
        if ((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 800150a:	f414 3f80 	tst.w	r4, #65536	@ 0x10000
          SET_BIT(EXTI->IMR, iocurrent);
 800150e:	4c6a      	ldr	r4, [pc, #424]	@ (80016b8 <HAL_GPIO_Init+0x2ec>)
          CLEAR_BIT(EXTI->EMR, iocurrent);
 8001510:	f8cc 0004 	str.w	r0, [ip, #4]
          SET_BIT(EXTI->IMR, iocurrent);
 8001514:	6820      	ldr	r0, [r4, #0]
        if ((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8001516:	d00c      	beq.n	8001532 <HAL_GPIO_Init+0x166>
          SET_BIT(EXTI->IMR, iocurrent);
 8001518:	4330      	orrs	r0, r6
 800151a:	6020      	str	r0, [r4, #0]
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 800151c:	680c      	ldr	r4, [r1, #0]
	position++;
 800151e:	3301      	adds	r3, #1
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 8001520:	fa34 f003 	lsrs.w	r0, r4, r3
 8001524:	f102 0204 	add.w	r2, r2, #4
 8001528:	f47f af6d 	bne.w	8001406 <HAL_GPIO_Init+0x3a>
  }
}
 800152c:	b005      	add	sp, #20
 800152e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
          CLEAR_BIT(EXTI->IMR, iocurrent);
 8001532:	ea20 0006 	bic.w	r0, r0, r6
 8001536:	6020      	str	r0, [r4, #0]
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 8001538:	680c      	ldr	r4, [r1, #0]
 800153a:	e75d      	b.n	80013f8 <HAL_GPIO_Init+0x2c>
          config = GPIO_Init->Speed + GPIO_CR_CNF_AF_OUTPUT_OD;
 800153c:	68c8      	ldr	r0, [r1, #12]
 800153e:	f100 0a0c 	add.w	sl, r0, #12
          break;
 8001542:	e784      	b.n	800144e <HAL_GPIO_Init+0x82>
          config = GPIO_Init->Speed + GPIO_CR_CNF_GP_OUTPUT_OD;
 8001544:	68c8      	ldr	r0, [r1, #12]
 8001546:	f100 0a04 	add.w	sl, r0, #4
          break;
 800154a:	e780      	b.n	800144e <HAL_GPIO_Init+0x82>
          config = GPIO_Init->Speed + GPIO_CR_CNF_AF_OUTPUT_PP;
 800154c:	68c8      	ldr	r0, [r1, #12]
 800154e:	f100 0a08 	add.w	sl, r0, #8
          break;
 8001552:	e77c      	b.n	800144e <HAL_GPIO_Init+0x82>
      switch (GPIO_Init->Mode)
 8001554:	f8df c164 	ldr.w	ip, [pc, #356]	@ 80016bc <HAL_GPIO_Init+0x2f0>
 8001558:	4564      	cmp	r4, ip
 800155a:	d00e      	beq.n	800157a <HAL_GPIO_Init+0x1ae>
 800155c:	f200 80d7 	bhi.w	800170e <HAL_GPIO_Init+0x342>
 8001560:	f5ac 1c80 	sub.w	ip, ip, #1048576	@ 0x100000
 8001564:	4564      	cmp	r4, ip
 8001566:	d008      	beq.n	800157a <HAL_GPIO_Init+0x1ae>
 8001568:	f50c 2c70 	add.w	ip, ip, #983040	@ 0xf0000
 800156c:	4564      	cmp	r4, ip
 800156e:	d004      	beq.n	800157a <HAL_GPIO_Init+0x1ae>
 8001570:	f5ac 1c80 	sub.w	ip, ip, #1048576	@ 0x100000
 8001574:	4564      	cmp	r4, ip
 8001576:	f47f af6a 	bne.w	800144e <HAL_GPIO_Init+0x82>
          if (GPIO_Init->Pull == GPIO_NOPULL)
 800157a:	688c      	ldr	r4, [r1, #8]
 800157c:	2c00      	cmp	r4, #0
 800157e:	f040 80d1 	bne.w	8001724 <HAL_GPIO_Init+0x358>
            config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_FLOATING;
 8001582:	f04f 0a04 	mov.w	sl, #4
 8001586:	e762      	b.n	800144e <HAL_GPIO_Init+0x82>
  uint32_t config = 0x00u;
 8001588:	f04f 0900 	mov.w	r9, #0
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 800158c:	f06f 051f 	mvn.w	r5, #31
    ioposition = (0x01uL << position);
 8001590:	2701      	movs	r7, #1
      MODIFY_REG((*configregister), ((GPIO_CRL_MODE0 | GPIO_CRL_CNF0) << registeroffset), (config << registeroffset));
 8001592:	f04f 0e0f 	mov.w	lr, #15
  uint32_t position = 0x00u;
 8001596:	464b      	mov	r3, r9
        __HAL_RCC_AFIO_CLK_ENABLE();
 8001598:	f8df c110 	ldr.w	ip, [pc, #272]	@ 80016ac <HAL_GPIO_Init+0x2e0>
      configregister = (iocurrent < GPIO_PIN_8) ? &GPIOx->CRL     : &GPIOx->CRH;
 800159c:	f8df 8120 	ldr.w	r8, [pc, #288]	@ 80016c0 <HAL_GPIO_Init+0x2f4>
 80015a0:	e005      	b.n	80015ae <HAL_GPIO_Init+0x1e2>
	position++;
 80015a2:	3301      	adds	r3, #1
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 80015a4:	fa34 f203 	lsrs.w	r2, r4, r3
 80015a8:	f105 0504 	add.w	r5, r5, #4
 80015ac:	d0be      	beq.n	800152c <HAL_GPIO_Init+0x160>
    ioposition = (0x01uL << position);
 80015ae:	fa07 f203 	lsl.w	r2, r7, r3
    if (iocurrent == ioposition)
 80015b2:	ea32 0a04 	bics.w	sl, r2, r4
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 80015b6:	ea04 0602 	and.w	r6, r4, r2
    if (iocurrent == ioposition)
 80015ba:	d1f2      	bne.n	80015a2 <HAL_GPIO_Init+0x1d6>
      switch (GPIO_Init->Mode)
 80015bc:	684c      	ldr	r4, [r1, #4]
 80015be:	2c12      	cmp	r4, #18
 80015c0:	f200 80bc 	bhi.w	800173c <HAL_GPIO_Init+0x370>
 80015c4:	2c12      	cmp	r4, #18
 80015c6:	d816      	bhi.n	80015f6 <HAL_GPIO_Init+0x22a>
 80015c8:	e8df f014 	tbh	[pc, r4, lsl #1]
 80015cc:	001300ca 	.word	0x001300ca
 80015d0:	00ec00d7 	.word	0x00ec00d7
 80015d4:	00150015 	.word	0x00150015
 80015d8:	00150015 	.word	0x00150015
 80015dc:	00150015 	.word	0x00150015
 80015e0:	00150015 	.word	0x00150015
 80015e4:	00150015 	.word	0x00150015
 80015e8:	00150015 	.word	0x00150015
 80015ec:	00db0015 	.word	0x00db0015
 80015f0:	00d3      	.short	0x00d3
          config = GPIO_Init->Speed + GPIO_CR_CNF_GP_OUTPUT_PP;
 80015f2:	f8d1 900c 	ldr.w	r9, [r1, #12]
      configregister = (iocurrent < GPIO_PIN_8) ? &GPIOx->CRL     : &GPIOx->CRH;
 80015f6:	2eff      	cmp	r6, #255	@ 0xff
 80015f8:	d951      	bls.n	800169e <HAL_GPIO_Init+0x2d2>
      registeroffset = (iocurrent < GPIO_PIN_8) ? (position << 2u) : ((position - 8u) << 2u);
 80015fa:	46aa      	mov	sl, r5
      configregister = (iocurrent < GPIO_PIN_8) ? &GPIOx->CRL     : &GPIOx->CRH;
 80015fc:	4644      	mov	r4, r8
      MODIFY_REG((*configregister), ((GPIO_CRL_MODE0 | GPIO_CRL_CNF0) << registeroffset), (config << registeroffset));
 80015fe:	6822      	ldr	r2, [r4, #0]
 8001600:	fa0e fb0a 	lsl.w	fp, lr, sl
 8001604:	ea22 020b 	bic.w	r2, r2, fp
 8001608:	fa09 fa0a 	lsl.w	sl, r9, sl
 800160c:	ea42 020a 	orr.w	r2, r2, sl
 8001610:	6022      	str	r2, [r4, #0]
      if ((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8001612:	684a      	ldr	r2, [r1, #4]
 8001614:	00d4      	lsls	r4, r2, #3
 8001616:	d555      	bpl.n	80016c4 <HAL_GPIO_Init+0x2f8>
        __HAL_RCC_AFIO_CLK_ENABLE();
 8001618:	f8dc 4018 	ldr.w	r4, [ip, #24]
        CLEAR_BIT(temp, (0x0Fu) << (4u * (position & 0x03u)));
 800161c:	f003 0a03 	and.w	sl, r3, #3
        __HAL_RCC_AFIO_CLK_ENABLE();
 8001620:	f044 0401 	orr.w	r4, r4, #1
 8001624:	f8cc 4018 	str.w	r4, [ip, #24]
 8001628:	f8dc 4018 	ldr.w	r4, [ip, #24]
        CLEAR_BIT(temp, (0x0Fu) << (4u * (position & 0x03u)));
 800162c:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
        __HAL_RCC_AFIO_CLK_ENABLE();
 8001630:	f004 0401 	and.w	r4, r4, #1
 8001634:	9403      	str	r4, [sp, #12]
 8001636:	9c03      	ldr	r4, [sp, #12]
        temp = AFIO->EXTICR[position >> 2u];
 8001638:	f023 0403 	bic.w	r4, r3, #3
 800163c:	f104 4480 	add.w	r4, r4, #1073741824	@ 0x40000000
 8001640:	f504 3480 	add.w	r4, r4, #65536	@ 0x10000
 8001644:	f8d4 b008 	ldr.w	fp, [r4, #8]
        CLEAR_BIT(temp, (0x0Fu) << (4u * (position & 0x03u)));
 8001648:	fa0e fa0a 	lsl.w	sl, lr, sl
 800164c:	ea2b 0a0a 	bic.w	sl, fp, sl
        AFIO->EXTICR[position >> 2u] = temp;
 8001650:	f8c4 a008 	str.w	sl, [r4, #8]
        if ((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8001654:	02d4      	lsls	r4, r2, #11
 8001656:	d537      	bpl.n	80016c8 <HAL_GPIO_Init+0x2fc>
          SET_BIT(EXTI->RTSR, iocurrent);
 8001658:	f8df a05c 	ldr.w	sl, [pc, #92]	@ 80016b8 <HAL_GPIO_Init+0x2ec>
 800165c:	f8da 4008 	ldr.w	r4, [sl, #8]
 8001660:	4334      	orrs	r4, r6
 8001662:	f8ca 4008 	str.w	r4, [sl, #8]
        if ((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8001666:	0294      	lsls	r4, r2, #10
 8001668:	d538      	bpl.n	80016dc <HAL_GPIO_Init+0x310>
          SET_BIT(EXTI->FTSR, iocurrent);
 800166a:	f8df a04c 	ldr.w	sl, [pc, #76]	@ 80016b8 <HAL_GPIO_Init+0x2ec>
 800166e:	f8da 400c 	ldr.w	r4, [sl, #12]
 8001672:	4334      	orrs	r4, r6
 8001674:	f8ca 400c 	str.w	r4, [sl, #12]
        if ((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8001678:	0394      	lsls	r4, r2, #14
 800167a:	d539      	bpl.n	80016f0 <HAL_GPIO_Init+0x324>
          SET_BIT(EXTI->EMR, iocurrent);
 800167c:	f8df a038 	ldr.w	sl, [pc, #56]	@ 80016b8 <HAL_GPIO_Init+0x2ec>
 8001680:	f8da 4004 	ldr.w	r4, [sl, #4]
 8001684:	4334      	orrs	r4, r6
 8001686:	f8ca 4004 	str.w	r4, [sl, #4]
          SET_BIT(EXTI->IMR, iocurrent);
 800168a:	4c0b      	ldr	r4, [pc, #44]	@ (80016b8 <HAL_GPIO_Init+0x2ec>)
        if ((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 800168c:	f412 3f80 	tst.w	r2, #65536	@ 0x10000
          SET_BIT(EXTI->IMR, iocurrent);
 8001690:	6822      	ldr	r2, [r4, #0]
          CLEAR_BIT(EXTI->IMR, iocurrent);
 8001692:	bf0c      	ite	eq
 8001694:	43b2      	biceq	r2, r6
          SET_BIT(EXTI->IMR, iocurrent);
 8001696:	4332      	orrne	r2, r6
 8001698:	6022      	str	r2, [r4, #0]
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 800169a:	680c      	ldr	r4, [r1, #0]
 800169c:	e781      	b.n	80015a2 <HAL_GPIO_Init+0x1d6>
      configregister = (iocurrent < GPIO_PIN_8) ? &GPIOx->CRL     : &GPIOx->CRH;
 800169e:	4604      	mov	r4, r0
 80016a0:	ea4f 0a83 	mov.w	sl, r3, lsl #2
 80016a4:	e7ab      	b.n	80015fe <HAL_GPIO_Init+0x232>
 80016a6:	bf00      	nop
 80016a8:	40010800 	.word	0x40010800
 80016ac:	40021000 	.word	0x40021000
 80016b0:	40010c00 	.word	0x40010c00
 80016b4:	40011000 	.word	0x40011000
 80016b8:	40010400 	.word	0x40010400
 80016bc:	10220000 	.word	0x10220000
 80016c0:	40010804 	.word	0x40010804
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 80016c4:	680c      	ldr	r4, [r1, #0]
 80016c6:	e76c      	b.n	80015a2 <HAL_GPIO_Init+0x1d6>
          CLEAR_BIT(EXTI->RTSR, iocurrent);
 80016c8:	f8df a0e4 	ldr.w	sl, [pc, #228]	@ 80017b0 <HAL_GPIO_Init+0x3e4>
 80016cc:	f8da 4008 	ldr.w	r4, [sl, #8]
 80016d0:	ea24 0406 	bic.w	r4, r4, r6
 80016d4:	f8ca 4008 	str.w	r4, [sl, #8]
        if ((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 80016d8:	0294      	lsls	r4, r2, #10
 80016da:	d4c6      	bmi.n	800166a <HAL_GPIO_Init+0x29e>
          CLEAR_BIT(EXTI->FTSR, iocurrent);
 80016dc:	f8df a0d0 	ldr.w	sl, [pc, #208]	@ 80017b0 <HAL_GPIO_Init+0x3e4>
 80016e0:	f8da 400c 	ldr.w	r4, [sl, #12]
 80016e4:	ea24 0406 	bic.w	r4, r4, r6
 80016e8:	f8ca 400c 	str.w	r4, [sl, #12]
        if ((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 80016ec:	0394      	lsls	r4, r2, #14
 80016ee:	d4c5      	bmi.n	800167c <HAL_GPIO_Init+0x2b0>
          CLEAR_BIT(EXTI->EMR, iocurrent);
 80016f0:	f8df a0bc 	ldr.w	sl, [pc, #188]	@ 80017b0 <HAL_GPIO_Init+0x3e4>
 80016f4:	f8da 4004 	ldr.w	r4, [sl, #4]
 80016f8:	ea24 0406 	bic.w	r4, r4, r6
 80016fc:	f8ca 4004 	str.w	r4, [sl, #4]
 8001700:	e7c3      	b.n	800168a <HAL_GPIO_Init+0x2be>
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4u * (position & 0x03u)));
 8001702:	2001      	movs	r0, #1
 8001704:	fa00 f009 	lsl.w	r0, r0, r9
 8001708:	ea40 000e 	orr.w	r0, r0, lr
 800170c:	e6dc      	b.n	80014c8 <HAL_GPIO_Init+0xfc>
      switch (GPIO_Init->Mode)
 800170e:	f8df c0a4 	ldr.w	ip, [pc, #164]	@ 80017b4 <HAL_GPIO_Init+0x3e8>
 8001712:	4564      	cmp	r4, ip
 8001714:	f43f af31 	beq.w	800157a <HAL_GPIO_Init+0x1ae>
 8001718:	f50c 3c80 	add.w	ip, ip, #65536	@ 0x10000
 800171c:	4564      	cmp	r4, ip
 800171e:	f47f ae96 	bne.w	800144e <HAL_GPIO_Init+0x82>
 8001722:	e72a      	b.n	800157a <HAL_GPIO_Init+0x1ae>
          else if (GPIO_Init->Pull == GPIO_PULLUP)
 8001724:	2c01      	cmp	r4, #1
            config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_PU_PD;
 8001726:	f04f 0a08 	mov.w	sl, #8
            GPIOx->BSRR = ioposition;
 800172a:	bf0c      	ite	eq
 800172c:	f8cb 0010 	streq.w	r0, [fp, #16]
            GPIOx->BRR = ioposition;
 8001730:	f8cb 0014 	strne.w	r0, [fp, #20]
 8001734:	e68b      	b.n	800144e <HAL_GPIO_Init+0x82>
      switch (GPIO_Init->Mode)
 8001736:	f04f 0a00 	mov.w	sl, #0
 800173a:	e688      	b.n	800144e <HAL_GPIO_Init+0x82>
 800173c:	f8df a078 	ldr.w	sl, [pc, #120]	@ 80017b8 <HAL_GPIO_Init+0x3ec>
 8001740:	4554      	cmp	r4, sl
 8001742:	d00d      	beq.n	8001760 <HAL_GPIO_Init+0x394>
 8001744:	d821      	bhi.n	800178a <HAL_GPIO_Init+0x3be>
 8001746:	f5aa 1a80 	sub.w	sl, sl, #1048576	@ 0x100000
 800174a:	4554      	cmp	r4, sl
 800174c:	d008      	beq.n	8001760 <HAL_GPIO_Init+0x394>
 800174e:	f50a 2a70 	add.w	sl, sl, #983040	@ 0xf0000
 8001752:	4554      	cmp	r4, sl
 8001754:	d004      	beq.n	8001760 <HAL_GPIO_Init+0x394>
 8001756:	f5aa 1a80 	sub.w	sl, sl, #1048576	@ 0x100000
 800175a:	4554      	cmp	r4, sl
 800175c:	f47f af4b 	bne.w	80015f6 <HAL_GPIO_Init+0x22a>
          if (GPIO_Init->Pull == GPIO_NOPULL)
 8001760:	688c      	ldr	r4, [r1, #8]
 8001762:	b1e4      	cbz	r4, 800179e <HAL_GPIO_Init+0x3d2>
          else if (GPIO_Init->Pull == GPIO_PULLUP)
 8001764:	2c01      	cmp	r4, #1
            GPIOx->BSRR = ioposition;
 8001766:	4c15      	ldr	r4, [pc, #84]	@ (80017bc <HAL_GPIO_Init+0x3f0>)
          else if (GPIO_Init->Pull == GPIO_PULLUP)
 8001768:	d01f      	beq.n	80017aa <HAL_GPIO_Init+0x3de>
            GPIOx->BRR = ioposition;
 800176a:	6162      	str	r2, [r4, #20]
            config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_PU_PD;
 800176c:	f04f 0908 	mov.w	r9, #8
 8001770:	e741      	b.n	80015f6 <HAL_GPIO_Init+0x22a>
          config = GPIO_Init->Speed + GPIO_CR_CNF_AF_OUTPUT_OD;
 8001772:	68ca      	ldr	r2, [r1, #12]
 8001774:	f102 090c 	add.w	r9, r2, #12
          break;
 8001778:	e73d      	b.n	80015f6 <HAL_GPIO_Init+0x22a>
          config = GPIO_Init->Speed + GPIO_CR_CNF_AF_OUTPUT_PP;
 800177a:	68ca      	ldr	r2, [r1, #12]
 800177c:	f102 0908 	add.w	r9, r2, #8
          break;
 8001780:	e739      	b.n	80015f6 <HAL_GPIO_Init+0x22a>
          config = GPIO_Init->Speed + GPIO_CR_CNF_GP_OUTPUT_OD;
 8001782:	68ca      	ldr	r2, [r1, #12]
 8001784:	f102 0904 	add.w	r9, r2, #4
          break;
 8001788:	e735      	b.n	80015f6 <HAL_GPIO_Init+0x22a>
      switch (GPIO_Init->Mode)
 800178a:	f8df a028 	ldr.w	sl, [pc, #40]	@ 80017b4 <HAL_GPIO_Init+0x3e8>
 800178e:	4554      	cmp	r4, sl
 8001790:	d0e6      	beq.n	8001760 <HAL_GPIO_Init+0x394>
 8001792:	f50a 3a80 	add.w	sl, sl, #65536	@ 0x10000
 8001796:	4554      	cmp	r4, sl
 8001798:	f47f af2d 	bne.w	80015f6 <HAL_GPIO_Init+0x22a>
 800179c:	e7e0      	b.n	8001760 <HAL_GPIO_Init+0x394>
            config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_FLOATING;
 800179e:	f04f 0904 	mov.w	r9, #4
 80017a2:	e728      	b.n	80015f6 <HAL_GPIO_Init+0x22a>
          config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_ANALOG;
 80017a4:	f04f 0900 	mov.w	r9, #0
 80017a8:	e725      	b.n	80015f6 <HAL_GPIO_Init+0x22a>
            GPIOx->BSRR = ioposition;
 80017aa:	6122      	str	r2, [r4, #16]
 80017ac:	e7de      	b.n	800176c <HAL_GPIO_Init+0x3a0>
 80017ae:	bf00      	nop
 80017b0:	40010400 	.word	0x40010400
 80017b4:	10310000 	.word	0x10310000
 80017b8:	10220000 	.word	0x10220000
 80017bc:	40010800 	.word	0x40010800

080017c0 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 80017c0:	b902      	cbnz	r2, 80017c4 <HAL_GPIO_WritePin+0x4>
  {
    GPIOx->BSRR = GPIO_Pin;
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16u;
 80017c2:	0409      	lsls	r1, r1, #16
 80017c4:	6101      	str	r1, [r0, #16]
  }
}
 80017c6:	4770      	bx	lr

080017c8 <HAL_RCC_OscConfig>:
{
  uint32_t tickstart;
  uint32_t pll_config;

  /* Check Null pointer */
  if (RCC_OscInitStruct == NULL)
 80017c8:	2800      	cmp	r0, #0
 80017ca:	f000 81e4 	beq.w	8001b96 <HAL_RCC_OscConfig+0x3ce>
{
 80017ce:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*------------------------------- HSE Configuration ------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 80017d2:	6803      	ldr	r3, [r0, #0]
 80017d4:	4604      	mov	r4, r0
 80017d6:	07dd      	lsls	r5, r3, #31
{
 80017d8:	b082      	sub	sp, #8
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 80017da:	d535      	bpl.n	8001848 <HAL_RCC_OscConfig+0x80>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    if ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE)
 80017dc:	4999      	ldr	r1, [pc, #612]	@ (8001a44 <HAL_RCC_OscConfig+0x27c>)
 80017de:	684a      	ldr	r2, [r1, #4]
 80017e0:	f002 020c 	and.w	r2, r2, #12
 80017e4:	2a04      	cmp	r2, #4
 80017e6:	f000 80ed 	beq.w	80019c4 <HAL_RCC_OscConfig+0x1fc>
        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
 80017ea:	684a      	ldr	r2, [r1, #4]
 80017ec:	f002 020c 	and.w	r2, r2, #12
 80017f0:	2a08      	cmp	r2, #8
 80017f2:	f000 80e3 	beq.w	80019bc <HAL_RCC_OscConfig+0x1f4>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80017f6:	6863      	ldr	r3, [r4, #4]
 80017f8:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 80017fc:	d010      	beq.n	8001820 <HAL_RCC_OscConfig+0x58>
 80017fe:	2b00      	cmp	r3, #0
 8001800:	f000 810a 	beq.w	8001a18 <HAL_RCC_OscConfig+0x250>
 8001804:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
 8001808:	f000 8180 	beq.w	8001b0c <HAL_RCC_OscConfig+0x344>
 800180c:	4b8d      	ldr	r3, [pc, #564]	@ (8001a44 <HAL_RCC_OscConfig+0x27c>)
 800180e:	681a      	ldr	r2, [r3, #0]
 8001810:	f422 3280 	bic.w	r2, r2, #65536	@ 0x10000
 8001814:	601a      	str	r2, [r3, #0]
 8001816:	681a      	ldr	r2, [r3, #0]
 8001818:	f422 2280 	bic.w	r2, r2, #262144	@ 0x40000
 800181c:	601a      	str	r2, [r3, #0]


      /* Check the HSE State */
      if (RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 800181e:	e004      	b.n	800182a <HAL_RCC_OscConfig+0x62>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8001820:	4a88      	ldr	r2, [pc, #544]	@ (8001a44 <HAL_RCC_OscConfig+0x27c>)
 8001822:	6813      	ldr	r3, [r2, #0]
 8001824:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 8001828:	6013      	str	r3, [r2, #0]
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800182a:	f7ff f9d9 	bl	8000be0 <HAL_GetTick>

        /* Wait till HSE is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800182e:	4e85      	ldr	r6, [pc, #532]	@ (8001a44 <HAL_RCC_OscConfig+0x27c>)
        tickstart = HAL_GetTick();
 8001830:	4605      	mov	r5, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8001832:	e005      	b.n	8001840 <HAL_RCC_OscConfig+0x78>
        {
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8001834:	f7ff f9d4 	bl	8000be0 <HAL_GetTick>
 8001838:	1b40      	subs	r0, r0, r5
 800183a:	2864      	cmp	r0, #100	@ 0x64
 800183c:	f200 80e8 	bhi.w	8001a10 <HAL_RCC_OscConfig+0x248>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8001840:	6833      	ldr	r3, [r6, #0]
 8001842:	039a      	lsls	r2, r3, #14
 8001844:	d5f6      	bpl.n	8001834 <HAL_RCC_OscConfig+0x6c>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8001846:	6823      	ldr	r3, [r4, #0]
 8001848:	079f      	lsls	r7, r3, #30
 800184a:	d528      	bpl.n	800189e <HAL_RCC_OscConfig+0xd6>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI)
 800184c:	4a7d      	ldr	r2, [pc, #500]	@ (8001a44 <HAL_RCC_OscConfig+0x27c>)
 800184e:	6851      	ldr	r1, [r2, #4]
 8001850:	f011 0f0c 	tst.w	r1, #12
 8001854:	f000 8096 	beq.w	8001984 <HAL_RCC_OscConfig+0x1bc>
        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI_DIV2)))
 8001858:	6851      	ldr	r1, [r2, #4]
 800185a:	f001 010c 	and.w	r1, r1, #12
 800185e:	2908      	cmp	r1, #8
 8001860:	f000 808c 	beq.w	800197c <HAL_RCC_OscConfig+0x1b4>
      }
    }
    else
    {
      /* Check the HSI State */
      if (RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 8001864:	6923      	ldr	r3, [r4, #16]
 8001866:	2b00      	cmp	r3, #0
 8001868:	f000 8116 	beq.w	8001a98 <HAL_RCC_OscConfig+0x2d0>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 800186c:	2201      	movs	r2, #1
 800186e:	4b76      	ldr	r3, [pc, #472]	@ (8001a48 <HAL_RCC_OscConfig+0x280>)

        /* Get Start Tick */
        tickstart = HAL_GetTick();

        /* Wait till HSI is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8001870:	4e74      	ldr	r6, [pc, #464]	@ (8001a44 <HAL_RCC_OscConfig+0x27c>)
        __HAL_RCC_HSI_ENABLE();
 8001872:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 8001874:	f7ff f9b4 	bl	8000be0 <HAL_GetTick>
 8001878:	4605      	mov	r5, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800187a:	e005      	b.n	8001888 <HAL_RCC_OscConfig+0xc0>
        {
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 800187c:	f7ff f9b0 	bl	8000be0 <HAL_GetTick>
 8001880:	1b40      	subs	r0, r0, r5
 8001882:	2802      	cmp	r0, #2
 8001884:	f200 80c4 	bhi.w	8001a10 <HAL_RCC_OscConfig+0x248>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8001888:	6833      	ldr	r3, [r6, #0]
 800188a:	0798      	lsls	r0, r3, #30
 800188c:	d5f6      	bpl.n	800187c <HAL_RCC_OscConfig+0xb4>
            return HAL_TIMEOUT;
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800188e:	6833      	ldr	r3, [r6, #0]
 8001890:	6962      	ldr	r2, [r4, #20]
 8001892:	f023 03f8 	bic.w	r3, r3, #248	@ 0xf8
 8001896:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
 800189a:	6033      	str	r3, [r6, #0]
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 800189c:	6823      	ldr	r3, [r4, #0]
 800189e:	071a      	lsls	r2, r3, #28
 80018a0:	d429      	bmi.n	80018f6 <HAL_RCC_OscConfig+0x12e>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 80018a2:	075d      	lsls	r5, r3, #29
 80018a4:	d54b      	bpl.n	800193e <HAL_RCC_OscConfig+0x176>
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if (__HAL_RCC_PWR_IS_CLK_DISABLED())
 80018a6:	4b67      	ldr	r3, [pc, #412]	@ (8001a44 <HAL_RCC_OscConfig+0x27c>)
 80018a8:	69da      	ldr	r2, [r3, #28]
 80018aa:	00d0      	lsls	r0, r2, #3
 80018ac:	f100 8084 	bmi.w	80019b8 <HAL_RCC_OscConfig+0x1f0>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
      pwrclkchanged = SET;
 80018b0:	2501      	movs	r5, #1
      __HAL_RCC_PWR_CLK_ENABLE();
 80018b2:	69da      	ldr	r2, [r3, #28]
 80018b4:	f042 5280 	orr.w	r2, r2, #268435456	@ 0x10000000
 80018b8:	61da      	str	r2, [r3, #28]
 80018ba:	69db      	ldr	r3, [r3, #28]
 80018bc:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 80018c0:	9300      	str	r3, [sp, #0]
 80018c2:	9b00      	ldr	r3, [sp, #0]
    }

    if (HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 80018c4:	4e61      	ldr	r6, [pc, #388]	@ (8001a4c <HAL_RCC_OscConfig+0x284>)
 80018c6:	6833      	ldr	r3, [r6, #0]
 80018c8:	05d9      	lsls	r1, r3, #23
 80018ca:	f140 8091 	bpl.w	80019f0 <HAL_RCC_OscConfig+0x228>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80018ce:	68e3      	ldr	r3, [r4, #12]
 80018d0:	2b01      	cmp	r3, #1
 80018d2:	f000 80f2 	beq.w	8001aba <HAL_RCC_OscConfig+0x2f2>
 80018d6:	2b00      	cmp	r3, #0
 80018d8:	f000 80be 	beq.w	8001a58 <HAL_RCC_OscConfig+0x290>
 80018dc:	2b05      	cmp	r3, #5
 80018de:	4b59      	ldr	r3, [pc, #356]	@ (8001a44 <HAL_RCC_OscConfig+0x27c>)
 80018e0:	6a1a      	ldr	r2, [r3, #32]
 80018e2:	f000 8120 	beq.w	8001b26 <HAL_RCC_OscConfig+0x35e>
 80018e6:	f022 0201 	bic.w	r2, r2, #1
 80018ea:	621a      	str	r2, [r3, #32]
 80018ec:	6a1a      	ldr	r2, [r3, #32]
 80018ee:	f022 0204 	bic.w	r2, r2, #4
 80018f2:	621a      	str	r2, [r3, #32]
    /* Check the LSE State */
    if (RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 80018f4:	e0e6      	b.n	8001ac4 <HAL_RCC_OscConfig+0x2fc>
    if (RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 80018f6:	69a3      	ldr	r3, [r4, #24]
 80018f8:	2b00      	cmp	r3, #0
 80018fa:	d04c      	beq.n	8001996 <HAL_RCC_OscConfig+0x1ce>
      __HAL_RCC_LSI_ENABLE();
 80018fc:	2201      	movs	r2, #1
 80018fe:	4b52      	ldr	r3, [pc, #328]	@ (8001a48 <HAL_RCC_OscConfig+0x280>)
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8001900:	4e50      	ldr	r6, [pc, #320]	@ (8001a44 <HAL_RCC_OscConfig+0x27c>)
      __HAL_RCC_LSI_ENABLE();
 8001902:	f8c3 2480 	str.w	r2, [r3, #1152]	@ 0x480
      tickstart = HAL_GetTick();
 8001906:	f7ff f96b 	bl	8000be0 <HAL_GetTick>
 800190a:	4605      	mov	r5, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 800190c:	e004      	b.n	8001918 <HAL_RCC_OscConfig+0x150>
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 800190e:	f7ff f967 	bl	8000be0 <HAL_GetTick>
 8001912:	1b40      	subs	r0, r0, r5
 8001914:	2802      	cmp	r0, #2
 8001916:	d87b      	bhi.n	8001a10 <HAL_RCC_OscConfig+0x248>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8001918:	6a73      	ldr	r3, [r6, #36]	@ 0x24
 800191a:	079b      	lsls	r3, r3, #30
 800191c:	d5f7      	bpl.n	800190e <HAL_RCC_OscConfig+0x146>
  * @param  mdelay: specifies the delay time length, in milliseconds.
  * @retval None
  */
static void RCC_Delay(uint32_t mdelay)
{
  __IO uint32_t Delay = mdelay * (SystemCoreClock / 8U / 1000U);
 800191e:	4b4c      	ldr	r3, [pc, #304]	@ (8001a50 <HAL_RCC_OscConfig+0x288>)
 8001920:	4a4c      	ldr	r2, [pc, #304]	@ (8001a54 <HAL_RCC_OscConfig+0x28c>)
 8001922:	681b      	ldr	r3, [r3, #0]
 8001924:	fba2 2303 	umull	r2, r3, r2, r3
 8001928:	0a5b      	lsrs	r3, r3, #9
 800192a:	9301      	str	r3, [sp, #4]
  do
  {
    __NOP();
 800192c:	bf00      	nop
  }
  while (Delay --);
 800192e:	9b01      	ldr	r3, [sp, #4]
 8001930:	1e5a      	subs	r2, r3, #1
 8001932:	9201      	str	r2, [sp, #4]
 8001934:	2b00      	cmp	r3, #0
 8001936:	d1f9      	bne.n	800192c <HAL_RCC_OscConfig+0x164>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8001938:	6823      	ldr	r3, [r4, #0]
 800193a:	075d      	lsls	r5, r3, #29
 800193c:	d4b3      	bmi.n	80018a6 <HAL_RCC_OscConfig+0xde>
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 800193e:	69e3      	ldr	r3, [r4, #28]
 8001940:	b1c3      	cbz	r3, 8001974 <HAL_RCC_OscConfig+0x1ac>
    if (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8001942:	4d40      	ldr	r5, [pc, #256]	@ (8001a44 <HAL_RCC_OscConfig+0x27c>)
 8001944:	686a      	ldr	r2, [r5, #4]
 8001946:	f002 020c 	and.w	r2, r2, #12
 800194a:	2a08      	cmp	r2, #8
 800194c:	f000 80cd 	beq.w	8001aea <HAL_RCC_OscConfig+0x322>
        __HAL_RCC_PLL_DISABLE();
 8001950:	2200      	movs	r2, #0
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8001952:	2b02      	cmp	r3, #2
        __HAL_RCC_PLL_DISABLE();
 8001954:	4b3c      	ldr	r3, [pc, #240]	@ (8001a48 <HAL_RCC_OscConfig+0x280>)
 8001956:	661a      	str	r2, [r3, #96]	@ 0x60
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8001958:	f000 80ed 	beq.w	8001b36 <HAL_RCC_OscConfig+0x36e>
        tickstart = HAL_GetTick();
 800195c:	f7ff f940 	bl	8000be0 <HAL_GetTick>
 8001960:	4604      	mov	r4, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 8001962:	e004      	b.n	800196e <HAL_RCC_OscConfig+0x1a6>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8001964:	f7ff f93c 	bl	8000be0 <HAL_GetTick>
 8001968:	1b00      	subs	r0, r0, r4
 800196a:	2802      	cmp	r0, #2
 800196c:	d850      	bhi.n	8001a10 <HAL_RCC_OscConfig+0x248>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 800196e:	682b      	ldr	r3, [r5, #0]
 8001970:	019b      	lsls	r3, r3, #6
 8001972:	d4f7      	bmi.n	8001964 <HAL_RCC_OscConfig+0x19c>
  return HAL_OK;
 8001974:	2000      	movs	r0, #0
}
 8001976:	b002      	add	sp, #8
 8001978:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI_DIV2)))
 800197c:	6852      	ldr	r2, [r2, #4]
 800197e:	03d6      	lsls	r6, r2, #15
 8001980:	f53f af70 	bmi.w	8001864 <HAL_RCC_OscConfig+0x9c>
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8001984:	4a2f      	ldr	r2, [pc, #188]	@ (8001a44 <HAL_RCC_OscConfig+0x27c>)
 8001986:	6812      	ldr	r2, [r2, #0]
 8001988:	0795      	lsls	r5, r2, #30
 800198a:	d525      	bpl.n	80019d8 <HAL_RCC_OscConfig+0x210>
 800198c:	6922      	ldr	r2, [r4, #16]
 800198e:	2a01      	cmp	r2, #1
 8001990:	d022      	beq.n	80019d8 <HAL_RCC_OscConfig+0x210>
    return HAL_ERROR;
 8001992:	2001      	movs	r0, #1
 8001994:	e7ef      	b.n	8001976 <HAL_RCC_OscConfig+0x1ae>
      __HAL_RCC_LSI_DISABLE();
 8001996:	4a2c      	ldr	r2, [pc, #176]	@ (8001a48 <HAL_RCC_OscConfig+0x280>)
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8001998:	4e2a      	ldr	r6, [pc, #168]	@ (8001a44 <HAL_RCC_OscConfig+0x27c>)
      __HAL_RCC_LSI_DISABLE();
 800199a:	f8c2 3480 	str.w	r3, [r2, #1152]	@ 0x480
      tickstart = HAL_GetTick();
 800199e:	f7ff f91f 	bl	8000be0 <HAL_GetTick>
 80019a2:	4605      	mov	r5, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 80019a4:	e004      	b.n	80019b0 <HAL_RCC_OscConfig+0x1e8>
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 80019a6:	f7ff f91b 	bl	8000be0 <HAL_GetTick>
 80019aa:	1b40      	subs	r0, r0, r5
 80019ac:	2802      	cmp	r0, #2
 80019ae:	d82f      	bhi.n	8001a10 <HAL_RCC_OscConfig+0x248>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 80019b0:	6a73      	ldr	r3, [r6, #36]	@ 0x24
 80019b2:	079f      	lsls	r7, r3, #30
 80019b4:	d4f7      	bmi.n	80019a6 <HAL_RCC_OscConfig+0x1de>
 80019b6:	e7bf      	b.n	8001938 <HAL_RCC_OscConfig+0x170>
    FlagStatus       pwrclkchanged = RESET;
 80019b8:	2500      	movs	r5, #0
 80019ba:	e783      	b.n	80018c4 <HAL_RCC_OscConfig+0xfc>
        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
 80019bc:	684a      	ldr	r2, [r1, #4]
 80019be:	03d0      	lsls	r0, r2, #15
 80019c0:	f57f af19 	bpl.w	80017f6 <HAL_RCC_OscConfig+0x2e>
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 80019c4:	4a1f      	ldr	r2, [pc, #124]	@ (8001a44 <HAL_RCC_OscConfig+0x27c>)
 80019c6:	6812      	ldr	r2, [r2, #0]
 80019c8:	0391      	lsls	r1, r2, #14
 80019ca:	f57f af3d 	bpl.w	8001848 <HAL_RCC_OscConfig+0x80>
 80019ce:	6862      	ldr	r2, [r4, #4]
 80019d0:	2a00      	cmp	r2, #0
 80019d2:	f47f af39 	bne.w	8001848 <HAL_RCC_OscConfig+0x80>
 80019d6:	e7dc      	b.n	8001992 <HAL_RCC_OscConfig+0x1ca>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80019d8:	491a      	ldr	r1, [pc, #104]	@ (8001a44 <HAL_RCC_OscConfig+0x27c>)
 80019da:	6960      	ldr	r0, [r4, #20]
 80019dc:	680a      	ldr	r2, [r1, #0]
 80019de:	f022 02f8 	bic.w	r2, r2, #248	@ 0xf8
 80019e2:	ea42 02c0 	orr.w	r2, r2, r0, lsl #3
 80019e6:	600a      	str	r2, [r1, #0]
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 80019e8:	071a      	lsls	r2, r3, #28
 80019ea:	f57f af5a 	bpl.w	80018a2 <HAL_RCC_OscConfig+0xda>
 80019ee:	e782      	b.n	80018f6 <HAL_RCC_OscConfig+0x12e>
      SET_BIT(PWR->CR, PWR_CR_DBP);
 80019f0:	6833      	ldr	r3, [r6, #0]
 80019f2:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 80019f6:	6033      	str	r3, [r6, #0]
      tickstart = HAL_GetTick();
 80019f8:	f7ff f8f2 	bl	8000be0 <HAL_GetTick>
 80019fc:	4607      	mov	r7, r0
      while (HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 80019fe:	6833      	ldr	r3, [r6, #0]
 8001a00:	05da      	lsls	r2, r3, #23
 8001a02:	f53f af64 	bmi.w	80018ce <HAL_RCC_OscConfig+0x106>
        if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8001a06:	f7ff f8eb 	bl	8000be0 <HAL_GetTick>
 8001a0a:	1bc0      	subs	r0, r0, r7
 8001a0c:	2864      	cmp	r0, #100	@ 0x64
 8001a0e:	d9f6      	bls.n	80019fe <HAL_RCC_OscConfig+0x236>
            return HAL_TIMEOUT;
 8001a10:	2003      	movs	r0, #3
}
 8001a12:	b002      	add	sp, #8
 8001a14:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8001a18:	4d0a      	ldr	r5, [pc, #40]	@ (8001a44 <HAL_RCC_OscConfig+0x27c>)
 8001a1a:	682b      	ldr	r3, [r5, #0]
 8001a1c:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 8001a20:	602b      	str	r3, [r5, #0]
 8001a22:	682b      	ldr	r3, [r5, #0]
 8001a24:	f423 2380 	bic.w	r3, r3, #262144	@ 0x40000
 8001a28:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 8001a2a:	f7ff f8d9 	bl	8000be0 <HAL_GetTick>
 8001a2e:	4606      	mov	r6, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8001a30:	e004      	b.n	8001a3c <HAL_RCC_OscConfig+0x274>
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8001a32:	f7ff f8d5 	bl	8000be0 <HAL_GetTick>
 8001a36:	1b80      	subs	r0, r0, r6
 8001a38:	2864      	cmp	r0, #100	@ 0x64
 8001a3a:	d8e9      	bhi.n	8001a10 <HAL_RCC_OscConfig+0x248>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8001a3c:	682b      	ldr	r3, [r5, #0]
 8001a3e:	039b      	lsls	r3, r3, #14
 8001a40:	d4f7      	bmi.n	8001a32 <HAL_RCC_OscConfig+0x26a>
 8001a42:	e700      	b.n	8001846 <HAL_RCC_OscConfig+0x7e>
 8001a44:	40021000 	.word	0x40021000
 8001a48:	42420000 	.word	0x42420000
 8001a4c:	40007000 	.word	0x40007000
 8001a50:	2000001c 	.word	0x2000001c
 8001a54:	10624dd3 	.word	0x10624dd3
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8001a58:	4e50      	ldr	r6, [pc, #320]	@ (8001b9c <HAL_RCC_OscConfig+0x3d4>)
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8001a5a:	f241 3888 	movw	r8, #5000	@ 0x1388
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8001a5e:	6a33      	ldr	r3, [r6, #32]
 8001a60:	f023 0301 	bic.w	r3, r3, #1
 8001a64:	6233      	str	r3, [r6, #32]
 8001a66:	6a33      	ldr	r3, [r6, #32]
 8001a68:	f023 0304 	bic.w	r3, r3, #4
 8001a6c:	6233      	str	r3, [r6, #32]
      tickstart = HAL_GetTick();
 8001a6e:	f7ff f8b7 	bl	8000be0 <HAL_GetTick>
 8001a72:	4607      	mov	r7, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8001a74:	e004      	b.n	8001a80 <HAL_RCC_OscConfig+0x2b8>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8001a76:	f7ff f8b3 	bl	8000be0 <HAL_GetTick>
 8001a7a:	1bc0      	subs	r0, r0, r7
 8001a7c:	4540      	cmp	r0, r8
 8001a7e:	d8c7      	bhi.n	8001a10 <HAL_RCC_OscConfig+0x248>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8001a80:	6a33      	ldr	r3, [r6, #32]
 8001a82:	0798      	lsls	r0, r3, #30
 8001a84:	d4f7      	bmi.n	8001a76 <HAL_RCC_OscConfig+0x2ae>
    if (pwrclkchanged == SET)
 8001a86:	2d00      	cmp	r5, #0
 8001a88:	f43f af59 	beq.w	800193e <HAL_RCC_OscConfig+0x176>
      __HAL_RCC_PWR_CLK_DISABLE();
 8001a8c:	4a43      	ldr	r2, [pc, #268]	@ (8001b9c <HAL_RCC_OscConfig+0x3d4>)
 8001a8e:	69d3      	ldr	r3, [r2, #28]
 8001a90:	f023 5380 	bic.w	r3, r3, #268435456	@ 0x10000000
 8001a94:	61d3      	str	r3, [r2, #28]
 8001a96:	e752      	b.n	800193e <HAL_RCC_OscConfig+0x176>
        __HAL_RCC_HSI_DISABLE();
 8001a98:	4a41      	ldr	r2, [pc, #260]	@ (8001ba0 <HAL_RCC_OscConfig+0x3d8>)
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8001a9a:	4e40      	ldr	r6, [pc, #256]	@ (8001b9c <HAL_RCC_OscConfig+0x3d4>)
        __HAL_RCC_HSI_DISABLE();
 8001a9c:	6013      	str	r3, [r2, #0]
        tickstart = HAL_GetTick();
 8001a9e:	f7ff f89f 	bl	8000be0 <HAL_GetTick>
 8001aa2:	4605      	mov	r5, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8001aa4:	e004      	b.n	8001ab0 <HAL_RCC_OscConfig+0x2e8>
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8001aa6:	f7ff f89b 	bl	8000be0 <HAL_GetTick>
 8001aaa:	1b40      	subs	r0, r0, r5
 8001aac:	2802      	cmp	r0, #2
 8001aae:	d8af      	bhi.n	8001a10 <HAL_RCC_OscConfig+0x248>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8001ab0:	6833      	ldr	r3, [r6, #0]
 8001ab2:	0799      	lsls	r1, r3, #30
 8001ab4:	d4f7      	bmi.n	8001aa6 <HAL_RCC_OscConfig+0x2de>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8001ab6:	6823      	ldr	r3, [r4, #0]
 8001ab8:	e6f1      	b.n	800189e <HAL_RCC_OscConfig+0xd6>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8001aba:	4a38      	ldr	r2, [pc, #224]	@ (8001b9c <HAL_RCC_OscConfig+0x3d4>)
 8001abc:	6a13      	ldr	r3, [r2, #32]
 8001abe:	f043 0301 	orr.w	r3, r3, #1
 8001ac2:	6213      	str	r3, [r2, #32]
      tickstart = HAL_GetTick();
 8001ac4:	f7ff f88c 	bl	8000be0 <HAL_GetTick>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8001ac8:	f241 3888 	movw	r8, #5000	@ 0x1388
      tickstart = HAL_GetTick();
 8001acc:	4606      	mov	r6, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8001ace:	4f33      	ldr	r7, [pc, #204]	@ (8001b9c <HAL_RCC_OscConfig+0x3d4>)
 8001ad0:	e004      	b.n	8001adc <HAL_RCC_OscConfig+0x314>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8001ad2:	f7ff f885 	bl	8000be0 <HAL_GetTick>
 8001ad6:	1b80      	subs	r0, r0, r6
 8001ad8:	4540      	cmp	r0, r8
 8001ada:	d899      	bhi.n	8001a10 <HAL_RCC_OscConfig+0x248>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8001adc:	6a3b      	ldr	r3, [r7, #32]
 8001ade:	079b      	lsls	r3, r3, #30
 8001ae0:	d5f7      	bpl.n	8001ad2 <HAL_RCC_OscConfig+0x30a>
    if (pwrclkchanged == SET)
 8001ae2:	2d00      	cmp	r5, #0
 8001ae4:	f43f af2b 	beq.w	800193e <HAL_RCC_OscConfig+0x176>
 8001ae8:	e7d0      	b.n	8001a8c <HAL_RCC_OscConfig+0x2c4>
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)
 8001aea:	2b01      	cmp	r3, #1
 8001aec:	f43f af51 	beq.w	8001992 <HAL_RCC_OscConfig+0x1ca>
        pll_config = RCC->CFGR;
 8001af0:	686b      	ldr	r3, [r5, #4]
        if ((READ_BIT(pll_config, RCC_CFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 8001af2:	6a22      	ldr	r2, [r4, #32]
 8001af4:	f403 3180 	and.w	r1, r3, #65536	@ 0x10000
 8001af8:	4291      	cmp	r1, r2
 8001afa:	f47f af4a 	bne.w	8001992 <HAL_RCC_OscConfig+0x1ca>
 8001afe:	6a60      	ldr	r0, [r4, #36]	@ 0x24
            (READ_BIT(pll_config, RCC_CFGR_PLLMULL) != RCC_OscInitStruct->PLL.PLLMUL))
 8001b00:	f403 1370 	and.w	r3, r3, #3932160	@ 0x3c0000
        if ((READ_BIT(pll_config, RCC_CFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 8001b04:	1a18      	subs	r0, r3, r0
 8001b06:	bf18      	it	ne
 8001b08:	2001      	movne	r0, #1
 8001b0a:	e734      	b.n	8001976 <HAL_RCC_OscConfig+0x1ae>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8001b0c:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
 8001b10:	f5a3 333c 	sub.w	r3, r3, #192512	@ 0x2f000
 8001b14:	681a      	ldr	r2, [r3, #0]
 8001b16:	f442 2280 	orr.w	r2, r2, #262144	@ 0x40000
 8001b1a:	601a      	str	r2, [r3, #0]
 8001b1c:	681a      	ldr	r2, [r3, #0]
 8001b1e:	f442 3280 	orr.w	r2, r2, #65536	@ 0x10000
 8001b22:	601a      	str	r2, [r3, #0]
      if (RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 8001b24:	e681      	b.n	800182a <HAL_RCC_OscConfig+0x62>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8001b26:	f042 0204 	orr.w	r2, r2, #4
 8001b2a:	621a      	str	r2, [r3, #32]
 8001b2c:	6a1a      	ldr	r2, [r3, #32]
 8001b2e:	f042 0201 	orr.w	r2, r2, #1
 8001b32:	621a      	str	r2, [r3, #32]
    if (RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 8001b34:	e7c6      	b.n	8001ac4 <HAL_RCC_OscConfig+0x2fc>
        tickstart = HAL_GetTick();
 8001b36:	f7ff f853 	bl	8000be0 <HAL_GetTick>
 8001b3a:	4606      	mov	r6, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 8001b3c:	e005      	b.n	8001b4a <HAL_RCC_OscConfig+0x382>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8001b3e:	f7ff f84f 	bl	8000be0 <HAL_GetTick>
 8001b42:	1b80      	subs	r0, r0, r6
 8001b44:	2802      	cmp	r0, #2
 8001b46:	f63f af63 	bhi.w	8001a10 <HAL_RCC_OscConfig+0x248>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 8001b4a:	682b      	ldr	r3, [r5, #0]
 8001b4c:	0199      	lsls	r1, r3, #6
 8001b4e:	d4f6      	bmi.n	8001b3e <HAL_RCC_OscConfig+0x376>
        if (RCC_OscInitStruct->PLL.PLLSource == RCC_PLLSOURCE_HSE)
 8001b50:	6a23      	ldr	r3, [r4, #32]
 8001b52:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 8001b56:	d105      	bne.n	8001b64 <HAL_RCC_OscConfig+0x39c>
          __HAL_RCC_HSE_PREDIV_CONFIG(RCC_OscInitStruct->HSEPredivValue);
 8001b58:	686a      	ldr	r2, [r5, #4]
 8001b5a:	68a1      	ldr	r1, [r4, #8]
 8001b5c:	f422 3200 	bic.w	r2, r2, #131072	@ 0x20000
 8001b60:	430a      	orrs	r2, r1
 8001b62:	606a      	str	r2, [r5, #4]
        __HAL_RCC_PLL_ENABLE();
 8001b64:	2001      	movs	r0, #1
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8001b66:	4d0d      	ldr	r5, [pc, #52]	@ (8001b9c <HAL_RCC_OscConfig+0x3d4>)
 8001b68:	6a61      	ldr	r1, [r4, #36]	@ 0x24
 8001b6a:	686a      	ldr	r2, [r5, #4]
 8001b6c:	430b      	orrs	r3, r1
 8001b6e:	f422 1274 	bic.w	r2, r2, #3997696	@ 0x3d0000
        __HAL_RCC_PLL_ENABLE();
 8001b72:	490b      	ldr	r1, [pc, #44]	@ (8001ba0 <HAL_RCC_OscConfig+0x3d8>)
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8001b74:	4313      	orrs	r3, r2
 8001b76:	606b      	str	r3, [r5, #4]
        __HAL_RCC_PLL_ENABLE();
 8001b78:	6608      	str	r0, [r1, #96]	@ 0x60
        tickstart = HAL_GetTick();
 8001b7a:	f7ff f831 	bl	8000be0 <HAL_GetTick>
 8001b7e:	4604      	mov	r4, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
 8001b80:	e005      	b.n	8001b8e <HAL_RCC_OscConfig+0x3c6>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8001b82:	f7ff f82d 	bl	8000be0 <HAL_GetTick>
 8001b86:	1b00      	subs	r0, r0, r4
 8001b88:	2802      	cmp	r0, #2
 8001b8a:	f63f af41 	bhi.w	8001a10 <HAL_RCC_OscConfig+0x248>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
 8001b8e:	682b      	ldr	r3, [r5, #0]
 8001b90:	019a      	lsls	r2, r3, #6
 8001b92:	d5f6      	bpl.n	8001b82 <HAL_RCC_OscConfig+0x3ba>
 8001b94:	e6ee      	b.n	8001974 <HAL_RCC_OscConfig+0x1ac>
    return HAL_ERROR;
 8001b96:	2001      	movs	r0, #1
}
 8001b98:	4770      	bx	lr
 8001b9a:	bf00      	nop
 8001b9c:	40021000 	.word	0x40021000
 8001ba0:	42420000 	.word	0x42420000

08001ba4 <HAL_RCC_ClockConfig>:
  if (RCC_ClkInitStruct == NULL)
 8001ba4:	2800      	cmp	r0, #0
 8001ba6:	f000 80a1 	beq.w	8001cec <HAL_RCC_ClockConfig+0x148>
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 8001baa:	4a56      	ldr	r2, [pc, #344]	@ (8001d04 <HAL_RCC_ClockConfig+0x160>)
{
 8001bac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 8001bb0:	6813      	ldr	r3, [r2, #0]
 8001bb2:	4604      	mov	r4, r0
 8001bb4:	f003 0307 	and.w	r3, r3, #7
 8001bb8:	428b      	cmp	r3, r1
 8001bba:	460d      	mov	r5, r1
 8001bbc:	d20c      	bcs.n	8001bd8 <HAL_RCC_ClockConfig+0x34>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8001bbe:	6813      	ldr	r3, [r2, #0]
 8001bc0:	f023 0307 	bic.w	r3, r3, #7
 8001bc4:	430b      	orrs	r3, r1
 8001bc6:	6013      	str	r3, [r2, #0]
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 8001bc8:	6813      	ldr	r3, [r2, #0]
 8001bca:	f003 0307 	and.w	r3, r3, #7
 8001bce:	428b      	cmp	r3, r1
 8001bd0:	d002      	beq.n	8001bd8 <HAL_RCC_ClockConfig+0x34>
    return HAL_ERROR;
 8001bd2:	2001      	movs	r0, #1
}
 8001bd4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8001bd8:	6823      	ldr	r3, [r4, #0]
 8001bda:	079e      	lsls	r6, r3, #30
 8001bdc:	d514      	bpl.n	8001c08 <HAL_RCC_ClockConfig+0x64>
    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8001bde:	0758      	lsls	r0, r3, #29
 8001be0:	d504      	bpl.n	8001bec <HAL_RCC_ClockConfig+0x48>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
 8001be2:	4949      	ldr	r1, [pc, #292]	@ (8001d08 <HAL_RCC_ClockConfig+0x164>)
 8001be4:	684a      	ldr	r2, [r1, #4]
 8001be6:	f442 62e0 	orr.w	r2, r2, #1792	@ 0x700
 8001bea:	604a      	str	r2, [r1, #4]
    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8001bec:	0719      	lsls	r1, r3, #28
 8001bee:	d504      	bpl.n	8001bfa <HAL_RCC_ClockConfig+0x56>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));
 8001bf0:	4945      	ldr	r1, [pc, #276]	@ (8001d08 <HAL_RCC_ClockConfig+0x164>)
 8001bf2:	684a      	ldr	r2, [r1, #4]
 8001bf4:	f442 5260 	orr.w	r2, r2, #14336	@ 0x3800
 8001bf8:	604a      	str	r2, [r1, #4]
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8001bfa:	4943      	ldr	r1, [pc, #268]	@ (8001d08 <HAL_RCC_ClockConfig+0x164>)
 8001bfc:	68a0      	ldr	r0, [r4, #8]
 8001bfe:	684a      	ldr	r2, [r1, #4]
 8001c00:	f022 02f0 	bic.w	r2, r2, #240	@ 0xf0
 8001c04:	4302      	orrs	r2, r0
 8001c06:	604a      	str	r2, [r1, #4]
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8001c08:	07da      	lsls	r2, r3, #31
 8001c0a:	d520      	bpl.n	8001c4e <HAL_RCC_ClockConfig+0xaa>
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8001c0c:	6862      	ldr	r2, [r4, #4]
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8001c0e:	4b3e      	ldr	r3, [pc, #248]	@ (8001d08 <HAL_RCC_ClockConfig+0x164>)
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8001c10:	2a01      	cmp	r2, #1
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8001c12:	681b      	ldr	r3, [r3, #0]
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8001c14:	d06c      	beq.n	8001cf0 <HAL_RCC_ClockConfig+0x14c>
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8001c16:	2a02      	cmp	r2, #2
 8001c18:	d065      	beq.n	8001ce6 <HAL_RCC_ClockConfig+0x142>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8001c1a:	079e      	lsls	r6, r3, #30
 8001c1c:	d5d9      	bpl.n	8001bd2 <HAL_RCC_ClockConfig+0x2e>
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8001c1e:	4e3a      	ldr	r6, [pc, #232]	@ (8001d08 <HAL_RCC_ClockConfig+0x164>)
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001c20:	f241 3888 	movw	r8, #5000	@ 0x1388
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8001c24:	6873      	ldr	r3, [r6, #4]
 8001c26:	f023 0303 	bic.w	r3, r3, #3
 8001c2a:	4313      	orrs	r3, r2
 8001c2c:	6073      	str	r3, [r6, #4]
    tickstart = HAL_GetTick();
 8001c2e:	f7fe ffd7 	bl	8000be0 <HAL_GetTick>
 8001c32:	4607      	mov	r7, r0
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8001c34:	e004      	b.n	8001c40 <HAL_RCC_ClockConfig+0x9c>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001c36:	f7fe ffd3 	bl	8000be0 <HAL_GetTick>
 8001c3a:	1bc0      	subs	r0, r0, r7
 8001c3c:	4540      	cmp	r0, r8
 8001c3e:	d85a      	bhi.n	8001cf6 <HAL_RCC_ClockConfig+0x152>
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8001c40:	6873      	ldr	r3, [r6, #4]
 8001c42:	6862      	ldr	r2, [r4, #4]
 8001c44:	f003 030c 	and.w	r3, r3, #12
 8001c48:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 8001c4c:	d1f3      	bne.n	8001c36 <HAL_RCC_ClockConfig+0x92>
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 8001c4e:	4a2d      	ldr	r2, [pc, #180]	@ (8001d04 <HAL_RCC_ClockConfig+0x160>)
 8001c50:	6813      	ldr	r3, [r2, #0]
 8001c52:	f003 0307 	and.w	r3, r3, #7
 8001c56:	42ab      	cmp	r3, r5
 8001c58:	d909      	bls.n	8001c6e <HAL_RCC_ClockConfig+0xca>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8001c5a:	6813      	ldr	r3, [r2, #0]
 8001c5c:	f023 0307 	bic.w	r3, r3, #7
 8001c60:	432b      	orrs	r3, r5
 8001c62:	6013      	str	r3, [r2, #0]
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 8001c64:	6813      	ldr	r3, [r2, #0]
 8001c66:	f003 0307 	and.w	r3, r3, #7
 8001c6a:	42ab      	cmp	r3, r5
 8001c6c:	d1b1      	bne.n	8001bd2 <HAL_RCC_ClockConfig+0x2e>
if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8001c6e:	6823      	ldr	r3, [r4, #0]
 8001c70:	0758      	lsls	r0, r3, #29
 8001c72:	d506      	bpl.n	8001c82 <HAL_RCC_ClockConfig+0xde>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 8001c74:	4924      	ldr	r1, [pc, #144]	@ (8001d08 <HAL_RCC_ClockConfig+0x164>)
 8001c76:	68e0      	ldr	r0, [r4, #12]
 8001c78:	684a      	ldr	r2, [r1, #4]
 8001c7a:	f422 62e0 	bic.w	r2, r2, #1792	@ 0x700
 8001c7e:	4302      	orrs	r2, r0
 8001c80:	604a      	str	r2, [r1, #4]
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8001c82:	0719      	lsls	r1, r3, #28
 8001c84:	d507      	bpl.n	8001c96 <HAL_RCC_ClockConfig+0xf2>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
 8001c86:	4a20      	ldr	r2, [pc, #128]	@ (8001d08 <HAL_RCC_ClockConfig+0x164>)
 8001c88:	6921      	ldr	r1, [r4, #16]
 8001c8a:	6853      	ldr	r3, [r2, #4]
 8001c8c:	f423 5360 	bic.w	r3, r3, #14336	@ 0x3800
 8001c90:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8001c94:	6053      	str	r3, [r2, #4]
  tmpreg = RCC->CFGR;
 8001c96:	491c      	ldr	r1, [pc, #112]	@ (8001d08 <HAL_RCC_ClockConfig+0x164>)
 8001c98:	684a      	ldr	r2, [r1, #4]
  switch (tmpreg & RCC_CFGR_SWS)
 8001c9a:	f002 030c 	and.w	r3, r2, #12
 8001c9e:	2b08      	cmp	r3, #8
 8001ca0:	d010      	beq.n	8001cc4 <HAL_RCC_ClockConfig+0x120>
      sysclockfreq = HSE_VALUE;
 8001ca2:	4b1a      	ldr	r3, [pc, #104]	@ (8001d0c <HAL_RCC_ClockConfig+0x168>)
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos];
 8001ca4:	4a18      	ldr	r2, [pc, #96]	@ (8001d08 <HAL_RCC_ClockConfig+0x164>)
 8001ca6:	481a      	ldr	r0, [pc, #104]	@ (8001d10 <HAL_RCC_ClockConfig+0x16c>)
 8001ca8:	6852      	ldr	r2, [r2, #4]
  HAL_InitTick(uwTickPrio);
 8001caa:	491a      	ldr	r1, [pc, #104]	@ (8001d14 <HAL_RCC_ClockConfig+0x170>)
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos];
 8001cac:	f3c2 1203 	ubfx	r2, r2, #4, #4
 8001cb0:	5c80      	ldrb	r0, [r0, r2]
 8001cb2:	4a19      	ldr	r2, [pc, #100]	@ (8001d18 <HAL_RCC_ClockConfig+0x174>)
 8001cb4:	40c3      	lsrs	r3, r0
  HAL_InitTick(uwTickPrio);
 8001cb6:	6808      	ldr	r0, [r1, #0]
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos];
 8001cb8:	6013      	str	r3, [r2, #0]
  HAL_InitTick(uwTickPrio);
 8001cba:	f7fe fee7 	bl	8000a8c <HAL_InitTick>
  return HAL_OK;
 8001cbe:	2000      	movs	r0, #0
}
 8001cc0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      pllmul = aPLLMULFactorTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMULL) >> RCC_CFGR_PLLMULL_Pos];
 8001cc4:	4815      	ldr	r0, [pc, #84]	@ (8001d1c <HAL_RCC_ClockConfig+0x178>)
 8001cc6:	f3c2 4383 	ubfx	r3, r2, #18, #4
      if ((tmpreg & RCC_CFGR_PLLSRC) != RCC_PLLSOURCE_HSI_DIV2)
 8001cca:	03d2      	lsls	r2, r2, #15
      pllmul = aPLLMULFactorTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMULL) >> RCC_CFGR_PLLMULL_Pos];
 8001ccc:	5cc3      	ldrb	r3, [r0, r3]
      if ((tmpreg & RCC_CFGR_PLLSRC) != RCC_PLLSOURCE_HSI_DIV2)
 8001cce:	d514      	bpl.n	8001cfa <HAL_RCC_ClockConfig+0x156>
        pllclk = (uint32_t)((HSE_VALUE  * pllmul) / prediv);
 8001cd0:	480e      	ldr	r0, [pc, #56]	@ (8001d0c <HAL_RCC_ClockConfig+0x168>)
        prediv = aPredivFactorTable[(uint32_t)(RCC->CFGR & RCC_CFGR_PLLXTPRE) >> RCC_CFGR_PLLXTPRE_Pos];
 8001cd2:	684a      	ldr	r2, [r1, #4]
        pllclk = (uint32_t)((HSE_VALUE  * pllmul) / prediv);
 8001cd4:	fb00 f303 	mul.w	r3, r0, r3
        prediv = aPredivFactorTable[(uint32_t)(RCC->CFGR & RCC_CFGR_PLLXTPRE) >> RCC_CFGR_PLLXTPRE_Pos];
 8001cd8:	4911      	ldr	r1, [pc, #68]	@ (8001d20 <HAL_RCC_ClockConfig+0x17c>)
 8001cda:	f3c2 4240 	ubfx	r2, r2, #17, #1
 8001cde:	5c8a      	ldrb	r2, [r1, r2]
        pllclk = (uint32_t)((HSE_VALUE  * pllmul) / prediv);
 8001ce0:	fbb3 f3f2 	udiv	r3, r3, r2
 8001ce4:	e7de      	b.n	8001ca4 <HAL_RCC_ClockConfig+0x100>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8001ce6:	019f      	lsls	r7, r3, #6
 8001ce8:	d499      	bmi.n	8001c1e <HAL_RCC_ClockConfig+0x7a>
 8001cea:	e772      	b.n	8001bd2 <HAL_RCC_ClockConfig+0x2e>
    return HAL_ERROR;
 8001cec:	2001      	movs	r0, #1
}
 8001cee:	4770      	bx	lr
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8001cf0:	039b      	lsls	r3, r3, #14
 8001cf2:	d494      	bmi.n	8001c1e <HAL_RCC_ClockConfig+0x7a>
 8001cf4:	e76d      	b.n	8001bd2 <HAL_RCC_ClockConfig+0x2e>
        return HAL_TIMEOUT;
 8001cf6:	2003      	movs	r0, #3
 8001cf8:	e76c      	b.n	8001bd4 <HAL_RCC_ClockConfig+0x30>
        pllclk = (uint32_t)((HSI_VALUE >> 1) * pllmul);
 8001cfa:	4a0a      	ldr	r2, [pc, #40]	@ (8001d24 <HAL_RCC_ClockConfig+0x180>)
 8001cfc:	fb02 f303 	mul.w	r3, r2, r3
 8001d00:	e7d0      	b.n	8001ca4 <HAL_RCC_ClockConfig+0x100>
 8001d02:	bf00      	nop
 8001d04:	40022000 	.word	0x40022000
 8001d08:	40021000 	.word	0x40021000
 8001d0c:	007a1200 	.word	0x007a1200
 8001d10:	08006f30 	.word	0x08006f30
 8001d14:	20000024 	.word	0x20000024
 8001d18:	2000001c 	.word	0x2000001c
 8001d1c:	08006f44 	.word	0x08006f44
 8001d20:	08006f40 	.word	0x08006f40
 8001d24:	003d0900 	.word	0x003d0900

08001d28 <HAL_RCC_GetPCLK1Freq>:
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos]);
 8001d28:	4b04      	ldr	r3, [pc, #16]	@ (8001d3c <HAL_RCC_GetPCLK1Freq+0x14>)
  return SystemCoreClock;
 8001d2a:	4a05      	ldr	r2, [pc, #20]	@ (8001d40 <HAL_RCC_GetPCLK1Freq+0x18>)
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos]);
 8001d2c:	685b      	ldr	r3, [r3, #4]
 8001d2e:	4905      	ldr	r1, [pc, #20]	@ (8001d44 <HAL_RCC_GetPCLK1Freq+0x1c>)
 8001d30:	f3c3 2302 	ubfx	r3, r3, #8, #3
 8001d34:	5ccb      	ldrb	r3, [r1, r3]
 8001d36:	6810      	ldr	r0, [r2, #0]
}
 8001d38:	40d8      	lsrs	r0, r3
 8001d3a:	4770      	bx	lr
 8001d3c:	40021000 	.word	0x40021000
 8001d40:	2000001c 	.word	0x2000001c
 8001d44:	08006f28 	.word	0x08006f28

08001d48 <HAL_RCC_GetPCLK2Freq>:
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos]);
 8001d48:	4b04      	ldr	r3, [pc, #16]	@ (8001d5c <HAL_RCC_GetPCLK2Freq+0x14>)
  return SystemCoreClock;
 8001d4a:	4a05      	ldr	r2, [pc, #20]	@ (8001d60 <HAL_RCC_GetPCLK2Freq+0x18>)
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos]);
 8001d4c:	685b      	ldr	r3, [r3, #4]
 8001d4e:	4905      	ldr	r1, [pc, #20]	@ (8001d64 <HAL_RCC_GetPCLK2Freq+0x1c>)
 8001d50:	f3c3 23c2 	ubfx	r3, r3, #11, #3
 8001d54:	5ccb      	ldrb	r3, [r1, r3]
 8001d56:	6810      	ldr	r0, [r2, #0]
}
 8001d58:	40d8      	lsrs	r0, r3
 8001d5a:	4770      	bx	lr
 8001d5c:	40021000 	.word	0x40021000
 8001d60:	2000001c 	.word	0x2000001c
 8001d64:	08006f28 	.word	0x08006f28

08001d68 <HAL_RCC_GetClockConfig>:
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
 8001d68:	220f      	movs	r2, #15
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
 8001d6a:	4b0d      	ldr	r3, [pc, #52]	@ (8001da0 <HAL_RCC_GetClockConfig+0x38>)
{
 8001d6c:	b410      	push	{r4}
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
 8001d6e:	6002      	str	r2, [r0, #0]
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
 8001d70:	685a      	ldr	r2, [r3, #4]
  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
 8001d72:	4c0c      	ldr	r4, [pc, #48]	@ (8001da4 <HAL_RCC_GetClockConfig+0x3c>)
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
 8001d74:	f002 0203 	and.w	r2, r2, #3
 8001d78:	6042      	str	r2, [r0, #4]
  RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_HPRE);
 8001d7a:	685a      	ldr	r2, [r3, #4]
 8001d7c:	f002 02f0 	and.w	r2, r2, #240	@ 0xf0
 8001d80:	6082      	str	r2, [r0, #8]
  RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_PPRE1);
 8001d82:	685a      	ldr	r2, [r3, #4]
 8001d84:	f402 62e0 	and.w	r2, r2, #1792	@ 0x700
 8001d88:	60c2      	str	r2, [r0, #12]
  RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)((RCC->CFGR & RCC_CFGR_PPRE2) >> 3);
 8001d8a:	685b      	ldr	r3, [r3, #4]
 8001d8c:	08db      	lsrs	r3, r3, #3
 8001d8e:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
 8001d92:	6103      	str	r3, [r0, #16]
  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
 8001d94:	6823      	ldr	r3, [r4, #0]
}
 8001d96:	bc10      	pop	{r4}
  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
 8001d98:	f003 0307 	and.w	r3, r3, #7
 8001d9c:	600b      	str	r3, [r1, #0]
}
 8001d9e:	4770      	bx	lr
 8001da0:	40021000 	.word	0x40021000
 8001da4:	40022000 	.word	0x40022000

08001da8 <HAL_TIM_Base_MspInit>:
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_Base_MspInit could be implemented in the user file
   */
}
 8001da8:	4770      	bx	lr
 8001daa:	bf00      	nop

08001dac <HAL_TIM_Base_Init>:
  if (htim == NULL)
 8001dac:	2800      	cmp	r0, #0
 8001dae:	d058      	beq.n	8001e62 <HAL_TIM_Base_Init+0xb6>
{
 8001db0:	b570      	push	{r4, r5, r6, lr}
  if (htim->State == HAL_TIM_STATE_RESET)
 8001db2:	f890 303d 	ldrb.w	r3, [r0, #61]	@ 0x3d
 8001db6:	4604      	mov	r4, r0
 8001db8:	f003 02ff 	and.w	r2, r3, #255	@ 0xff
 8001dbc:	2b00      	cmp	r3, #0
 8001dbe:	d04b      	beq.n	8001e58 <HAL_TIM_Base_Init+0xac>
  htim->State = HAL_TIM_STATE_BUSY;
 8001dc0:	2302      	movs	r3, #2
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 8001dc2:	6822      	ldr	r2, [r4, #0]
{
  uint32_t tmpcr1;
  tmpcr1 = TIMx->CR1;

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8001dc4:	4e2c      	ldr	r6, [pc, #176]	@ (8001e78 <HAL_TIM_Base_Init+0xcc>)
  htim->State = HAL_TIM_STATE_BUSY;
 8001dc6:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8001dca:	42b2      	cmp	r2, r6
    tmpcr1 &= ~TIM_CR1_CKD;
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
  }

  /* Set the auto-reload preload */
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8001dcc:	69a5      	ldr	r5, [r4, #24]

  TIMx->CR1 = tmpcr1;

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 8001dce:	68e0      	ldr	r0, [r4, #12]

  /* Set the Prescaler value */
  TIMx->PSC = Structure->Prescaler;
 8001dd0:	6861      	ldr	r1, [r4, #4]
  tmpcr1 = TIMx->CR1;
 8001dd2:	6813      	ldr	r3, [r2, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8001dd4:	d02c      	beq.n	8001e30 <HAL_TIM_Base_Init+0x84>
 8001dd6:	f1b2 4f80 	cmp.w	r2, #1073741824	@ 0x40000000
 8001dda:	d029      	beq.n	8001e30 <HAL_TIM_Base_Init+0x84>
 8001ddc:	f5a6 3694 	sub.w	r6, r6, #75776	@ 0x12800
 8001de0:	42b2      	cmp	r2, r6
 8001de2:	d040      	beq.n	8001e66 <HAL_TIM_Base_Init+0xba>
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8001de4:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 8001de8:	432b      	orrs	r3, r5
  TIMx->CR1 = tmpcr1;
 8001dea:	6013      	str	r3, [r2, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 8001dec:	62d0      	str	r0, [r2, #44]	@ 0x2c
  TIMx->PSC = Structure->Prescaler;
 8001dee:	6291      	str	r1, [r2, #40]	@ 0x28
    TIMx->RCR = Structure->RepetitionCounter;
  }

  /* Generate an update event to reload the Prescaler
     and the repetition counter (only for advanced timer) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 8001df0:	2301      	movs	r3, #1
 8001df2:	6153      	str	r3, [r2, #20]

  /* Check if the update flag is set after the Update Generation, if so clear the UIF flag */
  if (HAL_IS_BIT_SET(TIMx->SR, TIM_FLAG_UPDATE))
 8001df4:	6913      	ldr	r3, [r2, #16]
 8001df6:	07db      	lsls	r3, r3, #31
 8001df8:	d503      	bpl.n	8001e02 <HAL_TIM_Base_Init+0x56>
  {
    /* Clear the update flag */
    CLEAR_BIT(TIMx->SR, TIM_FLAG_UPDATE);
 8001dfa:	6913      	ldr	r3, [r2, #16]
 8001dfc:	f023 0301 	bic.w	r3, r3, #1
 8001e00:	6113      	str	r3, [r2, #16]
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 8001e02:	2301      	movs	r3, #1
 8001e04:	f884 3046 	strb.w	r3, [r4, #70]	@ 0x46
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8001e08:	f884 303e 	strb.w	r3, [r4, #62]	@ 0x3e
 8001e0c:	f884 303f 	strb.w	r3, [r4, #63]	@ 0x3f
 8001e10:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
 8001e14:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8001e18:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
 8001e1c:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
 8001e20:	f884 3044 	strb.w	r3, [r4, #68]	@ 0x44
 8001e24:	f884 3045 	strb.w	r3, [r4, #69]	@ 0x45
  htim->State = HAL_TIM_STATE_READY;
 8001e28:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
  return HAL_OK;
 8001e2c:	2000      	movs	r0, #0
}
 8001e2e:	bd70      	pop	{r4, r5, r6, pc}
    tmpcr1 |= Structure->CounterMode;
 8001e30:	68a6      	ldr	r6, [r4, #8]
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8001e32:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
    tmpcr1 |= Structure->CounterMode;
 8001e36:	4333      	orrs	r3, r6
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8001e38:	6926      	ldr	r6, [r4, #16]
    tmpcr1 &= ~TIM_CR1_CKD;
 8001e3a:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8001e3e:	4333      	orrs	r3, r6
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8001e40:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 8001e44:	432b      	orrs	r3, r5
  TIMx->CR1 = tmpcr1;
 8001e46:	6013      	str	r3, [r2, #0]
  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 8001e48:	4b0b      	ldr	r3, [pc, #44]	@ (8001e78 <HAL_TIM_Base_Init+0xcc>)
  TIMx->ARR = (uint32_t)Structure->Period ;
 8001e4a:	62d0      	str	r0, [r2, #44]	@ 0x2c
  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 8001e4c:	429a      	cmp	r2, r3
  TIMx->PSC = Structure->Prescaler;
 8001e4e:	6291      	str	r1, [r2, #40]	@ 0x28
  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 8001e50:	d1ce      	bne.n	8001df0 <HAL_TIM_Base_Init+0x44>
    TIMx->RCR = Structure->RepetitionCounter;
 8001e52:	6963      	ldr	r3, [r4, #20]
 8001e54:	6313      	str	r3, [r2, #48]	@ 0x30
 8001e56:	e7cb      	b.n	8001df0 <HAL_TIM_Base_Init+0x44>
    htim->Lock = HAL_UNLOCKED;
 8001e58:	f880 203c 	strb.w	r2, [r0, #60]	@ 0x3c
    HAL_TIM_Base_MspInit(htim);
 8001e5c:	f7ff ffa4 	bl	8001da8 <HAL_TIM_Base_MspInit>
 8001e60:	e7ae      	b.n	8001dc0 <HAL_TIM_Base_Init+0x14>
    return HAL_ERROR;
 8001e62:	2001      	movs	r0, #1
}
 8001e64:	4770      	bx	lr
    tmpcr1 |= Structure->CounterMode;
 8001e66:	68a6      	ldr	r6, [r4, #8]
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8001e68:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
    tmpcr1 |= Structure->CounterMode;
 8001e6c:	4333      	orrs	r3, r6
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8001e6e:	6926      	ldr	r6, [r4, #16]
    tmpcr1 &= ~TIM_CR1_CKD;
 8001e70:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8001e74:	4333      	orrs	r3, r6
 8001e76:	e7b5      	b.n	8001de4 <HAL_TIM_Base_Init+0x38>
 8001e78:	40012c00 	.word	0x40012c00

08001e7c <HAL_TIM_Base_Start_IT>:
  if (htim->State != HAL_TIM_STATE_READY)
 8001e7c:	f890 303d 	ldrb.w	r3, [r0, #61]	@ 0x3d
 8001e80:	2b01      	cmp	r3, #1
 8001e82:	d116      	bne.n	8001eb2 <HAL_TIM_Base_Start_IT+0x36>
  htim->State = HAL_TIM_STATE_BUSY;
 8001e84:	2202      	movs	r2, #2
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 8001e86:	6803      	ldr	r3, [r0, #0]
  htim->State = HAL_TIM_STATE_BUSY;
 8001e88:	f880 203d 	strb.w	r2, [r0, #61]	@ 0x3d
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 8001e8c:	68da      	ldr	r2, [r3, #12]
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8001e8e:	490d      	ldr	r1, [pc, #52]	@ (8001ec4 <HAL_TIM_Base_Start_IT+0x48>)
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 8001e90:	f042 0201 	orr.w	r2, r2, #1
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8001e94:	428b      	cmp	r3, r1
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 8001e96:	60da      	str	r2, [r3, #12]
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8001e98:	d00d      	beq.n	8001eb6 <HAL_TIM_Base_Start_IT+0x3a>
 8001e9a:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 8001e9e:	d00a      	beq.n	8001eb6 <HAL_TIM_Base_Start_IT+0x3a>
 8001ea0:	4a09      	ldr	r2, [pc, #36]	@ (8001ec8 <HAL_TIM_Base_Start_IT+0x4c>)
 8001ea2:	4293      	cmp	r3, r2
 8001ea4:	d007      	beq.n	8001eb6 <HAL_TIM_Base_Start_IT+0x3a>
      __HAL_TIM_ENABLE(htim);
 8001ea6:	681a      	ldr	r2, [r3, #0]
  return HAL_OK;
 8001ea8:	2000      	movs	r0, #0
      __HAL_TIM_ENABLE(htim);
 8001eaa:	f042 0201 	orr.w	r2, r2, #1
 8001eae:	601a      	str	r2, [r3, #0]
 8001eb0:	4770      	bx	lr
    return HAL_ERROR;
 8001eb2:	2001      	movs	r0, #1
}
 8001eb4:	4770      	bx	lr
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 8001eb6:	689a      	ldr	r2, [r3, #8]
 8001eb8:	f002 0207 	and.w	r2, r2, #7
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8001ebc:	2a06      	cmp	r2, #6
 8001ebe:	d1f2      	bne.n	8001ea6 <HAL_TIM_Base_Start_IT+0x2a>
  return HAL_OK;
 8001ec0:	2000      	movs	r0, #0
 8001ec2:	4770      	bx	lr
 8001ec4:	40012c00 	.word	0x40012c00
 8001ec8:	40000400 	.word	0x40000400

08001ecc <HAL_TIM_OC_DelayElapsedCallback>:
__weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
 8001ecc:	4770      	bx	lr
 8001ece:	bf00      	nop

08001ed0 <HAL_TIM_IC_CaptureCallback>:
__weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
 8001ed0:	4770      	bx	lr
 8001ed2:	bf00      	nop

08001ed4 <HAL_TIM_PWM_PulseFinishedCallback>:
__weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
 8001ed4:	4770      	bx	lr
 8001ed6:	bf00      	nop

08001ed8 <HAL_TIM_TriggerCallback>:
__weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
 8001ed8:	4770      	bx	lr
 8001eda:	bf00      	nop

08001edc <HAL_TIM_IRQHandler>:
  uint32_t itsource = htim->Instance->DIER;
 8001edc:	6803      	ldr	r3, [r0, #0]
{
 8001ede:	b570      	push	{r4, r5, r6, lr}
  uint32_t itsource = htim->Instance->DIER;
 8001ee0:	68de      	ldr	r6, [r3, #12]
  uint32_t itflag   = htim->Instance->SR;
 8001ee2:	691d      	ldr	r5, [r3, #16]
{
 8001ee4:	4604      	mov	r4, r0
  if ((itflag & (TIM_FLAG_CC1)) == (TIM_FLAG_CC1))
 8001ee6:	07a9      	lsls	r1, r5, #30
 8001ee8:	d501      	bpl.n	8001eee <HAL_TIM_IRQHandler+0x12>
    if ((itsource & (TIM_IT_CC1)) == (TIM_IT_CC1))
 8001eea:	07b2      	lsls	r2, r6, #30
 8001eec:	d451      	bmi.n	8001f92 <HAL_TIM_IRQHandler+0xb6>
  if ((itflag & (TIM_FLAG_CC2)) == (TIM_FLAG_CC2))
 8001eee:	0769      	lsls	r1, r5, #29
 8001ef0:	d501      	bpl.n	8001ef6 <HAL_TIM_IRQHandler+0x1a>
    if ((itsource & (TIM_IT_CC2)) == (TIM_IT_CC2))
 8001ef2:	0772      	lsls	r2, r6, #29
 8001ef4:	d43a      	bmi.n	8001f6c <HAL_TIM_IRQHandler+0x90>
  if ((itflag & (TIM_FLAG_CC3)) == (TIM_FLAG_CC3))
 8001ef6:	072b      	lsls	r3, r5, #28
 8001ef8:	d501      	bpl.n	8001efe <HAL_TIM_IRQHandler+0x22>
    if ((itsource & (TIM_IT_CC3)) == (TIM_IT_CC3))
 8001efa:	0730      	lsls	r0, r6, #28
 8001efc:	d424      	bmi.n	8001f48 <HAL_TIM_IRQHandler+0x6c>
  if ((itflag & (TIM_FLAG_CC4)) == (TIM_FLAG_CC4))
 8001efe:	06ea      	lsls	r2, r5, #27
 8001f00:	d501      	bpl.n	8001f06 <HAL_TIM_IRQHandler+0x2a>
    if ((itsource & (TIM_IT_CC4)) == (TIM_IT_CC4))
 8001f02:	06f3      	lsls	r3, r6, #27
 8001f04:	d410      	bmi.n	8001f28 <HAL_TIM_IRQHandler+0x4c>
  if ((itflag & (TIM_FLAG_UPDATE)) == (TIM_FLAG_UPDATE))
 8001f06:	07e8      	lsls	r0, r5, #31
 8001f08:	d501      	bpl.n	8001f0e <HAL_TIM_IRQHandler+0x32>
    if ((itsource & (TIM_IT_UPDATE)) == (TIM_IT_UPDATE))
 8001f0a:	07f1      	lsls	r1, r6, #31
 8001f0c:	d457      	bmi.n	8001fbe <HAL_TIM_IRQHandler+0xe2>
  if ((itflag & (TIM_FLAG_BREAK)) == (TIM_FLAG_BREAK))
 8001f0e:	062a      	lsls	r2, r5, #24
 8001f10:	d501      	bpl.n	8001f16 <HAL_TIM_IRQHandler+0x3a>
    if ((itsource & (TIM_IT_BREAK)) == (TIM_IT_BREAK))
 8001f12:	0633      	lsls	r3, r6, #24
 8001f14:	d45b      	bmi.n	8001fce <HAL_TIM_IRQHandler+0xf2>
  if ((itflag & (TIM_FLAG_TRIGGER)) == (TIM_FLAG_TRIGGER))
 8001f16:	0668      	lsls	r0, r5, #25
 8001f18:	d501      	bpl.n	8001f1e <HAL_TIM_IRQHandler+0x42>
    if ((itsource & (TIM_IT_TRIGGER)) == (TIM_IT_TRIGGER))
 8001f1a:	0671      	lsls	r1, r6, #25
 8001f1c:	d45f      	bmi.n	8001fde <HAL_TIM_IRQHandler+0x102>
  if ((itflag & (TIM_FLAG_COM)) == (TIM_FLAG_COM))
 8001f1e:	06aa      	lsls	r2, r5, #26
 8001f20:	d501      	bpl.n	8001f26 <HAL_TIM_IRQHandler+0x4a>
    if ((itsource & (TIM_IT_COM)) == (TIM_IT_COM))
 8001f22:	06b3      	lsls	r3, r6, #26
 8001f24:	d442      	bmi.n	8001fac <HAL_TIM_IRQHandler+0xd0>
}
 8001f26:	bd70      	pop	{r4, r5, r6, pc}
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC4);
 8001f28:	f06f 0110 	mvn.w	r1, #16
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 8001f2c:	2208      	movs	r2, #8
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC4);
 8001f2e:	6823      	ldr	r3, [r4, #0]
        HAL_TIM_IC_CaptureCallback(htim);
 8001f30:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC4);
 8001f32:	6119      	str	r1, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 8001f34:	7722      	strb	r2, [r4, #28]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 8001f36:	69db      	ldr	r3, [r3, #28]
 8001f38:	f413 7f40 	tst.w	r3, #768	@ 0x300
 8001f3c:	d063      	beq.n	8002006 <HAL_TIM_IRQHandler+0x12a>
        HAL_TIM_IC_CaptureCallback(htim);
 8001f3e:	f7ff ffc7 	bl	8001ed0 <HAL_TIM_IC_CaptureCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8001f42:	2300      	movs	r3, #0
 8001f44:	7723      	strb	r3, [r4, #28]
 8001f46:	e7de      	b.n	8001f06 <HAL_TIM_IRQHandler+0x2a>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC3);
 8001f48:	f06f 0108 	mvn.w	r1, #8
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 8001f4c:	2204      	movs	r2, #4
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC3);
 8001f4e:	6823      	ldr	r3, [r4, #0]
        HAL_TIM_IC_CaptureCallback(htim);
 8001f50:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC3);
 8001f52:	6119      	str	r1, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 8001f54:	7722      	strb	r2, [r4, #28]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 8001f56:	69db      	ldr	r3, [r3, #28]
 8001f58:	0799      	lsls	r1, r3, #30
 8001f5a:	d151      	bne.n	8002000 <HAL_TIM_IRQHandler+0x124>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8001f5c:	f7ff ffb6 	bl	8001ecc <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8001f60:	4620      	mov	r0, r4
 8001f62:	f7ff ffb7 	bl	8001ed4 <HAL_TIM_PWM_PulseFinishedCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8001f66:	2300      	movs	r3, #0
 8001f68:	7723      	strb	r3, [r4, #28]
 8001f6a:	e7c8      	b.n	8001efe <HAL_TIM_IRQHandler+0x22>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC2);
 8001f6c:	f06f 0104 	mvn.w	r1, #4
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 8001f70:	2202      	movs	r2, #2
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC2);
 8001f72:	6823      	ldr	r3, [r4, #0]
        HAL_TIM_IC_CaptureCallback(htim);
 8001f74:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC2);
 8001f76:	6119      	str	r1, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 8001f78:	7722      	strb	r2, [r4, #28]
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 8001f7a:	699b      	ldr	r3, [r3, #24]
 8001f7c:	f413 7f40 	tst.w	r3, #768	@ 0x300
 8001f80:	d13b      	bne.n	8001ffa <HAL_TIM_IRQHandler+0x11e>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8001f82:	f7ff ffa3 	bl	8001ecc <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8001f86:	4620      	mov	r0, r4
 8001f88:	f7ff ffa4 	bl	8001ed4 <HAL_TIM_PWM_PulseFinishedCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8001f8c:	2300      	movs	r3, #0
 8001f8e:	7723      	strb	r3, [r4, #28]
 8001f90:	e7b1      	b.n	8001ef6 <HAL_TIM_IRQHandler+0x1a>
        __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC1);
 8001f92:	f06f 0202 	mvn.w	r2, #2
 8001f96:	611a      	str	r2, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 8001f98:	2201      	movs	r2, #1
 8001f9a:	7702      	strb	r2, [r0, #28]
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 8001f9c:	699b      	ldr	r3, [r3, #24]
 8001f9e:	079b      	lsls	r3, r3, #30
 8001fa0:	d025      	beq.n	8001fee <HAL_TIM_IRQHandler+0x112>
          HAL_TIM_IC_CaptureCallback(htim);
 8001fa2:	f7ff ff95 	bl	8001ed0 <HAL_TIM_IC_CaptureCallback>
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8001fa6:	2300      	movs	r3, #0
 8001fa8:	7723      	strb	r3, [r4, #28]
 8001faa:	e7a0      	b.n	8001eee <HAL_TIM_IRQHandler+0x12>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_COM);
 8001fac:	f06f 0220 	mvn.w	r2, #32
 8001fb0:	6823      	ldr	r3, [r4, #0]
      HAL_TIMEx_CommutCallback(htim);
 8001fb2:	4620      	mov	r0, r4
}
 8001fb4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_COM);
 8001fb8:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_CommutCallback(htim);
 8001fba:	f000 b82b 	b.w	8002014 <HAL_TIMEx_CommutCallback>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_UPDATE);
 8001fbe:	f06f 0201 	mvn.w	r2, #1
 8001fc2:	6823      	ldr	r3, [r4, #0]
      HAL_TIM_PeriodElapsedCallback(htim);
 8001fc4:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_UPDATE);
 8001fc6:	611a      	str	r2, [r3, #16]
      HAL_TIM_PeriodElapsedCallback(htim);
 8001fc8:	f7fe fcae 	bl	8000928 <HAL_TIM_PeriodElapsedCallback>
 8001fcc:	e79f      	b.n	8001f0e <HAL_TIM_IRQHandler+0x32>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK);
 8001fce:	f06f 0280 	mvn.w	r2, #128	@ 0x80
 8001fd2:	6823      	ldr	r3, [r4, #0]
      HAL_TIMEx_BreakCallback(htim);
 8001fd4:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK);
 8001fd6:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_BreakCallback(htim);
 8001fd8:	f000 f81e 	bl	8002018 <HAL_TIMEx_BreakCallback>
 8001fdc:	e79b      	b.n	8001f16 <HAL_TIM_IRQHandler+0x3a>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_TRIGGER);
 8001fde:	f06f 0240 	mvn.w	r2, #64	@ 0x40
 8001fe2:	6823      	ldr	r3, [r4, #0]
      HAL_TIM_TriggerCallback(htim);
 8001fe4:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_TRIGGER);
 8001fe6:	611a      	str	r2, [r3, #16]
      HAL_TIM_TriggerCallback(htim);
 8001fe8:	f7ff ff76 	bl	8001ed8 <HAL_TIM_TriggerCallback>
 8001fec:	e797      	b.n	8001f1e <HAL_TIM_IRQHandler+0x42>
          HAL_TIM_OC_DelayElapsedCallback(htim);
 8001fee:	f7ff ff6d 	bl	8001ecc <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 8001ff2:	4620      	mov	r0, r4
 8001ff4:	f7ff ff6e 	bl	8001ed4 <HAL_TIM_PWM_PulseFinishedCallback>
 8001ff8:	e7d5      	b.n	8001fa6 <HAL_TIM_IRQHandler+0xca>
        HAL_TIM_IC_CaptureCallback(htim);
 8001ffa:	f7ff ff69 	bl	8001ed0 <HAL_TIM_IC_CaptureCallback>
 8001ffe:	e7c5      	b.n	8001f8c <HAL_TIM_IRQHandler+0xb0>
        HAL_TIM_IC_CaptureCallback(htim);
 8002000:	f7ff ff66 	bl	8001ed0 <HAL_TIM_IC_CaptureCallback>
 8002004:	e7af      	b.n	8001f66 <HAL_TIM_IRQHandler+0x8a>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8002006:	f7ff ff61 	bl	8001ecc <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 800200a:	4620      	mov	r0, r4
 800200c:	f7ff ff62 	bl	8001ed4 <HAL_TIM_PWM_PulseFinishedCallback>
 8002010:	e797      	b.n	8001f42 <HAL_TIM_IRQHandler+0x66>
 8002012:	bf00      	nop

08002014 <HAL_TIMEx_CommutCallback>:
/**
  * @brief  Commutation callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_CommutCallback(TIM_HandleTypeDef *htim)
 8002014:	4770      	bx	lr
 8002016:	bf00      	nop

08002018 <HAL_TIMEx_BreakCallback>:
/**
  * @brief  Break detection callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_BreakCallback(TIM_HandleTypeDef *htim)
 8002018:	4770      	bx	lr
 800201a:	bf00      	nop

0800201c <HAL_UART_Init>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
  /* Check the UART handle allocation */
  if (huart == NULL)
 800201c:	2800      	cmp	r0, #0
 800201e:	d065      	beq.n	80020ec <HAL_UART_Init+0xd0>
{
 8002020:	b570      	push	{r4, r5, r6, lr}
  assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
#if defined(USART_CR1_OVER8)
  assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
#endif /* USART_CR1_OVER8 */

  if (huart->gState == HAL_UART_STATE_RESET)
 8002022:	f890 3041 	ldrb.w	r3, [r0, #65]	@ 0x41
 8002026:	4604      	mov	r4, r0
 8002028:	f003 02ff 	and.w	r2, r3, #255	@ 0xff
 800202c:	2b00      	cmp	r3, #0
 800202e:	d055      	beq.n	80020dc <HAL_UART_Init+0xc0>
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
  MODIFY_REG(huart->Instance->CR1,
             (uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | USART_CR1_RE | USART_CR1_OVER8),
             tmpreg);
#else
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode;
 8002030:	e9d4 2602 	ldrd	r2, r6, [r4, #8]
  huart->gState = HAL_UART_STATE_BUSY;
 8002034:	2124      	movs	r1, #36	@ 0x24
  __HAL_UART_DISABLE(huart);
 8002036:	6823      	ldr	r3, [r4, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 8002038:	f884 1041 	strb.w	r1, [r4, #65]	@ 0x41
  __HAL_UART_DISABLE(huart);
 800203c:	68d9      	ldr	r1, [r3, #12]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode;
 800203e:	6920      	ldr	r0, [r4, #16]
  __HAL_UART_DISABLE(huart);
 8002040:	f421 5100 	bic.w	r1, r1, #8192	@ 0x2000
             tmpreg);
#endif /* USART_CR1_OVER8 */

  /*-------------------------- USART CR3 Configuration -----------------------*/
  /* Configure the UART HFC: Set CTSE and RTSE bits according to huart->Init.HwFlowCtl value */
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE), huart->Init.HwFlowCtl);
 8002044:	69a5      	ldr	r5, [r4, #24]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode;
 8002046:	4302      	orrs	r2, r0
 8002048:	6960      	ldr	r0, [r4, #20]
  __HAL_UART_DISABLE(huart);
 800204a:	60d9      	str	r1, [r3, #12]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 800204c:	6919      	ldr	r1, [r3, #16]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode;
 800204e:	4302      	orrs	r2, r0
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 8002050:	f421 5140 	bic.w	r1, r1, #12288	@ 0x3000
 8002054:	4331      	orrs	r1, r6
 8002056:	6119      	str	r1, [r3, #16]
  MODIFY_REG(huart->Instance->CR1,
 8002058:	68d9      	ldr	r1, [r3, #12]


  if(huart->Instance == USART1)
 800205a:	4825      	ldr	r0, [pc, #148]	@ (80020f0 <HAL_UART_Init+0xd4>)
  MODIFY_REG(huart->Instance->CR1,
 800205c:	f421 51b0 	bic.w	r1, r1, #5632	@ 0x1600
 8002060:	f021 010c 	bic.w	r1, r1, #12
 8002064:	430a      	orrs	r2, r1
 8002066:	60da      	str	r2, [r3, #12]
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE), huart->Init.HwFlowCtl);
 8002068:	695a      	ldr	r2, [r3, #20]
  if(huart->Instance == USART1)
 800206a:	4283      	cmp	r3, r0
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE), huart->Init.HwFlowCtl);
 800206c:	f422 7240 	bic.w	r2, r2, #768	@ 0x300
 8002070:	ea42 0205 	orr.w	r2, r2, r5
 8002074:	615a      	str	r2, [r3, #20]
  if(huart->Instance == USART1)
 8002076:	d036      	beq.n	80020e6 <HAL_UART_Init+0xca>
  {
    pclk = HAL_RCC_GetPCLK2Freq();
  }
  else
  {
    pclk = HAL_RCC_GetPCLK1Freq();
 8002078:	f7ff fe56 	bl	8001d28 <HAL_RCC_GetPCLK1Freq>
  else
  {
    huart->Instance->BRR = UART_BRR_SAMPLING16(pclk, huart->Init.BaudRate);
  }
#else
  huart->Instance->BRR = UART_BRR_SAMPLING16(pclk, huart->Init.BaudRate);
 800207c:	6862      	ldr	r2, [r4, #4]
 800207e:	eb00 0380 	add.w	r3, r0, r0, lsl #2
 8002082:	0092      	lsls	r2, r2, #2
 8002084:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8002088:	fbb3 f3f2 	udiv	r3, r3, r2
 800208c:	f04f 0e64 	mov.w	lr, #100	@ 0x64
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8002090:	2500      	movs	r5, #0
  huart->gState = HAL_UART_STATE_READY;
 8002092:	f04f 0c20 	mov.w	ip, #32
  huart->Instance->BRR = UART_BRR_SAMPLING16(pclk, huart->Init.BaudRate);
 8002096:	4817      	ldr	r0, [pc, #92]	@ (80020f4 <HAL_UART_Init+0xd8>)
 8002098:	6821      	ldr	r1, [r4, #0]
 800209a:	fba0 6203 	umull	r6, r2, r0, r3
 800209e:	0952      	lsrs	r2, r2, #5
 80020a0:	fb0e 3312 	mls	r3, lr, r2, r3
 80020a4:	011b      	lsls	r3, r3, #4
 80020a6:	3332      	adds	r3, #50	@ 0x32
 80020a8:	fba0 0303 	umull	r0, r3, r0, r3
 80020ac:	0112      	lsls	r2, r2, #4
 80020ae:	eb02 1253 	add.w	r2, r2, r3, lsr #5
 80020b2:	608a      	str	r2, [r1, #8]
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 80020b4:	690b      	ldr	r3, [r1, #16]
  return HAL_OK;
 80020b6:	4628      	mov	r0, r5
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 80020b8:	f423 4390 	bic.w	r3, r3, #18432	@ 0x4800
 80020bc:	610b      	str	r3, [r1, #16]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 80020be:	694b      	ldr	r3, [r1, #20]
 80020c0:	f023 032a 	bic.w	r3, r3, #42	@ 0x2a
 80020c4:	614b      	str	r3, [r1, #20]
  __HAL_UART_ENABLE(huart);
 80020c6:	68cb      	ldr	r3, [r1, #12]
 80020c8:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
 80020cc:	60cb      	str	r3, [r1, #12]
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 80020ce:	6465      	str	r5, [r4, #68]	@ 0x44
  huart->gState = HAL_UART_STATE_READY;
 80020d0:	f884 c041 	strb.w	ip, [r4, #65]	@ 0x41
  huart->RxState = HAL_UART_STATE_READY;
 80020d4:	f884 c042 	strb.w	ip, [r4, #66]	@ 0x42
  huart->RxEventType = HAL_UART_RXEVENT_TC;
 80020d8:	6365      	str	r5, [r4, #52]	@ 0x34
}
 80020da:	bd70      	pop	{r4, r5, r6, pc}
    huart->Lock = HAL_UNLOCKED;
 80020dc:	f880 2040 	strb.w	r2, [r0, #64]	@ 0x40
    HAL_UART_MspInit(huart);
 80020e0:	f7fe fc98 	bl	8000a14 <HAL_UART_MspInit>
 80020e4:	e7a4      	b.n	8002030 <HAL_UART_Init+0x14>
    pclk = HAL_RCC_GetPCLK2Freq();
 80020e6:	f7ff fe2f 	bl	8001d48 <HAL_RCC_GetPCLK2Freq>
 80020ea:	e7c7      	b.n	800207c <HAL_UART_Init+0x60>
    return HAL_ERROR;
 80020ec:	2001      	movs	r0, #1
}
 80020ee:	4770      	bx	lr
 80020f0:	40013800 	.word	0x40013800
 80020f4:	51eb851f 	.word	0x51eb851f

080020f8 <vListInitialise>:
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 80020f8:	f04f 31ff 	mov.w	r1, #4294967295
	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 80020fc:	2200      	movs	r2, #0
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 80020fe:	f100 0308 	add.w	r3, r0, #8
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8002102:	e9c0 3101 	strd	r3, r1, [r0, #4]
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8002106:	e9c0 3303 	strd	r3, r3, [r0, #12]
	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 800210a:	6002      	str	r2, [r0, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
 800210c:	4770      	bx	lr
 800210e:	bf00      	nop

08002110 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
 8002110:	2300      	movs	r3, #0
 8002112:	6103      	str	r3, [r0, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
 8002114:	4770      	bx	lr
 8002116:	bf00      	nop

08002118 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t * const pxIndex = pxList->pxIndex;
 8002118:	6842      	ldr	r2, [r0, #4]
	pxIndex->pxPrevious = pxNewListItem;

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;

	( pxList->uxNumberOfItems )++;
 800211a:	6803      	ldr	r3, [r0, #0]
{
 800211c:	b410      	push	{r4}
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 800211e:	6894      	ldr	r4, [r2, #8]
	( pxList->uxNumberOfItems )++;
 8002120:	3301      	adds	r3, #1
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 8002122:	e9c1 2401 	strd	r2, r4, [r1, #4]
	pxIndex->pxPrevious->pxNext = pxNewListItem;
 8002126:	6061      	str	r1, [r4, #4]
	pxIndex->pxPrevious = pxNewListItem;
 8002128:	6091      	str	r1, [r2, #8]
}
 800212a:	bc10      	pop	{r4}
	pxNewListItem->pxContainer = pxList;
 800212c:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
 800212e:	6003      	str	r3, [r0, #0]
}
 8002130:	4770      	bx	lr
 8002132:	bf00      	nop

08002134 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 8002134:	b430      	push	{r4, r5}
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 8002136:	680d      	ldr	r5, [r1, #0]
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 8002138:	1c6b      	adds	r3, r5, #1
 800213a:	d010      	beq.n	800215e <vListInsert+0x2a>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
 800213c:	f100 0308 	add.w	r3, r0, #8
 8002140:	461c      	mov	r4, r3
 8002142:	685b      	ldr	r3, [r3, #4]
 8002144:	681a      	ldr	r2, [r3, #0]
 8002146:	42aa      	cmp	r2, r5
 8002148:	d9fa      	bls.n	8002140 <vListInsert+0xc>

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;

	( pxList->uxNumberOfItems )++;
 800214a:	6802      	ldr	r2, [r0, #0]
	pxNewListItem->pxNext = pxIterator->pxNext;
 800214c:	604b      	str	r3, [r1, #4]
	( pxList->uxNumberOfItems )++;
 800214e:	3201      	adds	r2, #1
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 8002150:	6099      	str	r1, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
 8002152:	608c      	str	r4, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
 8002154:	6061      	str	r1, [r4, #4]
	pxNewListItem->pxContainer = pxList;
 8002156:	6108      	str	r0, [r1, #16]
}
 8002158:	bc30      	pop	{r4, r5}
	( pxList->uxNumberOfItems )++;
 800215a:	6002      	str	r2, [r0, #0]
}
 800215c:	4770      	bx	lr
		pxIterator = pxList->xListEnd.pxPrevious;
 800215e:	6904      	ldr	r4, [r0, #16]
	pxNewListItem->pxNext = pxIterator->pxNext;
 8002160:	6863      	ldr	r3, [r4, #4]
 8002162:	e7f2      	b.n	800214a <vListInsert+0x16>

08002164 <uxListRemove>:

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
 8002164:	6903      	ldr	r3, [r0, #16]
{
 8002166:	b410      	push	{r4}

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8002168:	e9d0 1201 	ldrd	r1, r2, [r0, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 800216c:	685c      	ldr	r4, [r3, #4]
	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 800216e:	608a      	str	r2, [r1, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 8002170:	6051      	str	r1, [r2, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
 8002172:	2100      	movs	r1, #0
	if( pxList->pxIndex == pxItemToRemove )
 8002174:	4284      	cmp	r4, r0
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 8002176:	bf08      	it	eq
 8002178:	605a      	streq	r2, [r3, #4]
	( pxList->uxNumberOfItems )--;
 800217a:	681a      	ldr	r2, [r3, #0]
	pxItemToRemove->pxContainer = NULL;
 800217c:	6101      	str	r1, [r0, #16]
	( pxList->uxNumberOfItems )--;
 800217e:	3a01      	subs	r2, #1
 8002180:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
 8002182:	6818      	ldr	r0, [r3, #0]
}
 8002184:	bc10      	pop	{r4}
 8002186:	4770      	bx	lr

08002188 <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
 8002188:	b570      	push	{r4, r5, r6, lr}
 800218a:	4616      	mov	r6, r2

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 800218c:	6c02      	ldr	r2, [r0, #64]	@ 0x40
{
 800218e:	4604      	mov	r4, r0
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8002190:	6b85      	ldr	r5, [r0, #56]	@ 0x38
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 8002192:	b92a      	cbnz	r2, 80021a0 <prvCopyDataToQueue+0x18>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8002194:	6806      	ldr	r6, [r0, #0]
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 8002196:	3501      	adds	r5, #1
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8002198:	b34e      	cbz	r6, 80021ee <prvCopyDataToQueue+0x66>
BaseType_t xReturn = pdFALSE;
 800219a:	4610      	mov	r0, r2
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 800219c:	63a5      	str	r5, [r4, #56]	@ 0x38

	return xReturn;
}
 800219e:	bd70      	pop	{r4, r5, r6, pc}
	else if( xPosition == queueSEND_TO_BACK )
 80021a0:	b98e      	cbnz	r6, 80021c6 <prvCopyDataToQueue+0x3e>
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 80021a2:	6840      	ldr	r0, [r0, #4]
 80021a4:	f004 fdce 	bl	8006d44 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 80021a8:	6863      	ldr	r3, [r4, #4]
 80021aa:	6c21      	ldr	r1, [r4, #64]	@ 0x40
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 80021ac:	68a2      	ldr	r2, [r4, #8]
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 80021ae:	440b      	add	r3, r1
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 80021b0:	4293      	cmp	r3, r2
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 80021b2:	6063      	str	r3, [r4, #4]
			pxQueue->pcWriteTo = pxQueue->pcHead;
 80021b4:	bf28      	it	cs
 80021b6:	6823      	ldrcs	r3, [r4, #0]
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 80021b8:	f105 0501 	add.w	r5, r5, #1
			pxQueue->pcWriteTo = pxQueue->pcHead;
 80021bc:	bf28      	it	cs
 80021be:	6063      	strcs	r3, [r4, #4]
BaseType_t xReturn = pdFALSE;
 80021c0:	2000      	movs	r0, #0
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 80021c2:	63a5      	str	r5, [r4, #56]	@ 0x38
}
 80021c4:	bd70      	pop	{r4, r5, r6, pc}
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
 80021c6:	68c0      	ldr	r0, [r0, #12]
 80021c8:	f004 fdbc 	bl	8006d44 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
 80021cc:	6c22      	ldr	r2, [r4, #64]	@ 0x40
 80021ce:	68e3      	ldr	r3, [r4, #12]
 80021d0:	4251      	negs	r1, r2
 80021d2:	1a9b      	subs	r3, r3, r2
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 80021d4:	6822      	ldr	r2, [r4, #0]
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
 80021d6:	60e3      	str	r3, [r4, #12]
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 80021d8:	4293      	cmp	r3, r2
 80021da:	d202      	bcs.n	80021e2 <prvCopyDataToQueue+0x5a>
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
 80021dc:	68a3      	ldr	r3, [r4, #8]
 80021de:	440b      	add	r3, r1
 80021e0:	60e3      	str	r3, [r4, #12]
		if( xPosition == queueOVERWRITE )
 80021e2:	2e02      	cmp	r6, #2
 80021e4:	d008      	beq.n	80021f8 <prvCopyDataToQueue+0x70>
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 80021e6:	3501      	adds	r5, #1
BaseType_t xReturn = pdFALSE;
 80021e8:	2000      	movs	r0, #0
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 80021ea:	63a5      	str	r5, [r4, #56]	@ 0x38
}
 80021ec:	bd70      	pop	{r4, r5, r6, pc}
				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
 80021ee:	6880      	ldr	r0, [r0, #8]
 80021f0:	f001 fcf8 	bl	8003be4 <xTaskPriorityDisinherit>
				pxQueue->u.xSemaphore.xMutexHolder = NULL;
 80021f4:	60a6      	str	r6, [r4, #8]
 80021f6:	e7d1      	b.n	800219c <prvCopyDataToQueue+0x14>
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 80021f8:	2d01      	cmp	r5, #1
 80021fa:	bf38      	it	cc
 80021fc:	2501      	movcc	r5, #1
 80021fe:	e7df      	b.n	80021c0 <prvCopyDataToQueue+0x38>

08002200 <xQueueGenericCreateStatic>:
	{
 8002200:	b570      	push	{r4, r5, r6, lr}
 8002202:	b084      	sub	sp, #16
 8002204:	f89d 6020 	ldrb.w	r6, [sp, #32]
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 8002208:	b940      	cbnz	r0, 800221c <xQueueGenericCreateStatic+0x1c>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
 800220a:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800220e:	f383 8811 	msr	BASEPRI, r3
 8002212:	f3bf 8f6f 	isb	sy
 8002216:	f3bf 8f4f 	dsb	sy
 800221a:	e7fe      	b.n	800221a <xQueueGenericCreateStatic+0x1a>
		configASSERT( pxStaticQueue != NULL );
 800221c:	461c      	mov	r4, r3
 800221e:	b183      	cbz	r3, 8002242 <xQueueGenericCreateStatic+0x42>
		configASSERT( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) );
 8002220:	4605      	mov	r5, r0
 8002222:	b302      	cbz	r2, 8002266 <xQueueGenericCreateStatic+0x66>
 8002224:	b1b1      	cbz	r1, 8002254 <xQueueGenericCreateStatic+0x54>
			volatile size_t xSize = sizeof( StaticQueue_t );
 8002226:	2350      	movs	r3, #80	@ 0x50
 8002228:	9303      	str	r3, [sp, #12]
			configASSERT( xSize == sizeof( Queue_t ) );
 800222a:	9b03      	ldr	r3, [sp, #12]
 800222c:	2b50      	cmp	r3, #80	@ 0x50
 800222e:	d05d      	beq.n	80022ec <xQueueGenericCreateStatic+0xec>
 8002230:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8002234:	f383 8811 	msr	BASEPRI, r3
 8002238:	f3bf 8f6f 	isb	sy
 800223c:	f3bf 8f4f 	dsb	sy
 8002240:	e7fe      	b.n	8002240 <xQueueGenericCreateStatic+0x40>
 8002242:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8002246:	f383 8811 	msr	BASEPRI, r3
 800224a:	f3bf 8f6f 	isb	sy
 800224e:	f3bf 8f4f 	dsb	sy
		configASSERT( pxStaticQueue != NULL );
 8002252:	e7fe      	b.n	8002252 <xQueueGenericCreateStatic+0x52>
 8002254:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8002258:	f383 8811 	msr	BASEPRI, r3
 800225c:	f3bf 8f6f 	isb	sy
 8002260:	f3bf 8f4f 	dsb	sy
		configASSERT( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) );
 8002264:	e7fe      	b.n	8002264 <xQueueGenericCreateStatic+0x64>
		configASSERT( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) );
 8002266:	2900      	cmp	r1, #0
 8002268:	d137      	bne.n	80022da <xQueueGenericCreateStatic+0xda>
			volatile size_t xSize = sizeof( StaticQueue_t );
 800226a:	2350      	movs	r3, #80	@ 0x50
 800226c:	9303      	str	r3, [sp, #12]
			configASSERT( xSize == sizeof( Queue_t ) );
 800226e:	9b03      	ldr	r3, [sp, #12]
 8002270:	2b50      	cmp	r3, #80	@ 0x50
 8002272:	d1dd      	bne.n	8002230 <xQueueGenericCreateStatic+0x30>
			( void ) xSize; /* Keeps lint quiet when configASSERT() is not defined. */
 8002274:	4622      	mov	r2, r4
 8002276:	9b03      	ldr	r3, [sp, #12]
				pxNewQueue->ucStaticallyAllocated = pdTRUE;
 8002278:	2301      	movs	r3, #1
	pxNewQueue->uxItemSize = uxItemSize;
 800227a:	e9c4 510f 	strd	r5, r1, [r4, #60]	@ 0x3c
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 800227e:	6022      	str	r2, [r4, #0]
				pxNewQueue->ucStaticallyAllocated = pdTRUE;
 8002280:	f884 3046 	strb.w	r3, [r4, #70]	@ 0x46
	pxNewQueue->uxItemSize = uxItemSize;
 8002284:	9101      	str	r1, [sp, #4]
	taskENTER_CRITICAL();
 8002286:	f002 f845 	bl	8004314 <vPortEnterCritical>
		pxQueue->cRxLock = queueUNLOCKED;
 800228a:	23ff      	movs	r3, #255	@ 0xff
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 800228c:	2200      	movs	r2, #0
 800228e:	63a2      	str	r2, [r4, #56]	@ 0x38
		pxQueue->cRxLock = queueUNLOCKED;
 8002290:	f884 3044 	strb.w	r3, [r4, #68]	@ 0x44
		pxQueue->cTxLock = queueUNLOCKED;
 8002294:	f884 3045 	strb.w	r3, [r4, #69]	@ 0x45
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8002298:	e9d4 300f 	ldrd	r3, r0, [r4, #60]	@ 0x3c
 800229c:	fb00 f303 	mul.w	r3, r0, r3
 80022a0:	6822      	ldr	r2, [r4, #0]
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 80022a2:	1a18      	subs	r0, r3, r0
		pxQueue->pcWriteTo = pxQueue->pcHead;
 80022a4:	6062      	str	r2, [r4, #4]
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 80022a6:	4413      	add	r3, r2
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 80022a8:	4402      	add	r2, r0
 80022aa:	e9c4 3202 	strd	r3, r2, [r4, #8]
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 80022ae:	f104 0010 	add.w	r0, r4, #16
 80022b2:	f7ff ff21 	bl	80020f8 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 80022b6:	f104 0024 	add.w	r0, r4, #36	@ 0x24
 80022ba:	f7ff ff1d 	bl	80020f8 <vListInitialise>
	taskEXIT_CRITICAL();
 80022be:	f002 f84b 	bl	8004358 <vPortExitCritical>
	traceQUEUE_CREATE( pxNewQueue );
 80022c2:	9901      	ldr	r1, [sp, #4]
 80022c4:	2073      	movs	r0, #115	@ 0x73
 80022c6:	460a      	mov	r2, r1
 80022c8:	4633      	mov	r3, r6
 80022ca:	4629      	mov	r1, r5
		pxNewQueue->ucQueueType = ucQueueType;
 80022cc:	f884 604c 	strb.w	r6, [r4, #76]	@ 0x4c
	traceQUEUE_CREATE( pxNewQueue );
 80022d0:	f003 f9e2 	bl	8005698 <SEGGER_SYSVIEW_RecordU32x3>
	}
 80022d4:	4620      	mov	r0, r4
 80022d6:	b004      	add	sp, #16
 80022d8:	bd70      	pop	{r4, r5, r6, pc}
 80022da:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80022de:	f383 8811 	msr	BASEPRI, r3
 80022e2:	f3bf 8f6f 	isb	sy
 80022e6:	f3bf 8f4f 	dsb	sy
		configASSERT( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) );
 80022ea:	e7fe      	b.n	80022ea <xQueueGenericCreateStatic+0xea>
			( void ) xSize; /* Keeps lint quiet when configASSERT() is not defined. */
 80022ec:	9b03      	ldr	r3, [sp, #12]
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 80022ee:	e7c3      	b.n	8002278 <xQueueGenericCreateStatic+0x78>

080022f0 <xQueueGenericCreate>:
	{
 80022f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 80022f2:	b940      	cbnz	r0, 8002306 <xQueueGenericCreate+0x16>
 80022f4:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80022f8:	f383 8811 	msr	BASEPRI, r3
 80022fc:	f3bf 8f6f 	isb	sy
 8002300:	f3bf 8f4f 	dsb	sy
 8002304:	e7fe      	b.n	8002304 <xQueueGenericCreate+0x14>
 8002306:	4604      	mov	r4, r0
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8002308:	fb01 f000 	mul.w	r0, r1, r0
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
 800230c:	3050      	adds	r0, #80	@ 0x50
 800230e:	460f      	mov	r7, r1
 8002310:	4616      	mov	r6, r2
 8002312:	f002 f977 	bl	8004604 <pvPortMalloc>
		if( pxNewQueue != NULL )
 8002316:	4605      	mov	r5, r0
 8002318:	b370      	cbz	r0, 8002378 <xQueueGenericCreate+0x88>
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
 800231a:	2300      	movs	r3, #0
 800231c:	f880 3046 	strb.w	r3, [r0, #70]	@ 0x46
	if( uxItemSize == ( UBaseType_t ) 0 )
 8002320:	b367      	cbz	r7, 800237c <xQueueGenericCreate+0x8c>
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8002322:	f100 0350 	add.w	r3, r0, #80	@ 0x50
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 8002326:	602b      	str	r3, [r5, #0]
	pxNewQueue->uxItemSize = uxItemSize;
 8002328:	e9c5 470f 	strd	r4, r7, [r5, #60]	@ 0x3c
	taskENTER_CRITICAL();
 800232c:	f001 fff2 	bl	8004314 <vPortEnterCritical>
		pxQueue->cRxLock = queueUNLOCKED;
 8002330:	23ff      	movs	r3, #255	@ 0xff
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 8002332:	2200      	movs	r2, #0
 8002334:	63aa      	str	r2, [r5, #56]	@ 0x38
		pxQueue->cRxLock = queueUNLOCKED;
 8002336:	f885 3044 	strb.w	r3, [r5, #68]	@ 0x44
		pxQueue->cTxLock = queueUNLOCKED;
 800233a:	f885 3045 	strb.w	r3, [r5, #69]	@ 0x45
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 800233e:	e9d5 310f 	ldrd	r3, r1, [r5, #60]	@ 0x3c
 8002342:	fb01 f303 	mul.w	r3, r1, r3
 8002346:	682a      	ldr	r2, [r5, #0]
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8002348:	1a59      	subs	r1, r3, r1
		pxQueue->pcWriteTo = pxQueue->pcHead;
 800234a:	606a      	str	r2, [r5, #4]
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 800234c:	4413      	add	r3, r2
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 800234e:	440a      	add	r2, r1
 8002350:	e9c5 3202 	strd	r3, r2, [r5, #8]
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 8002354:	f105 0010 	add.w	r0, r5, #16
 8002358:	f7ff fece 	bl	80020f8 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 800235c:	f105 0024 	add.w	r0, r5, #36	@ 0x24
 8002360:	f7ff feca 	bl	80020f8 <vListInitialise>
	taskEXIT_CRITICAL();
 8002364:	f001 fff8 	bl	8004358 <vPortExitCritical>
	traceQUEUE_CREATE( pxNewQueue );
 8002368:	2073      	movs	r0, #115	@ 0x73
 800236a:	4633      	mov	r3, r6
 800236c:	463a      	mov	r2, r7
 800236e:	4621      	mov	r1, r4
		pxNewQueue->ucQueueType = ucQueueType;
 8002370:	f885 604c 	strb.w	r6, [r5, #76]	@ 0x4c
	traceQUEUE_CREATE( pxNewQueue );
 8002374:	f003 f990 	bl	8005698 <SEGGER_SYSVIEW_RecordU32x3>
	}
 8002378:	4628      	mov	r0, r5
 800237a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 800237c:	4603      	mov	r3, r0
 800237e:	e7d2      	b.n	8002326 <xQueueGenericCreate+0x36>

08002380 <xQueueGenericSend>:
{
 8002380:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8002384:	b087      	sub	sp, #28
 8002386:	9203      	str	r2, [sp, #12]
	configASSERT( pxQueue );
 8002388:	2800      	cmp	r0, #0
 800238a:	f000 8124 	beq.w	80025d6 <xQueueGenericSend+0x256>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800238e:	4604      	mov	r4, r0
 8002390:	4688      	mov	r8, r1
 8002392:	461f      	mov	r7, r3
 8002394:	2900      	cmp	r1, #0
 8002396:	f000 80b7 	beq.w	8002508 <xQueueGenericSend+0x188>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 800239a:	2f02      	cmp	r7, #2
 800239c:	d10b      	bne.n	80023b6 <xQueueGenericSend+0x36>
 800239e:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
 80023a0:	2b01      	cmp	r3, #1
 80023a2:	d008      	beq.n	80023b6 <xQueueGenericSend+0x36>
 80023a4:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80023a8:	f383 8811 	msr	BASEPRI, r3
 80023ac:	f3bf 8f6f 	isb	sy
 80023b0:	f3bf 8f4f 	dsb	sy
 80023b4:	e7fe      	b.n	80023b4 <xQueueGenericSend+0x34>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 80023b6:	f001 fbb3 	bl	8003b20 <xTaskGetSchedulerState>
 80023ba:	2800      	cmp	r0, #0
 80023bc:	f000 8114 	beq.w	80025e8 <xQueueGenericSend+0x268>
		taskENTER_CRITICAL();
 80023c0:	f001 ffa8 	bl	8004314 <vPortEnterCritical>
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 80023c4:	6ba2      	ldr	r2, [r4, #56]	@ 0x38
 80023c6:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
 80023c8:	429a      	cmp	r2, r3
 80023ca:	d379      	bcc.n	80024c0 <xQueueGenericSend+0x140>
 80023cc:	2f02      	cmp	r7, #2
 80023ce:	d077      	beq.n	80024c0 <xQueueGenericSend+0x140>
 80023d0:	2300      	movs	r3, #0
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 80023d2:	f104 0624 	add.w	r6, r4, #36	@ 0x24
				if( xTicksToWait == ( TickType_t ) 0 )
 80023d6:	9a03      	ldr	r2, [sp, #12]
 80023d8:	2a00      	cmp	r2, #0
 80023da:	f000 8112 	beq.w	8002602 <xQueueGenericSend+0x282>
				else if( xEntryTimeSet == pdFALSE )
 80023de:	2b00      	cmp	r3, #0
 80023e0:	f000 80f5 	beq.w	80025ce <xQueueGenericSend+0x24e>
		taskEXIT_CRITICAL();
 80023e4:	f001 ffb8 	bl	8004358 <vPortExitCritical>
		vTaskSuspendAll();
 80023e8:	f001 f9fa 	bl	80037e0 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 80023ec:	f001 ff92 	bl	8004314 <vPortEnterCritical>
 80023f0:	f894 3044 	ldrb.w	r3, [r4, #68]	@ 0x44
 80023f4:	2bff      	cmp	r3, #255	@ 0xff
 80023f6:	bf04      	itt	eq
 80023f8:	2300      	moveq	r3, #0
 80023fa:	f884 3044 	strbeq.w	r3, [r4, #68]	@ 0x44
 80023fe:	f894 3045 	ldrb.w	r3, [r4, #69]	@ 0x45
 8002402:	2bff      	cmp	r3, #255	@ 0xff
 8002404:	bf04      	itt	eq
 8002406:	2300      	moveq	r3, #0
 8002408:	f884 3045 	strbeq.w	r3, [r4, #69]	@ 0x45
 800240c:	f001 ffa4 	bl	8004358 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 8002410:	a804      	add	r0, sp, #16
 8002412:	a903      	add	r1, sp, #12
 8002414:	f001 fb3e 	bl	8003a94 <xTaskCheckForTimeOut>
 8002418:	2800      	cmp	r0, #0
 800241a:	f040 8102 	bne.w	8002622 <xQueueGenericSend+0x2a2>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
 800241e:	f001 ff79 	bl	8004314 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 8002422:	6ba2      	ldr	r2, [r4, #56]	@ 0x38
 8002424:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
 8002426:	429a      	cmp	r2, r3
 8002428:	d07b      	beq.n	8002522 <xQueueGenericSend+0x1a2>
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
 800242a:	f001 ff95 	bl	8004358 <vPortExitCritical>
	taskENTER_CRITICAL();
 800242e:	f001 ff71 	bl	8004314 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
 8002432:	f894 2045 	ldrb.w	r2, [r4, #69]	@ 0x45
 8002436:	b255      	sxtb	r5, r2
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8002438:	2d00      	cmp	r5, #0
 800243a:	dc04      	bgt.n	8002446 <xQueueGenericSend+0xc6>
 800243c:	e011      	b.n	8002462 <xQueueGenericSend+0xe2>
			--cTxLock;
 800243e:	1e6a      	subs	r2, r5, #1
 8002440:	b2d3      	uxtb	r3, r2
 8002442:	b255      	sxtb	r5, r2
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8002444:	b16b      	cbz	r3, 8002462 <xQueueGenericSend+0xe2>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8002446:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 8002448:	b15b      	cbz	r3, 8002462 <xQueueGenericSend+0xe2>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800244a:	4630      	mov	r0, r6
 800244c:	f001 facc 	bl	80039e8 <xTaskRemoveFromEventList>
 8002450:	2800      	cmp	r0, #0
 8002452:	d0f4      	beq.n	800243e <xQueueGenericSend+0xbe>
						vTaskMissedYield();
 8002454:	f001 fb5e 	bl	8003b14 <vTaskMissedYield>
			--cTxLock;
 8002458:	1e6a      	subs	r2, r5, #1
 800245a:	b2d3      	uxtb	r3, r2
 800245c:	b255      	sxtb	r5, r2
		while( cTxLock > queueLOCKED_UNMODIFIED )
 800245e:	2b00      	cmp	r3, #0
 8002460:	d1f1      	bne.n	8002446 <xQueueGenericSend+0xc6>
		pxQueue->cTxLock = queueUNLOCKED;
 8002462:	23ff      	movs	r3, #255	@ 0xff
 8002464:	f884 3045 	strb.w	r3, [r4, #69]	@ 0x45
	taskEXIT_CRITICAL();
 8002468:	f001 ff76 	bl	8004358 <vPortExitCritical>
	taskENTER_CRITICAL();
 800246c:	f001 ff52 	bl	8004314 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
 8002470:	f894 2044 	ldrb.w	r2, [r4, #68]	@ 0x44
 8002474:	b255      	sxtb	r5, r2
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8002476:	2d00      	cmp	r5, #0
 8002478:	dd14      	ble.n	80024a4 <xQueueGenericSend+0x124>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800247a:	f104 0910 	add.w	r9, r4, #16
 800247e:	e003      	b.n	8002488 <xQueueGenericSend+0x108>
				--cRxLock;
 8002480:	1e6a      	subs	r2, r5, #1
 8002482:	b2d3      	uxtb	r3, r2
 8002484:	b255      	sxtb	r5, r2
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8002486:	b16b      	cbz	r3, 80024a4 <xQueueGenericSend+0x124>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8002488:	6923      	ldr	r3, [r4, #16]
 800248a:	b15b      	cbz	r3, 80024a4 <xQueueGenericSend+0x124>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800248c:	4648      	mov	r0, r9
 800248e:	f001 faab 	bl	80039e8 <xTaskRemoveFromEventList>
 8002492:	2800      	cmp	r0, #0
 8002494:	d0f4      	beq.n	8002480 <xQueueGenericSend+0x100>
					vTaskMissedYield();
 8002496:	f001 fb3d 	bl	8003b14 <vTaskMissedYield>
				--cRxLock;
 800249a:	1e6a      	subs	r2, r5, #1
 800249c:	b2d3      	uxtb	r3, r2
 800249e:	b255      	sxtb	r5, r2
		while( cRxLock > queueLOCKED_UNMODIFIED )
 80024a0:	2b00      	cmp	r3, #0
 80024a2:	d1f1      	bne.n	8002488 <xQueueGenericSend+0x108>
		pxQueue->cRxLock = queueUNLOCKED;
 80024a4:	23ff      	movs	r3, #255	@ 0xff
 80024a6:	f884 3044 	strb.w	r3, [r4, #68]	@ 0x44
	taskEXIT_CRITICAL();
 80024aa:	f001 ff55 	bl	8004358 <vPortExitCritical>
				( void ) xTaskResumeAll();
 80024ae:	f001 f99f 	bl	80037f0 <xTaskResumeAll>
		taskENTER_CRITICAL();
 80024b2:	f001 ff2f 	bl	8004314 <vPortEnterCritical>
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 80024b6:	6ba1      	ldr	r1, [r4, #56]	@ 0x38
 80024b8:	6be2      	ldr	r2, [r4, #60]	@ 0x3c
 80024ba:	2301      	movs	r3, #1
 80024bc:	4291      	cmp	r1, r2
 80024be:	d28a      	bcs.n	80023d6 <xQueueGenericSend+0x56>
				traceQUEUE_SEND( pxQueue );
 80024c0:	4620      	mov	r0, r4
 80024c2:	f002 febf 	bl	8005244 <SEGGER_SYSVIEW_ShrinkId>
 80024c6:	9b03      	ldr	r3, [sp, #12]
 80024c8:	4601      	mov	r1, r0
 80024ca:	4642      	mov	r2, r8
 80024cc:	205a      	movs	r0, #90	@ 0x5a
 80024ce:	9700      	str	r7, [sp, #0]
 80024d0:	f003 f91c 	bl	800570c <SEGGER_SYSVIEW_RecordU32x4>
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 80024d4:	463a      	mov	r2, r7
 80024d6:	4641      	mov	r1, r8
 80024d8:	4620      	mov	r0, r4
 80024da:	f7ff fe55 	bl	8002188 <prvCopyDataToQueue>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 80024de:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 80024e0:	2b00      	cmp	r3, #0
 80024e2:	f040 80db 	bne.w	800269c <xQueueGenericSend+0x31c>
					else if( xYieldRequired != pdFALSE )
 80024e6:	b148      	cbz	r0, 80024fc <xQueueGenericSend+0x17c>
						queueYIELD_IF_USING_PREEMPTION();
 80024e8:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 80024ec:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 80024f0:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 80024f4:	f3bf 8f4f 	dsb	sy
 80024f8:	f3bf 8f6f 	isb	sy
				taskEXIT_CRITICAL();
 80024fc:	f001 ff2c 	bl	8004358 <vPortExitCritical>
				return pdPASS;
 8002500:	2001      	movs	r0, #1
}
 8002502:	b007      	add	sp, #28
 8002504:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8002508:	6c03      	ldr	r3, [r0, #64]	@ 0x40
 800250a:	2b00      	cmp	r3, #0
 800250c:	f43f af45 	beq.w	800239a <xQueueGenericSend+0x1a>
 8002510:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8002514:	f383 8811 	msr	BASEPRI, r3
 8002518:	f3bf 8f6f 	isb	sy
 800251c:	f3bf 8f4f 	dsb	sy
 8002520:	e7fe      	b.n	8002520 <xQueueGenericSend+0x1a0>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 8002522:	f104 0910 	add.w	r9, r4, #16
	taskEXIT_CRITICAL();
 8002526:	f001 ff17 	bl	8004358 <vPortExitCritical>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 800252a:	4648      	mov	r0, r9
 800252c:	9903      	ldr	r1, [sp, #12]
 800252e:	f001 f9dd 	bl	80038ec <vTaskPlaceOnEventList>
	taskENTER_CRITICAL();
 8002532:	f001 feef 	bl	8004314 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
 8002536:	f894 3045 	ldrb.w	r3, [r4, #69]	@ 0x45
 800253a:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 800253c:	2d00      	cmp	r5, #0
 800253e:	dc04      	bgt.n	800254a <xQueueGenericSend+0x1ca>
 8002540:	e011      	b.n	8002566 <xQueueGenericSend+0x1e6>
			--cTxLock;
 8002542:	1e6b      	subs	r3, r5, #1
 8002544:	b2da      	uxtb	r2, r3
 8002546:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8002548:	b16a      	cbz	r2, 8002566 <xQueueGenericSend+0x1e6>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800254a:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 800254c:	b15b      	cbz	r3, 8002566 <xQueueGenericSend+0x1e6>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800254e:	4630      	mov	r0, r6
 8002550:	f001 fa4a 	bl	80039e8 <xTaskRemoveFromEventList>
 8002554:	2800      	cmp	r0, #0
 8002556:	d0f4      	beq.n	8002542 <xQueueGenericSend+0x1c2>
						vTaskMissedYield();
 8002558:	f001 fadc 	bl	8003b14 <vTaskMissedYield>
			--cTxLock;
 800255c:	1e6b      	subs	r3, r5, #1
 800255e:	b2da      	uxtb	r2, r3
 8002560:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8002562:	2a00      	cmp	r2, #0
 8002564:	d1f1      	bne.n	800254a <xQueueGenericSend+0x1ca>
		pxQueue->cTxLock = queueUNLOCKED;
 8002566:	23ff      	movs	r3, #255	@ 0xff
 8002568:	f884 3045 	strb.w	r3, [r4, #69]	@ 0x45
	taskEXIT_CRITICAL();
 800256c:	f001 fef4 	bl	8004358 <vPortExitCritical>
	taskENTER_CRITICAL();
 8002570:	f001 fed0 	bl	8004314 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
 8002574:	f894 3044 	ldrb.w	r3, [r4, #68]	@ 0x44
 8002578:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 800257a:	2d00      	cmp	r5, #0
 800257c:	dc04      	bgt.n	8002588 <xQueueGenericSend+0x208>
 800257e:	e011      	b.n	80025a4 <xQueueGenericSend+0x224>
				--cRxLock;
 8002580:	1e6b      	subs	r3, r5, #1
 8002582:	b2da      	uxtb	r2, r3
 8002584:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8002586:	b16a      	cbz	r2, 80025a4 <xQueueGenericSend+0x224>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8002588:	6923      	ldr	r3, [r4, #16]
 800258a:	b15b      	cbz	r3, 80025a4 <xQueueGenericSend+0x224>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800258c:	4648      	mov	r0, r9
 800258e:	f001 fa2b 	bl	80039e8 <xTaskRemoveFromEventList>
 8002592:	2800      	cmp	r0, #0
 8002594:	d0f4      	beq.n	8002580 <xQueueGenericSend+0x200>
					vTaskMissedYield();
 8002596:	f001 fabd 	bl	8003b14 <vTaskMissedYield>
				--cRxLock;
 800259a:	1e6b      	subs	r3, r5, #1
 800259c:	b2da      	uxtb	r2, r3
 800259e:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 80025a0:	2a00      	cmp	r2, #0
 80025a2:	d1f1      	bne.n	8002588 <xQueueGenericSend+0x208>
		pxQueue->cRxLock = queueUNLOCKED;
 80025a4:	23ff      	movs	r3, #255	@ 0xff
 80025a6:	f884 3044 	strb.w	r3, [r4, #68]	@ 0x44
	taskEXIT_CRITICAL();
 80025aa:	f001 fed5 	bl	8004358 <vPortExitCritical>
				if( xTaskResumeAll() == pdFALSE )
 80025ae:	f001 f91f 	bl	80037f0 <xTaskResumeAll>
 80025b2:	2800      	cmp	r0, #0
 80025b4:	f47f af7d 	bne.w	80024b2 <xQueueGenericSend+0x132>
					portYIELD_WITHIN_API();
 80025b8:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 80025bc:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 80025c0:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 80025c4:	f3bf 8f4f 	dsb	sy
 80025c8:	f3bf 8f6f 	isb	sy
 80025cc:	e771      	b.n	80024b2 <xQueueGenericSend+0x132>
					vTaskInternalSetTimeOutState( &xTimeOut );
 80025ce:	a804      	add	r0, sp, #16
 80025d0:	f001 fa54 	bl	8003a7c <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 80025d4:	e706      	b.n	80023e4 <xQueueGenericSend+0x64>
 80025d6:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80025da:	f383 8811 	msr	BASEPRI, r3
 80025de:	f3bf 8f6f 	isb	sy
 80025e2:	f3bf 8f4f 	dsb	sy
	configASSERT( pxQueue );
 80025e6:	e7fe      	b.n	80025e6 <xQueueGenericSend+0x266>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 80025e8:	9b03      	ldr	r3, [sp, #12]
 80025ea:	2b00      	cmp	r3, #0
 80025ec:	f43f aee8 	beq.w	80023c0 <xQueueGenericSend+0x40>
 80025f0:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80025f4:	f383 8811 	msr	BASEPRI, r3
 80025f8:	f3bf 8f6f 	isb	sy
 80025fc:	f3bf 8f4f 	dsb	sy
 8002600:	e7fe      	b.n	8002600 <xQueueGenericSend+0x280>
					taskEXIT_CRITICAL();
 8002602:	f001 fea9 	bl	8004358 <vPortExitCritical>
			traceQUEUE_SEND_FAILED( pxQueue );
 8002606:	4620      	mov	r0, r4
 8002608:	f002 fe1c 	bl	8005244 <SEGGER_SYSVIEW_ShrinkId>
 800260c:	4642      	mov	r2, r8
 800260e:	4601      	mov	r1, r0
 8002610:	9b03      	ldr	r3, [sp, #12]
 8002612:	205a      	movs	r0, #90	@ 0x5a
 8002614:	9700      	str	r7, [sp, #0]
 8002616:	f003 f879 	bl	800570c <SEGGER_SYSVIEW_RecordU32x4>
					return errQUEUE_FULL;
 800261a:	2000      	movs	r0, #0
}
 800261c:	b007      	add	sp, #28
 800261e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	taskENTER_CRITICAL();
 8002622:	f001 fe77 	bl	8004314 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
 8002626:	f894 3045 	ldrb.w	r3, [r4, #69]	@ 0x45
 800262a:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 800262c:	2d00      	cmp	r5, #0
 800262e:	dd10      	ble.n	8002652 <xQueueGenericSend+0x2d2>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8002630:	f104 0624 	add.w	r6, r4, #36	@ 0x24
 8002634:	e003      	b.n	800263e <xQueueGenericSend+0x2be>
			--cTxLock;
 8002636:	1e6b      	subs	r3, r5, #1
 8002638:	b2da      	uxtb	r2, r3
 800263a:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 800263c:	b14a      	cbz	r2, 8002652 <xQueueGenericSend+0x2d2>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800263e:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 8002640:	b13b      	cbz	r3, 8002652 <xQueueGenericSend+0x2d2>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8002642:	4630      	mov	r0, r6
 8002644:	f001 f9d0 	bl	80039e8 <xTaskRemoveFromEventList>
 8002648:	2800      	cmp	r0, #0
 800264a:	d0f4      	beq.n	8002636 <xQueueGenericSend+0x2b6>
						vTaskMissedYield();
 800264c:	f001 fa62 	bl	8003b14 <vTaskMissedYield>
 8002650:	e7f1      	b.n	8002636 <xQueueGenericSend+0x2b6>
		pxQueue->cTxLock = queueUNLOCKED;
 8002652:	23ff      	movs	r3, #255	@ 0xff
 8002654:	f884 3045 	strb.w	r3, [r4, #69]	@ 0x45
	taskEXIT_CRITICAL();
 8002658:	f001 fe7e 	bl	8004358 <vPortExitCritical>
	taskENTER_CRITICAL();
 800265c:	f001 fe5a 	bl	8004314 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
 8002660:	f894 3044 	ldrb.w	r3, [r4, #68]	@ 0x44
 8002664:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8002666:	2d00      	cmp	r5, #0
 8002668:	dd10      	ble.n	800268c <xQueueGenericSend+0x30c>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800266a:	f104 0610 	add.w	r6, r4, #16
 800266e:	e003      	b.n	8002678 <xQueueGenericSend+0x2f8>
				--cRxLock;
 8002670:	1e6b      	subs	r3, r5, #1
 8002672:	b2da      	uxtb	r2, r3
 8002674:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8002676:	b14a      	cbz	r2, 800268c <xQueueGenericSend+0x30c>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8002678:	6923      	ldr	r3, [r4, #16]
 800267a:	b13b      	cbz	r3, 800268c <xQueueGenericSend+0x30c>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800267c:	4630      	mov	r0, r6
 800267e:	f001 f9b3 	bl	80039e8 <xTaskRemoveFromEventList>
 8002682:	2800      	cmp	r0, #0
 8002684:	d0f4      	beq.n	8002670 <xQueueGenericSend+0x2f0>
					vTaskMissedYield();
 8002686:	f001 fa45 	bl	8003b14 <vTaskMissedYield>
 800268a:	e7f1      	b.n	8002670 <xQueueGenericSend+0x2f0>
		pxQueue->cRxLock = queueUNLOCKED;
 800268c:	23ff      	movs	r3, #255	@ 0xff
 800268e:	f884 3044 	strb.w	r3, [r4, #68]	@ 0x44
	taskEXIT_CRITICAL();
 8002692:	f001 fe61 	bl	8004358 <vPortExitCritical>
			( void ) xTaskResumeAll();
 8002696:	f001 f8ab 	bl	80037f0 <xTaskResumeAll>
 800269a:	e7b4      	b.n	8002606 <xQueueGenericSend+0x286>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800269c:	f104 0024 	add.w	r0, r4, #36	@ 0x24
 80026a0:	f001 f9a2 	bl	80039e8 <xTaskRemoveFromEventList>
 80026a4:	2800      	cmp	r0, #0
 80026a6:	f43f af29 	beq.w	80024fc <xQueueGenericSend+0x17c>
 80026aa:	e71d      	b.n	80024e8 <xQueueGenericSend+0x168>

080026ac <xQueueGenericSendFromISR>:
{
 80026ac:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	configASSERT( pxQueue );
 80026b0:	2800      	cmp	r0, #0
 80026b2:	d04d      	beq.n	8002750 <xQueueGenericSendFromISR+0xa4>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 80026b4:	4604      	mov	r4, r0
 80026b6:	460f      	mov	r7, r1
 80026b8:	4616      	mov	r6, r2
 80026ba:	461d      	mov	r5, r3
 80026bc:	2900      	cmp	r1, #0
 80026be:	d03b      	beq.n	8002738 <xQueueGenericSendFromISR+0x8c>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 80026c0:	2d02      	cmp	r5, #2
 80026c2:	d10b      	bne.n	80026dc <xQueueGenericSendFromISR+0x30>
 80026c4:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
 80026c6:	2b01      	cmp	r3, #1
 80026c8:	d008      	beq.n	80026dc <xQueueGenericSendFromISR+0x30>
 80026ca:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80026ce:	f383 8811 	msr	BASEPRI, r3
 80026d2:	f3bf 8f6f 	isb	sy
 80026d6:	f3bf 8f4f 	dsb	sy
 80026da:	e7fe      	b.n	80026da <xQueueGenericSendFromISR+0x2e>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 80026dc:	f001 ff1e 	bl	800451c <vPortValidateInterruptPriority>

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile
 80026e0:	f3ef 8911 	mrs	r9, BASEPRI
 80026e4:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80026e8:	f383 8811 	msr	BASEPRI, r3
 80026ec:	f3bf 8f6f 	isb	sy
 80026f0:	f3bf 8f4f 	dsb	sy
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 80026f4:	6ba2      	ldr	r2, [r4, #56]	@ 0x38
 80026f6:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
 80026f8:	429a      	cmp	r2, r3
 80026fa:	d301      	bcc.n	8002700 <xQueueGenericSendFromISR+0x54>
 80026fc:	2d02      	cmp	r5, #2
 80026fe:	d130      	bne.n	8002762 <xQueueGenericSendFromISR+0xb6>
			traceQUEUE_SEND_FROM_ISR( pxQueue );
 8002700:	4620      	mov	r0, r4
			const int8_t cTxLock = pxQueue->cTxLock;
 8002702:	f894 8045 	ldrb.w	r8, [r4, #69]	@ 0x45
			const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
 8002706:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
			traceQUEUE_SEND_FROM_ISR( pxQueue );
 8002708:	f002 fd9c 	bl	8005244 <SEGGER_SYSVIEW_ShrinkId>
 800270c:	4632      	mov	r2, r6
 800270e:	4601      	mov	r1, r0
 8002710:	2060      	movs	r0, #96	@ 0x60
 8002712:	f002 ff95 	bl	8005640 <SEGGER_SYSVIEW_RecordU32x2>
			const int8_t cTxLock = pxQueue->cTxLock;
 8002716:	fa4f f888 	sxtb.w	r8, r8
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 800271a:	462a      	mov	r2, r5
 800271c:	4639      	mov	r1, r7
 800271e:	4620      	mov	r0, r4
 8002720:	f7ff fd32 	bl	8002188 <prvCopyDataToQueue>
			if( cTxLock == queueUNLOCKED )
 8002724:	f1b8 3fff 	cmp.w	r8, #4294967295
 8002728:	d028      	beq.n	800277c <xQueueGenericSendFromISR+0xd0>
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 800272a:	f108 0301 	add.w	r3, r8, #1
 800272e:	b25b      	sxtb	r3, r3
 8002730:	f884 3045 	strb.w	r3, [r4, #69]	@ 0x45
			xReturn = pdPASS;
 8002734:	2001      	movs	r0, #1
 8002736:	e01d      	b.n	8002774 <xQueueGenericSendFromISR+0xc8>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8002738:	6c03      	ldr	r3, [r0, #64]	@ 0x40
 800273a:	2b00      	cmp	r3, #0
 800273c:	d0c0      	beq.n	80026c0 <xQueueGenericSendFromISR+0x14>
	__asm volatile
 800273e:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8002742:	f383 8811 	msr	BASEPRI, r3
 8002746:	f3bf 8f6f 	isb	sy
 800274a:	f3bf 8f4f 	dsb	sy
 800274e:	e7fe      	b.n	800274e <xQueueGenericSendFromISR+0xa2>
 8002750:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8002754:	f383 8811 	msr	BASEPRI, r3
 8002758:	f3bf 8f6f 	isb	sy
 800275c:	f3bf 8f4f 	dsb	sy
	configASSERT( pxQueue );
 8002760:	e7fe      	b.n	8002760 <xQueueGenericSendFromISR+0xb4>
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
 8002762:	4620      	mov	r0, r4
 8002764:	f002 fd6e 	bl	8005244 <SEGGER_SYSVIEW_ShrinkId>
 8002768:	4632      	mov	r2, r6
 800276a:	4601      	mov	r1, r0
 800276c:	2060      	movs	r0, #96	@ 0x60
 800276e:	f002 ff67 	bl	8005640 <SEGGER_SYSVIEW_RecordU32x2>
			xReturn = errQUEUE_FULL;
 8002772:	2000      	movs	r0, #0
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
 8002774:	f389 8811 	msr	BASEPRI, r9
}
 8002778:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800277c:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 800277e:	2b00      	cmp	r3, #0
 8002780:	d0d8      	beq.n	8002734 <xQueueGenericSendFromISR+0x88>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8002782:	f104 0024 	add.w	r0, r4, #36	@ 0x24
 8002786:	f001 f92f 	bl	80039e8 <xTaskRemoveFromEventList>
 800278a:	2800      	cmp	r0, #0
 800278c:	d0d2      	beq.n	8002734 <xQueueGenericSendFromISR+0x88>
							if( pxHigherPriorityTaskWoken != NULL )
 800278e:	2e00      	cmp	r6, #0
 8002790:	d0d0      	beq.n	8002734 <xQueueGenericSendFromISR+0x88>
								*pxHigherPriorityTaskWoken = pdTRUE;
 8002792:	2301      	movs	r3, #1
 8002794:	6033      	str	r3, [r6, #0]
 8002796:	e7cd      	b.n	8002734 <xQueueGenericSendFromISR+0x88>

08002798 <xQueueReceive>:
{
 8002798:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800279c:	b087      	sub	sp, #28
 800279e:	9203      	str	r2, [sp, #12]
	configASSERT( ( pxQueue ) );
 80027a0:	2800      	cmp	r0, #0
 80027a2:	f000 8156 	beq.w	8002a52 <xQueueReceive+0x2ba>
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
 80027a6:	4604      	mov	r4, r0
 80027a8:	460f      	mov	r7, r1
 80027aa:	2900      	cmp	r1, #0
 80027ac:	d07b      	beq.n	80028a6 <xQueueReceive+0x10e>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 80027ae:	f001 f9b7 	bl	8003b20 <xTaskGetSchedulerState>
 80027b2:	2800      	cmp	r0, #0
 80027b4:	f000 8083 	beq.w	80028be <xQueueReceive+0x126>
		taskENTER_CRITICAL();
 80027b8:	f001 fdac 	bl	8004314 <vPortEnterCritical>
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 80027bc:	6ba5      	ldr	r5, [r4, #56]	@ 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 80027be:	2d00      	cmp	r5, #0
 80027c0:	f040 8150 	bne.w	8002a64 <xQueueReceive+0x2cc>
				if( xTicksToWait == ( TickType_t ) 0 )
 80027c4:	9b03      	ldr	r3, [sp, #12]
 80027c6:	2b00      	cmp	r3, #0
 80027c8:	f000 80d7 	beq.w	800297a <xQueueReceive+0x1e2>
					vTaskInternalSetTimeOutState( &xTimeOut );
 80027cc:	a804      	add	r0, sp, #16
 80027ce:	f001 f955 	bl	8003a7c <vTaskInternalSetTimeOutState>
		prvLockQueue( pxQueue );
 80027d2:	46a8      	mov	r8, r5
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 80027d4:	f104 0624 	add.w	r6, r4, #36	@ 0x24
		taskEXIT_CRITICAL();
 80027d8:	f001 fdbe 	bl	8004358 <vPortExitCritical>
		vTaskSuspendAll();
 80027dc:	f001 f800 	bl	80037e0 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 80027e0:	f001 fd98 	bl	8004314 <vPortEnterCritical>
 80027e4:	f894 3044 	ldrb.w	r3, [r4, #68]	@ 0x44
 80027e8:	2bff      	cmp	r3, #255	@ 0xff
 80027ea:	bf08      	it	eq
 80027ec:	f884 8044 	strbeq.w	r8, [r4, #68]	@ 0x44
 80027f0:	f894 3045 	ldrb.w	r3, [r4, #69]	@ 0x45
 80027f4:	2bff      	cmp	r3, #255	@ 0xff
 80027f6:	bf08      	it	eq
 80027f8:	f884 8045 	strbeq.w	r8, [r4, #69]	@ 0x45
 80027fc:	f001 fdac 	bl	8004358 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 8002800:	a903      	add	r1, sp, #12
 8002802:	a804      	add	r0, sp, #16
 8002804:	f001 f946 	bl	8003a94 <xTaskCheckForTimeOut>
 8002808:	2800      	cmp	r0, #0
 800280a:	d165      	bne.n	80028d8 <xQueueReceive+0x140>
	taskENTER_CRITICAL();
 800280c:	f001 fd82 	bl	8004314 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 8002810:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
 8002812:	2b00      	cmp	r3, #0
 8002814:	f000 80c6 	beq.w	80029a4 <xQueueReceive+0x20c>
	taskEXIT_CRITICAL();
 8002818:	f001 fd9e 	bl	8004358 <vPortExitCritical>
	taskENTER_CRITICAL();
 800281c:	f001 fd7a 	bl	8004314 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
 8002820:	f894 3045 	ldrb.w	r3, [r4, #69]	@ 0x45
 8002824:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8002826:	2d00      	cmp	r5, #0
 8002828:	dd14      	ble.n	8002854 <xQueueReceive+0xbc>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800282a:	f104 0924 	add.w	r9, r4, #36	@ 0x24
 800282e:	e003      	b.n	8002838 <xQueueReceive+0xa0>
			--cTxLock;
 8002830:	1e6b      	subs	r3, r5, #1
 8002832:	b2da      	uxtb	r2, r3
 8002834:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8002836:	b16a      	cbz	r2, 8002854 <xQueueReceive+0xbc>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8002838:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 800283a:	b15b      	cbz	r3, 8002854 <xQueueReceive+0xbc>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800283c:	4648      	mov	r0, r9
 800283e:	f001 f8d3 	bl	80039e8 <xTaskRemoveFromEventList>
 8002842:	2800      	cmp	r0, #0
 8002844:	d0f4      	beq.n	8002830 <xQueueReceive+0x98>
						vTaskMissedYield();
 8002846:	f001 f965 	bl	8003b14 <vTaskMissedYield>
			--cTxLock;
 800284a:	1e6b      	subs	r3, r5, #1
 800284c:	b2da      	uxtb	r2, r3
 800284e:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8002850:	2a00      	cmp	r2, #0
 8002852:	d1f1      	bne.n	8002838 <xQueueReceive+0xa0>
		pxQueue->cTxLock = queueUNLOCKED;
 8002854:	23ff      	movs	r3, #255	@ 0xff
 8002856:	f884 3045 	strb.w	r3, [r4, #69]	@ 0x45
	taskEXIT_CRITICAL();
 800285a:	f001 fd7d 	bl	8004358 <vPortExitCritical>
	taskENTER_CRITICAL();
 800285e:	f001 fd59 	bl	8004314 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
 8002862:	f894 3044 	ldrb.w	r3, [r4, #68]	@ 0x44
 8002866:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8002868:	2d00      	cmp	r5, #0
 800286a:	dd14      	ble.n	8002896 <xQueueReceive+0xfe>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800286c:	f104 0910 	add.w	r9, r4, #16
 8002870:	e003      	b.n	800287a <xQueueReceive+0xe2>
				--cRxLock;
 8002872:	1e6b      	subs	r3, r5, #1
 8002874:	b2da      	uxtb	r2, r3
 8002876:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8002878:	b16a      	cbz	r2, 8002896 <xQueueReceive+0xfe>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800287a:	6923      	ldr	r3, [r4, #16]
 800287c:	b15b      	cbz	r3, 8002896 <xQueueReceive+0xfe>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800287e:	4648      	mov	r0, r9
 8002880:	f001 f8b2 	bl	80039e8 <xTaskRemoveFromEventList>
 8002884:	2800      	cmp	r0, #0
 8002886:	d0f4      	beq.n	8002872 <xQueueReceive+0xda>
					vTaskMissedYield();
 8002888:	f001 f944 	bl	8003b14 <vTaskMissedYield>
				--cRxLock;
 800288c:	1e6b      	subs	r3, r5, #1
 800288e:	b2da      	uxtb	r2, r3
 8002890:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8002892:	2a00      	cmp	r2, #0
 8002894:	d1f1      	bne.n	800287a <xQueueReceive+0xe2>
		pxQueue->cRxLock = queueUNLOCKED;
 8002896:	23ff      	movs	r3, #255	@ 0xff
 8002898:	f884 3044 	strb.w	r3, [r4, #68]	@ 0x44
	taskEXIT_CRITICAL();
 800289c:	f001 fd5c 	bl	8004358 <vPortExitCritical>
				( void ) xTaskResumeAll();
 80028a0:	f000 ffa6 	bl	80037f0 <xTaskResumeAll>
 80028a4:	e060      	b.n	8002968 <xQueueReceive+0x1d0>
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
 80028a6:	6c03      	ldr	r3, [r0, #64]	@ 0x40
 80028a8:	2b00      	cmp	r3, #0
 80028aa:	d080      	beq.n	80027ae <xQueueReceive+0x16>
	__asm volatile
 80028ac:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80028b0:	f383 8811 	msr	BASEPRI, r3
 80028b4:	f3bf 8f6f 	isb	sy
 80028b8:	f3bf 8f4f 	dsb	sy
 80028bc:	e7fe      	b.n	80028bc <xQueueReceive+0x124>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 80028be:	9b03      	ldr	r3, [sp, #12]
 80028c0:	2b00      	cmp	r3, #0
 80028c2:	f43f af79 	beq.w	80027b8 <xQueueReceive+0x20>
 80028c6:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80028ca:	f383 8811 	msr	BASEPRI, r3
 80028ce:	f3bf 8f6f 	isb	sy
 80028d2:	f3bf 8f4f 	dsb	sy
 80028d6:	e7fe      	b.n	80028d6 <xQueueReceive+0x13e>
	taskENTER_CRITICAL();
 80028d8:	f001 fd1c 	bl	8004314 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
 80028dc:	f894 3045 	ldrb.w	r3, [r4, #69]	@ 0x45
 80028e0:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 80028e2:	2d00      	cmp	r5, #0
 80028e4:	dc04      	bgt.n	80028f0 <xQueueReceive+0x158>
 80028e6:	e011      	b.n	800290c <xQueueReceive+0x174>
			--cTxLock;
 80028e8:	1e6b      	subs	r3, r5, #1
 80028ea:	b2da      	uxtb	r2, r3
 80028ec:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 80028ee:	b16a      	cbz	r2, 800290c <xQueueReceive+0x174>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 80028f0:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 80028f2:	b15b      	cbz	r3, 800290c <xQueueReceive+0x174>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 80028f4:	4630      	mov	r0, r6
 80028f6:	f001 f877 	bl	80039e8 <xTaskRemoveFromEventList>
 80028fa:	2800      	cmp	r0, #0
 80028fc:	d0f4      	beq.n	80028e8 <xQueueReceive+0x150>
						vTaskMissedYield();
 80028fe:	f001 f909 	bl	8003b14 <vTaskMissedYield>
			--cTxLock;
 8002902:	1e6b      	subs	r3, r5, #1
 8002904:	b2da      	uxtb	r2, r3
 8002906:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8002908:	2a00      	cmp	r2, #0
 800290a:	d1f1      	bne.n	80028f0 <xQueueReceive+0x158>
		pxQueue->cTxLock = queueUNLOCKED;
 800290c:	23ff      	movs	r3, #255	@ 0xff
 800290e:	f884 3045 	strb.w	r3, [r4, #69]	@ 0x45
	taskEXIT_CRITICAL();
 8002912:	f001 fd21 	bl	8004358 <vPortExitCritical>
	taskENTER_CRITICAL();
 8002916:	f001 fcfd 	bl	8004314 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
 800291a:	f894 3044 	ldrb.w	r3, [r4, #68]	@ 0x44
 800291e:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8002920:	2d00      	cmp	r5, #0
 8002922:	dd14      	ble.n	800294e <xQueueReceive+0x1b6>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8002924:	f104 0910 	add.w	r9, r4, #16
 8002928:	e003      	b.n	8002932 <xQueueReceive+0x19a>
				--cRxLock;
 800292a:	1e6b      	subs	r3, r5, #1
 800292c:	b2da      	uxtb	r2, r3
 800292e:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8002930:	b16a      	cbz	r2, 800294e <xQueueReceive+0x1b6>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8002932:	6923      	ldr	r3, [r4, #16]
 8002934:	b15b      	cbz	r3, 800294e <xQueueReceive+0x1b6>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8002936:	4648      	mov	r0, r9
 8002938:	f001 f856 	bl	80039e8 <xTaskRemoveFromEventList>
 800293c:	2800      	cmp	r0, #0
 800293e:	d0f4      	beq.n	800292a <xQueueReceive+0x192>
					vTaskMissedYield();
 8002940:	f001 f8e8 	bl	8003b14 <vTaskMissedYield>
				--cRxLock;
 8002944:	1e6b      	subs	r3, r5, #1
 8002946:	b2da      	uxtb	r2, r3
 8002948:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 800294a:	2a00      	cmp	r2, #0
 800294c:	d1f1      	bne.n	8002932 <xQueueReceive+0x19a>
		pxQueue->cRxLock = queueUNLOCKED;
 800294e:	23ff      	movs	r3, #255	@ 0xff
 8002950:	f884 3044 	strb.w	r3, [r4, #68]	@ 0x44
	taskEXIT_CRITICAL();
 8002954:	f001 fd00 	bl	8004358 <vPortExitCritical>
			( void ) xTaskResumeAll();
 8002958:	f000 ff4a 	bl	80037f0 <xTaskResumeAll>
	taskENTER_CRITICAL();
 800295c:	f001 fcda 	bl	8004314 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 8002960:	6ba5      	ldr	r5, [r4, #56]	@ 0x38
 8002962:	b155      	cbz	r5, 800297a <xQueueReceive+0x1e2>
	taskEXIT_CRITICAL();
 8002964:	f001 fcf8 	bl	8004358 <vPortExitCritical>
		taskENTER_CRITICAL();
 8002968:	f001 fcd4 	bl	8004314 <vPortEnterCritical>
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 800296c:	6ba5      	ldr	r5, [r4, #56]	@ 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 800296e:	2d00      	cmp	r5, #0
 8002970:	d178      	bne.n	8002a64 <xQueueReceive+0x2cc>
				if( xTicksToWait == ( TickType_t ) 0 )
 8002972:	9b03      	ldr	r3, [sp, #12]
 8002974:	2b00      	cmp	r3, #0
 8002976:	f47f af2f 	bne.w	80027d8 <xQueueReceive+0x40>
					taskEXIT_CRITICAL();
 800297a:	f001 fced 	bl	8004358 <vPortExitCritical>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
 800297e:	4620      	mov	r0, r4
 8002980:	f002 fc60 	bl	8005244 <SEGGER_SYSVIEW_ShrinkId>
 8002984:	4604      	mov	r4, r0
 8002986:	2000      	movs	r0, #0
 8002988:	f002 fc5c 	bl	8005244 <SEGGER_SYSVIEW_ShrinkId>
 800298c:	2501      	movs	r5, #1
 800298e:	4602      	mov	r2, r0
 8002990:	4621      	mov	r1, r4
 8002992:	205c      	movs	r0, #92	@ 0x5c
 8002994:	9b03      	ldr	r3, [sp, #12]
 8002996:	9500      	str	r5, [sp, #0]
 8002998:	f002 feb8 	bl	800570c <SEGGER_SYSVIEW_RecordU32x4>
					return errQUEUE_EMPTY;
 800299c:	2000      	movs	r0, #0
}
 800299e:	b007      	add	sp, #28
 80029a0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 80029a4:	f104 0924 	add.w	r9, r4, #36	@ 0x24
	taskEXIT_CRITICAL();
 80029a8:	f001 fcd6 	bl	8004358 <vPortExitCritical>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 80029ac:	4648      	mov	r0, r9
 80029ae:	9903      	ldr	r1, [sp, #12]
 80029b0:	f000 ff9c 	bl	80038ec <vTaskPlaceOnEventList>
	taskENTER_CRITICAL();
 80029b4:	f001 fcae 	bl	8004314 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
 80029b8:	f894 3045 	ldrb.w	r3, [r4, #69]	@ 0x45
 80029bc:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 80029be:	2d00      	cmp	r5, #0
 80029c0:	dc04      	bgt.n	80029cc <xQueueReceive+0x234>
 80029c2:	e011      	b.n	80029e8 <xQueueReceive+0x250>
			--cTxLock;
 80029c4:	1e6b      	subs	r3, r5, #1
 80029c6:	b2da      	uxtb	r2, r3
 80029c8:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 80029ca:	b16a      	cbz	r2, 80029e8 <xQueueReceive+0x250>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 80029cc:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 80029ce:	b15b      	cbz	r3, 80029e8 <xQueueReceive+0x250>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 80029d0:	4648      	mov	r0, r9
 80029d2:	f001 f809 	bl	80039e8 <xTaskRemoveFromEventList>
 80029d6:	2800      	cmp	r0, #0
 80029d8:	d0f4      	beq.n	80029c4 <xQueueReceive+0x22c>
						vTaskMissedYield();
 80029da:	f001 f89b 	bl	8003b14 <vTaskMissedYield>
			--cTxLock;
 80029de:	1e6b      	subs	r3, r5, #1
 80029e0:	b2da      	uxtb	r2, r3
 80029e2:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 80029e4:	2a00      	cmp	r2, #0
 80029e6:	d1f1      	bne.n	80029cc <xQueueReceive+0x234>
		pxQueue->cTxLock = queueUNLOCKED;
 80029e8:	23ff      	movs	r3, #255	@ 0xff
 80029ea:	f884 3045 	strb.w	r3, [r4, #69]	@ 0x45
	taskEXIT_CRITICAL();
 80029ee:	f001 fcb3 	bl	8004358 <vPortExitCritical>
	taskENTER_CRITICAL();
 80029f2:	f001 fc8f 	bl	8004314 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
 80029f6:	f894 3044 	ldrb.w	r3, [r4, #68]	@ 0x44
 80029fa:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 80029fc:	2d00      	cmp	r5, #0
 80029fe:	dd14      	ble.n	8002a2a <xQueueReceive+0x292>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8002a00:	f104 0910 	add.w	r9, r4, #16
 8002a04:	e003      	b.n	8002a0e <xQueueReceive+0x276>
				--cRxLock;
 8002a06:	1e6b      	subs	r3, r5, #1
 8002a08:	b2da      	uxtb	r2, r3
 8002a0a:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8002a0c:	b16a      	cbz	r2, 8002a2a <xQueueReceive+0x292>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8002a0e:	6923      	ldr	r3, [r4, #16]
 8002a10:	b15b      	cbz	r3, 8002a2a <xQueueReceive+0x292>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8002a12:	4648      	mov	r0, r9
 8002a14:	f000 ffe8 	bl	80039e8 <xTaskRemoveFromEventList>
 8002a18:	2800      	cmp	r0, #0
 8002a1a:	d0f4      	beq.n	8002a06 <xQueueReceive+0x26e>
					vTaskMissedYield();
 8002a1c:	f001 f87a 	bl	8003b14 <vTaskMissedYield>
				--cRxLock;
 8002a20:	1e6b      	subs	r3, r5, #1
 8002a22:	b2da      	uxtb	r2, r3
 8002a24:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8002a26:	2a00      	cmp	r2, #0
 8002a28:	d1f1      	bne.n	8002a0e <xQueueReceive+0x276>
		pxQueue->cRxLock = queueUNLOCKED;
 8002a2a:	23ff      	movs	r3, #255	@ 0xff
 8002a2c:	f884 3044 	strb.w	r3, [r4, #68]	@ 0x44
	taskEXIT_CRITICAL();
 8002a30:	f001 fc92 	bl	8004358 <vPortExitCritical>
				if( xTaskResumeAll() == pdFALSE )
 8002a34:	f000 fedc 	bl	80037f0 <xTaskResumeAll>
 8002a38:	2800      	cmp	r0, #0
 8002a3a:	d195      	bne.n	8002968 <xQueueReceive+0x1d0>
					portYIELD_WITHIN_API();
 8002a3c:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 8002a40:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 8002a44:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 8002a48:	f3bf 8f4f 	dsb	sy
 8002a4c:	f3bf 8f6f 	isb	sy
 8002a50:	e78a      	b.n	8002968 <xQueueReceive+0x1d0>
 8002a52:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8002a56:	f383 8811 	msr	BASEPRI, r3
 8002a5a:	f3bf 8f6f 	isb	sy
 8002a5e:	f3bf 8f4f 	dsb	sy
	configASSERT( ( pxQueue ) );
 8002a62:	e7fe      	b.n	8002a62 <xQueueReceive+0x2ca>
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 8002a64:	6c22      	ldr	r2, [r4, #64]	@ 0x40
 8002a66:	b15a      	cbz	r2, 8002a80 <xQueueReceive+0x2e8>
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 8002a68:	68e1      	ldr	r1, [r4, #12]
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 8002a6a:	68a3      	ldr	r3, [r4, #8]
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 8002a6c:	4411      	add	r1, r2
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 8002a6e:	4299      	cmp	r1, r3
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 8002a70:	60e1      	str	r1, [r4, #12]
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
 8002a72:	bf28      	it	cs
 8002a74:	6821      	ldrcs	r1, [r4, #0]
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 8002a76:	4638      	mov	r0, r7
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
 8002a78:	bf28      	it	cs
 8002a7a:	60e1      	strcs	r1, [r4, #12]
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 8002a7c:	f004 f962 	bl	8006d44 <memcpy>
				traceQUEUE_RECEIVE( pxQueue );
 8002a80:	4620      	mov	r0, r4
 8002a82:	f002 fbdf 	bl	8005244 <SEGGER_SYSVIEW_ShrinkId>
 8002a86:	4606      	mov	r6, r0
 8002a88:	2000      	movs	r0, #0
 8002a8a:	f002 fbdb 	bl	8005244 <SEGGER_SYSVIEW_ShrinkId>
 8002a8e:	2301      	movs	r3, #1
 8002a90:	4602      	mov	r2, r0
 8002a92:	9300      	str	r3, [sp, #0]
 8002a94:	205c      	movs	r0, #92	@ 0x5c
 8002a96:	9b03      	ldr	r3, [sp, #12]
 8002a98:	4631      	mov	r1, r6
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 8002a9a:	3d01      	subs	r5, #1
				traceQUEUE_RECEIVE( pxQueue );
 8002a9c:	f002 fe36 	bl	800570c <SEGGER_SYSVIEW_RecordU32x4>
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 8002aa0:	63a5      	str	r5, [r4, #56]	@ 0x38
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8002aa2:	6923      	ldr	r3, [r4, #16]
 8002aa4:	b91b      	cbnz	r3, 8002aae <xQueueReceive+0x316>
				taskEXIT_CRITICAL();
 8002aa6:	f001 fc57 	bl	8004358 <vPortExitCritical>
				return pdPASS;
 8002aaa:	2001      	movs	r0, #1
 8002aac:	e777      	b.n	800299e <xQueueReceive+0x206>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8002aae:	f104 0010 	add.w	r0, r4, #16
 8002ab2:	f000 ff99 	bl	80039e8 <xTaskRemoveFromEventList>
 8002ab6:	2800      	cmp	r0, #0
 8002ab8:	d0f5      	beq.n	8002aa6 <xQueueReceive+0x30e>
						queueYIELD_IF_USING_PREEMPTION();
 8002aba:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 8002abe:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 8002ac2:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 8002ac6:	f3bf 8f4f 	dsb	sy
 8002aca:	f3bf 8f6f 	isb	sy
 8002ace:	e7ea      	b.n	8002aa6 <xQueueReceive+0x30e>

08002ad0 <xQueueSemaphoreTake>:
{
 8002ad0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8002ad4:	b087      	sub	sp, #28
 8002ad6:	9103      	str	r1, [sp, #12]
	configASSERT( ( pxQueue ) );
 8002ad8:	2800      	cmp	r0, #0
 8002ada:	d05d      	beq.n	8002b98 <xQueueSemaphoreTake+0xc8>
	configASSERT( pxQueue->uxItemSize == 0 );
 8002adc:	6c03      	ldr	r3, [r0, #64]	@ 0x40
 8002ade:	4604      	mov	r4, r0
 8002ae0:	b143      	cbz	r3, 8002af4 <xQueueSemaphoreTake+0x24>
 8002ae2:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8002ae6:	f383 8811 	msr	BASEPRI, r3
 8002aea:	f3bf 8f6f 	isb	sy
 8002aee:	f3bf 8f4f 	dsb	sy
 8002af2:	e7fe      	b.n	8002af2 <xQueueSemaphoreTake+0x22>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8002af4:	f001 f814 	bl	8003b20 <xTaskGetSchedulerState>
 8002af8:	2800      	cmp	r0, #0
 8002afa:	d056      	beq.n	8002baa <xQueueSemaphoreTake+0xda>
		taskENTER_CRITICAL();
 8002afc:	f001 fc0a 	bl	8004314 <vPortEnterCritical>
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
 8002b00:	6ba5      	ldr	r5, [r4, #56]	@ 0x38
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
 8002b02:	2d00      	cmp	r5, #0
 8002b04:	f040 8161 	bne.w	8002dca <xQueueSemaphoreTake+0x2fa>
				if( xTicksToWait == ( TickType_t ) 0 )
 8002b08:	9b03      	ldr	r3, [sp, #12]
 8002b0a:	2b00      	cmp	r3, #0
 8002b0c:	f000 8151 	beq.w	8002db2 <xQueueSemaphoreTake+0x2e2>
					vTaskInternalSetTimeOutState( &xTimeOut );
 8002b10:	a804      	add	r0, sp, #16
 8002b12:	f000 ffb3 	bl	8003a7c <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 8002b16:	462f      	mov	r7, r5
		prvLockQueue( pxQueue );
 8002b18:	46a8      	mov	r8, r5
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8002b1a:	f104 0624 	add.w	r6, r4, #36	@ 0x24
		taskEXIT_CRITICAL();
 8002b1e:	f001 fc1b 	bl	8004358 <vPortExitCritical>
		vTaskSuspendAll();
 8002b22:	f000 fe5d 	bl	80037e0 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 8002b26:	f001 fbf5 	bl	8004314 <vPortEnterCritical>
 8002b2a:	f894 3044 	ldrb.w	r3, [r4, #68]	@ 0x44
 8002b2e:	2bff      	cmp	r3, #255	@ 0xff
 8002b30:	bf08      	it	eq
 8002b32:	f884 8044 	strbeq.w	r8, [r4, #68]	@ 0x44
 8002b36:	f894 3045 	ldrb.w	r3, [r4, #69]	@ 0x45
 8002b3a:	2bff      	cmp	r3, #255	@ 0xff
 8002b3c:	bf08      	it	eq
 8002b3e:	f884 8045 	strbeq.w	r8, [r4, #69]	@ 0x45
 8002b42:	f001 fc09 	bl	8004358 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 8002b46:	a903      	add	r1, sp, #12
 8002b48:	a804      	add	r0, sp, #16
 8002b4a:	f000 ffa3 	bl	8003a94 <xTaskCheckForTimeOut>
 8002b4e:	2800      	cmp	r0, #0
 8002b50:	d137      	bne.n	8002bc2 <xQueueSemaphoreTake+0xf2>
	taskENTER_CRITICAL();
 8002b52:	f001 fbdf 	bl	8004314 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 8002b56:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
 8002b58:	2b00      	cmp	r3, #0
 8002b5a:	f000 80ca 	beq.w	8002cf2 <xQueueSemaphoreTake+0x222>
	taskEXIT_CRITICAL();
 8002b5e:	f001 fbfb 	bl	8004358 <vPortExitCritical>
	taskENTER_CRITICAL();
 8002b62:	f001 fbd7 	bl	8004314 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
 8002b66:	f894 3045 	ldrb.w	r3, [r4, #69]	@ 0x45
 8002b6a:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8002b6c:	2d00      	cmp	r5, #0
 8002b6e:	f340 8088 	ble.w	8002c82 <xQueueSemaphoreTake+0x1b2>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8002b72:	f104 0924 	add.w	r9, r4, #36	@ 0x24
 8002b76:	e004      	b.n	8002b82 <xQueueSemaphoreTake+0xb2>
			--cTxLock;
 8002b78:	1e6b      	subs	r3, r5, #1
 8002b7a:	b2da      	uxtb	r2, r3
 8002b7c:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8002b7e:	2a00      	cmp	r2, #0
 8002b80:	d07f      	beq.n	8002c82 <xQueueSemaphoreTake+0x1b2>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8002b82:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 8002b84:	2b00      	cmp	r3, #0
 8002b86:	d07c      	beq.n	8002c82 <xQueueSemaphoreTake+0x1b2>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8002b88:	4648      	mov	r0, r9
 8002b8a:	f000 ff2d 	bl	80039e8 <xTaskRemoveFromEventList>
 8002b8e:	2800      	cmp	r0, #0
 8002b90:	d0f2      	beq.n	8002b78 <xQueueSemaphoreTake+0xa8>
						vTaskMissedYield();
 8002b92:	f000 ffbf 	bl	8003b14 <vTaskMissedYield>
 8002b96:	e7ef      	b.n	8002b78 <xQueueSemaphoreTake+0xa8>
 8002b98:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8002b9c:	f383 8811 	msr	BASEPRI, r3
 8002ba0:	f3bf 8f6f 	isb	sy
 8002ba4:	f3bf 8f4f 	dsb	sy
	configASSERT( ( pxQueue ) );
 8002ba8:	e7fe      	b.n	8002ba8 <xQueueSemaphoreTake+0xd8>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8002baa:	9b03      	ldr	r3, [sp, #12]
 8002bac:	2b00      	cmp	r3, #0
 8002bae:	d0a5      	beq.n	8002afc <xQueueSemaphoreTake+0x2c>
 8002bb0:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8002bb4:	f383 8811 	msr	BASEPRI, r3
 8002bb8:	f3bf 8f6f 	isb	sy
 8002bbc:	f3bf 8f4f 	dsb	sy
 8002bc0:	e7fe      	b.n	8002bc0 <xQueueSemaphoreTake+0xf0>
	taskENTER_CRITICAL();
 8002bc2:	f001 fba7 	bl	8004314 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
 8002bc6:	f894 3045 	ldrb.w	r3, [r4, #69]	@ 0x45
 8002bca:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8002bcc:	2d00      	cmp	r5, #0
 8002bce:	dc04      	bgt.n	8002bda <xQueueSemaphoreTake+0x10a>
 8002bd0:	e011      	b.n	8002bf6 <xQueueSemaphoreTake+0x126>
			--cTxLock;
 8002bd2:	1e6b      	subs	r3, r5, #1
 8002bd4:	b2da      	uxtb	r2, r3
 8002bd6:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8002bd8:	b16a      	cbz	r2, 8002bf6 <xQueueSemaphoreTake+0x126>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8002bda:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 8002bdc:	b15b      	cbz	r3, 8002bf6 <xQueueSemaphoreTake+0x126>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8002bde:	4630      	mov	r0, r6
 8002be0:	f000 ff02 	bl	80039e8 <xTaskRemoveFromEventList>
 8002be4:	2800      	cmp	r0, #0
 8002be6:	d0f4      	beq.n	8002bd2 <xQueueSemaphoreTake+0x102>
						vTaskMissedYield();
 8002be8:	f000 ff94 	bl	8003b14 <vTaskMissedYield>
			--cTxLock;
 8002bec:	1e6b      	subs	r3, r5, #1
 8002bee:	b2da      	uxtb	r2, r3
 8002bf0:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8002bf2:	2a00      	cmp	r2, #0
 8002bf4:	d1f1      	bne.n	8002bda <xQueueSemaphoreTake+0x10a>
		pxQueue->cTxLock = queueUNLOCKED;
 8002bf6:	23ff      	movs	r3, #255	@ 0xff
 8002bf8:	f884 3045 	strb.w	r3, [r4, #69]	@ 0x45
	taskEXIT_CRITICAL();
 8002bfc:	f001 fbac 	bl	8004358 <vPortExitCritical>
	taskENTER_CRITICAL();
 8002c00:	f001 fb88 	bl	8004314 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
 8002c04:	f894 3044 	ldrb.w	r3, [r4, #68]	@ 0x44
 8002c08:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8002c0a:	2d00      	cmp	r5, #0
 8002c0c:	dd14      	ble.n	8002c38 <xQueueSemaphoreTake+0x168>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8002c0e:	f104 0910 	add.w	r9, r4, #16
 8002c12:	e003      	b.n	8002c1c <xQueueSemaphoreTake+0x14c>
				--cRxLock;
 8002c14:	1e6b      	subs	r3, r5, #1
 8002c16:	b2da      	uxtb	r2, r3
 8002c18:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8002c1a:	b16a      	cbz	r2, 8002c38 <xQueueSemaphoreTake+0x168>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8002c1c:	6923      	ldr	r3, [r4, #16]
 8002c1e:	b15b      	cbz	r3, 8002c38 <xQueueSemaphoreTake+0x168>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8002c20:	4648      	mov	r0, r9
 8002c22:	f000 fee1 	bl	80039e8 <xTaskRemoveFromEventList>
 8002c26:	2800      	cmp	r0, #0
 8002c28:	d0f4      	beq.n	8002c14 <xQueueSemaphoreTake+0x144>
					vTaskMissedYield();
 8002c2a:	f000 ff73 	bl	8003b14 <vTaskMissedYield>
				--cRxLock;
 8002c2e:	1e6b      	subs	r3, r5, #1
 8002c30:	b2da      	uxtb	r2, r3
 8002c32:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8002c34:	2a00      	cmp	r2, #0
 8002c36:	d1f1      	bne.n	8002c1c <xQueueSemaphoreTake+0x14c>
		pxQueue->cRxLock = queueUNLOCKED;
 8002c38:	23ff      	movs	r3, #255	@ 0xff
 8002c3a:	f884 3044 	strb.w	r3, [r4, #68]	@ 0x44
	taskEXIT_CRITICAL();
 8002c3e:	f001 fb8b 	bl	8004358 <vPortExitCritical>
			( void ) xTaskResumeAll();
 8002c42:	f000 fdd5 	bl	80037f0 <xTaskResumeAll>
	taskENTER_CRITICAL();
 8002c46:	f001 fb65 	bl	8004314 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 8002c4a:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
 8002c4c:	2b00      	cmp	r3, #0
 8002c4e:	f040 80a2 	bne.w	8002d96 <xQueueSemaphoreTake+0x2c6>
	taskEXIT_CRITICAL();
 8002c52:	f001 fb81 	bl	8004358 <vPortExitCritical>
					if( xInheritanceOccurred != pdFALSE )
 8002c56:	2f00      	cmp	r7, #0
 8002c58:	f040 80a0 	bne.w	8002d9c <xQueueSemaphoreTake+0x2cc>
				traceQUEUE_RECEIVE_FAILED( pxQueue );
 8002c5c:	4620      	mov	r0, r4
 8002c5e:	f002 faf1 	bl	8005244 <SEGGER_SYSVIEW_ShrinkId>
 8002c62:	4604      	mov	r4, r0
 8002c64:	2000      	movs	r0, #0
 8002c66:	f002 faed 	bl	8005244 <SEGGER_SYSVIEW_ShrinkId>
 8002c6a:	2501      	movs	r5, #1
 8002c6c:	4602      	mov	r2, r0
 8002c6e:	4621      	mov	r1, r4
 8002c70:	205c      	movs	r0, #92	@ 0x5c
 8002c72:	9b03      	ldr	r3, [sp, #12]
 8002c74:	9500      	str	r5, [sp, #0]
 8002c76:	f002 fd49 	bl	800570c <SEGGER_SYSVIEW_RecordU32x4>
					return errQUEUE_EMPTY;
 8002c7a:	2000      	movs	r0, #0
}
 8002c7c:	b007      	add	sp, #28
 8002c7e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		pxQueue->cTxLock = queueUNLOCKED;
 8002c82:	23ff      	movs	r3, #255	@ 0xff
 8002c84:	f884 3045 	strb.w	r3, [r4, #69]	@ 0x45
	taskEXIT_CRITICAL();
 8002c88:	f001 fb66 	bl	8004358 <vPortExitCritical>
	taskENTER_CRITICAL();
 8002c8c:	f001 fb42 	bl	8004314 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
 8002c90:	f894 3044 	ldrb.w	r3, [r4, #68]	@ 0x44
 8002c94:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8002c96:	2d00      	cmp	r5, #0
 8002c98:	dd10      	ble.n	8002cbc <xQueueSemaphoreTake+0x1ec>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8002c9a:	f104 0910 	add.w	r9, r4, #16
 8002c9e:	e003      	b.n	8002ca8 <xQueueSemaphoreTake+0x1d8>
				--cRxLock;
 8002ca0:	1e6b      	subs	r3, r5, #1
 8002ca2:	b2da      	uxtb	r2, r3
 8002ca4:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8002ca6:	b14a      	cbz	r2, 8002cbc <xQueueSemaphoreTake+0x1ec>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8002ca8:	6923      	ldr	r3, [r4, #16]
 8002caa:	b13b      	cbz	r3, 8002cbc <xQueueSemaphoreTake+0x1ec>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8002cac:	4648      	mov	r0, r9
 8002cae:	f000 fe9b 	bl	80039e8 <xTaskRemoveFromEventList>
 8002cb2:	2800      	cmp	r0, #0
 8002cb4:	d0f4      	beq.n	8002ca0 <xQueueSemaphoreTake+0x1d0>
					vTaskMissedYield();
 8002cb6:	f000 ff2d 	bl	8003b14 <vTaskMissedYield>
 8002cba:	e7f1      	b.n	8002ca0 <xQueueSemaphoreTake+0x1d0>
		pxQueue->cRxLock = queueUNLOCKED;
 8002cbc:	23ff      	movs	r3, #255	@ 0xff
 8002cbe:	f884 3044 	strb.w	r3, [r4, #68]	@ 0x44
	taskEXIT_CRITICAL();
 8002cc2:	f001 fb49 	bl	8004358 <vPortExitCritical>
				( void ) xTaskResumeAll();
 8002cc6:	f000 fd93 	bl	80037f0 <xTaskResumeAll>
		taskENTER_CRITICAL();
 8002cca:	f001 fb23 	bl	8004314 <vPortEnterCritical>
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
 8002cce:	6ba5      	ldr	r5, [r4, #56]	@ 0x38
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
 8002cd0:	2d00      	cmp	r5, #0
 8002cd2:	d17a      	bne.n	8002dca <xQueueSemaphoreTake+0x2fa>
				if( xTicksToWait == ( TickType_t ) 0 )
 8002cd4:	9b03      	ldr	r3, [sp, #12]
 8002cd6:	2b00      	cmp	r3, #0
 8002cd8:	f47f af21 	bne.w	8002b1e <xQueueSemaphoreTake+0x4e>
						configASSERT( xInheritanceOccurred == pdFALSE );
 8002cdc:	2f00      	cmp	r7, #0
 8002cde:	d068      	beq.n	8002db2 <xQueueSemaphoreTake+0x2e2>
 8002ce0:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8002ce4:	f383 8811 	msr	BASEPRI, r3
 8002ce8:	f3bf 8f6f 	isb	sy
 8002cec:	f3bf 8f4f 	dsb	sy
 8002cf0:	e7fe      	b.n	8002cf0 <xQueueSemaphoreTake+0x220>
	taskEXIT_CRITICAL();
 8002cf2:	f001 fb31 	bl	8004358 <vPortExitCritical>
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8002cf6:	6823      	ldr	r3, [r4, #0]
 8002cf8:	2b00      	cmp	r3, #0
 8002cfa:	d05d      	beq.n	8002db8 <xQueueSemaphoreTake+0x2e8>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 8002cfc:	f104 0924 	add.w	r9, r4, #36	@ 0x24
 8002d00:	4648      	mov	r0, r9
 8002d02:	9903      	ldr	r1, [sp, #12]
 8002d04:	f000 fdf2 	bl	80038ec <vTaskPlaceOnEventList>
	taskENTER_CRITICAL();
 8002d08:	f001 fb04 	bl	8004314 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
 8002d0c:	f894 3045 	ldrb.w	r3, [r4, #69]	@ 0x45
 8002d10:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8002d12:	2d00      	cmp	r5, #0
 8002d14:	dc04      	bgt.n	8002d20 <xQueueSemaphoreTake+0x250>
 8002d16:	e00d      	b.n	8002d34 <xQueueSemaphoreTake+0x264>
			--cTxLock;
 8002d18:	1e6b      	subs	r3, r5, #1
 8002d1a:	b2da      	uxtb	r2, r3
 8002d1c:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8002d1e:	b14a      	cbz	r2, 8002d34 <xQueueSemaphoreTake+0x264>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8002d20:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 8002d22:	b13b      	cbz	r3, 8002d34 <xQueueSemaphoreTake+0x264>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8002d24:	4648      	mov	r0, r9
 8002d26:	f000 fe5f 	bl	80039e8 <xTaskRemoveFromEventList>
 8002d2a:	2800      	cmp	r0, #0
 8002d2c:	d0f4      	beq.n	8002d18 <xQueueSemaphoreTake+0x248>
						vTaskMissedYield();
 8002d2e:	f000 fef1 	bl	8003b14 <vTaskMissedYield>
 8002d32:	e7f1      	b.n	8002d18 <xQueueSemaphoreTake+0x248>
		pxQueue->cTxLock = queueUNLOCKED;
 8002d34:	23ff      	movs	r3, #255	@ 0xff
 8002d36:	f884 3045 	strb.w	r3, [r4, #69]	@ 0x45
	taskEXIT_CRITICAL();
 8002d3a:	f001 fb0d 	bl	8004358 <vPortExitCritical>
	taskENTER_CRITICAL();
 8002d3e:	f001 fae9 	bl	8004314 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
 8002d42:	f894 3044 	ldrb.w	r3, [r4, #68]	@ 0x44
 8002d46:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8002d48:	2d00      	cmp	r5, #0
 8002d4a:	dd10      	ble.n	8002d6e <xQueueSemaphoreTake+0x29e>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8002d4c:	f104 0910 	add.w	r9, r4, #16
 8002d50:	e003      	b.n	8002d5a <xQueueSemaphoreTake+0x28a>
				--cRxLock;
 8002d52:	1e6b      	subs	r3, r5, #1
 8002d54:	b2da      	uxtb	r2, r3
 8002d56:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8002d58:	b14a      	cbz	r2, 8002d6e <xQueueSemaphoreTake+0x29e>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8002d5a:	6923      	ldr	r3, [r4, #16]
 8002d5c:	b13b      	cbz	r3, 8002d6e <xQueueSemaphoreTake+0x29e>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8002d5e:	4648      	mov	r0, r9
 8002d60:	f000 fe42 	bl	80039e8 <xTaskRemoveFromEventList>
 8002d64:	2800      	cmp	r0, #0
 8002d66:	d0f4      	beq.n	8002d52 <xQueueSemaphoreTake+0x282>
					vTaskMissedYield();
 8002d68:	f000 fed4 	bl	8003b14 <vTaskMissedYield>
 8002d6c:	e7f1      	b.n	8002d52 <xQueueSemaphoreTake+0x282>
		pxQueue->cRxLock = queueUNLOCKED;
 8002d6e:	23ff      	movs	r3, #255	@ 0xff
 8002d70:	f884 3044 	strb.w	r3, [r4, #68]	@ 0x44
	taskEXIT_CRITICAL();
 8002d74:	f001 faf0 	bl	8004358 <vPortExitCritical>
				if( xTaskResumeAll() == pdFALSE )
 8002d78:	f000 fd3a 	bl	80037f0 <xTaskResumeAll>
 8002d7c:	2800      	cmp	r0, #0
 8002d7e:	d1a4      	bne.n	8002cca <xQueueSemaphoreTake+0x1fa>
					portYIELD_WITHIN_API();
 8002d80:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 8002d84:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 8002d88:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 8002d8c:	f3bf 8f4f 	dsb	sy
 8002d90:	f3bf 8f6f 	isb	sy
 8002d94:	e799      	b.n	8002cca <xQueueSemaphoreTake+0x1fa>
	taskEXIT_CRITICAL();
 8002d96:	f001 fadf 	bl	8004358 <vPortExitCritical>
	return xReturn;
 8002d9a:	e796      	b.n	8002cca <xQueueSemaphoreTake+0x1fa>
						taskENTER_CRITICAL();
 8002d9c:	f001 faba 	bl	8004314 <vPortEnterCritical>
		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
 8002da0:	6a61      	ldr	r1, [r4, #36]	@ 0x24
 8002da2:	b119      	cbz	r1, 8002dac <xQueueSemaphoreTake+0x2dc>
			uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
 8002da4:	6b23      	ldr	r3, [r4, #48]	@ 0x30
 8002da6:	6819      	ldr	r1, [r3, #0]
 8002da8:	f1c1 0107 	rsb	r1, r1, #7
							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
 8002dac:	68a0      	ldr	r0, [r4, #8]
 8002dae:	f000 ff77 	bl	8003ca0 <vTaskPriorityDisinheritAfterTimeout>
						taskEXIT_CRITICAL();
 8002db2:	f001 fad1 	bl	8004358 <vPortExitCritical>
 8002db6:	e751      	b.n	8002c5c <xQueueSemaphoreTake+0x18c>
						taskENTER_CRITICAL();
 8002db8:	f001 faac 	bl	8004314 <vPortEnterCritical>
							xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
 8002dbc:	68a0      	ldr	r0, [r4, #8]
 8002dbe:	f000 febf 	bl	8003b40 <xTaskPriorityInherit>
 8002dc2:	4607      	mov	r7, r0
						taskEXIT_CRITICAL();
 8002dc4:	f001 fac8 	bl	8004358 <vPortExitCritical>
 8002dc8:	e798      	b.n	8002cfc <xQueueSemaphoreTake+0x22c>
				traceQUEUE_RECEIVE( pxQueue );
 8002dca:	4620      	mov	r0, r4
 8002dcc:	f002 fa3a 	bl	8005244 <SEGGER_SYSVIEW_ShrinkId>
 8002dd0:	4606      	mov	r6, r0
 8002dd2:	2000      	movs	r0, #0
 8002dd4:	f002 fa36 	bl	8005244 <SEGGER_SYSVIEW_ShrinkId>
 8002dd8:	2301      	movs	r3, #1
 8002dda:	4602      	mov	r2, r0
 8002ddc:	9300      	str	r3, [sp, #0]
 8002dde:	205c      	movs	r0, #92	@ 0x5c
 8002de0:	9b03      	ldr	r3, [sp, #12]
 8002de2:	4631      	mov	r1, r6
 8002de4:	f002 fc92 	bl	800570c <SEGGER_SYSVIEW_RecordU32x4>
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8002de8:	6823      	ldr	r3, [r4, #0]
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
 8002dea:	3d01      	subs	r5, #1
 8002dec:	63a5      	str	r5, [r4, #56]	@ 0x38
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8002dee:	b12b      	cbz	r3, 8002dfc <xQueueSemaphoreTake+0x32c>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8002df0:	6923      	ldr	r3, [r4, #16]
 8002df2:	b93b      	cbnz	r3, 8002e04 <xQueueSemaphoreTake+0x334>
				taskEXIT_CRITICAL();
 8002df4:	f001 fab0 	bl	8004358 <vPortExitCritical>
				return pdPASS;
 8002df8:	2001      	movs	r0, #1
 8002dfa:	e73f      	b.n	8002c7c <xQueueSemaphoreTake+0x1ac>
						pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
 8002dfc:	f000 ffb2 	bl	8003d64 <pvTaskIncrementMutexHeldCount>
 8002e00:	60a0      	str	r0, [r4, #8]
 8002e02:	e7f5      	b.n	8002df0 <xQueueSemaphoreTake+0x320>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8002e04:	f104 0010 	add.w	r0, r4, #16
 8002e08:	f000 fdee 	bl	80039e8 <xTaskRemoveFromEventList>
 8002e0c:	2800      	cmp	r0, #0
 8002e0e:	d0f1      	beq.n	8002df4 <xQueueSemaphoreTake+0x324>
						queueYIELD_IF_USING_PREEMPTION();
 8002e10:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 8002e14:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 8002e18:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 8002e1c:	f3bf 8f4f 	dsb	sy
 8002e20:	f3bf 8f6f 	isb	sy
 8002e24:	e7e6      	b.n	8002df4 <xQueueSemaphoreTake+0x324>
 8002e26:	bf00      	nop

08002e28 <vQueueAddToRegistry>:
/*-----------------------------------------------------------*/

#if ( configQUEUE_REGISTRY_SIZE > 0 )

	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
 8002e28:	b538      	push	{r3, r4, r5, lr}

		/* See if there is an empty space in the registry.  A NULL name denotes
		a free slot. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
		{
			if( xQueueRegistry[ ux ].pcQueueName == NULL )
 8002e2a:	4b16      	ldr	r3, [pc, #88]	@ (8002e84 <vQueueAddToRegistry+0x5c>)
	{
 8002e2c:	460d      	mov	r5, r1
			if( xQueueRegistry[ ux ].pcQueueName == NULL )
 8002e2e:	681c      	ldr	r4, [r3, #0]
 8002e30:	b184      	cbz	r4, 8002e54 <vQueueAddToRegistry+0x2c>
 8002e32:	689a      	ldr	r2, [r3, #8]
 8002e34:	b16a      	cbz	r2, 8002e52 <vQueueAddToRegistry+0x2a>
 8002e36:	691a      	ldr	r2, [r3, #16]
 8002e38:	b1d2      	cbz	r2, 8002e70 <vQueueAddToRegistry+0x48>
 8002e3a:	699a      	ldr	r2, [r3, #24]
 8002e3c:	b1d2      	cbz	r2, 8002e74 <vQueueAddToRegistry+0x4c>
 8002e3e:	6a1a      	ldr	r2, [r3, #32]
 8002e40:	b1d2      	cbz	r2, 8002e78 <vQueueAddToRegistry+0x50>
 8002e42:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 8002e44:	b1d2      	cbz	r2, 8002e7c <vQueueAddToRegistry+0x54>
 8002e46:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8002e48:	b1d2      	cbz	r2, 8002e80 <vQueueAddToRegistry+0x58>
 8002e4a:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
 8002e4c:	2407      	movs	r4, #7
 8002e4e:	b10a      	cbz	r2, 8002e54 <vQueueAddToRegistry+0x2c>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
 8002e50:	bd38      	pop	{r3, r4, r5, pc}
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 8002e52:	2401      	movs	r4, #1
				xQueueRegistry[ ux ].xHandle = xQueue;
 8002e54:	eb03 02c4 	add.w	r2, r3, r4, lsl #3
				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
 8002e58:	f843 5034 	str.w	r5, [r3, r4, lsl #3]
				xQueueRegistry[ ux ].xHandle = xQueue;
 8002e5c:	6050      	str	r0, [r2, #4]
				traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
 8002e5e:	f002 f9f1 	bl	8005244 <SEGGER_SYSVIEW_ShrinkId>
 8002e62:	462a      	mov	r2, r5
	}
 8002e64:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
				traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
 8002e68:	4601      	mov	r1, r0
 8002e6a:	2071      	movs	r0, #113	@ 0x71
 8002e6c:	f002 bbe8 	b.w	8005640 <SEGGER_SYSVIEW_RecordU32x2>
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 8002e70:	2402      	movs	r4, #2
 8002e72:	e7ef      	b.n	8002e54 <vQueueAddToRegistry+0x2c>
 8002e74:	2403      	movs	r4, #3
 8002e76:	e7ed      	b.n	8002e54 <vQueueAddToRegistry+0x2c>
 8002e78:	2404      	movs	r4, #4
 8002e7a:	e7eb      	b.n	8002e54 <vQueueAddToRegistry+0x2c>
 8002e7c:	2405      	movs	r4, #5
 8002e7e:	e7e9      	b.n	8002e54 <vQueueAddToRegistry+0x2c>
 8002e80:	2406      	movs	r4, #6
 8002e82:	e7e7      	b.n	8002e54 <vQueueAddToRegistry+0x2c>
 8002e84:	20000938 	.word	0x20000938

08002e88 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
 8002e88:	b570      	push	{r4, r5, r6, lr}
 8002e8a:	4605      	mov	r5, r0
 8002e8c:	460e      	mov	r6, r1
 8002e8e:	4614      	mov	r4, r2
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
 8002e90:	f001 fa40 	bl	8004314 <vPortEnterCritical>
 8002e94:	f895 3044 	ldrb.w	r3, [r5, #68]	@ 0x44
 8002e98:	2bff      	cmp	r3, #255	@ 0xff
 8002e9a:	bf04      	itt	eq
 8002e9c:	2300      	moveq	r3, #0
 8002e9e:	f885 3044 	strbeq.w	r3, [r5, #68]	@ 0x44
 8002ea2:	f895 3045 	ldrb.w	r3, [r5, #69]	@ 0x45
 8002ea6:	2bff      	cmp	r3, #255	@ 0xff
 8002ea8:	bf04      	itt	eq
 8002eaa:	2300      	moveq	r3, #0
 8002eac:	f885 3045 	strbeq.w	r3, [r5, #69]	@ 0x45
 8002eb0:	f001 fa52 	bl	8004358 <vPortExitCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
 8002eb4:	6bab      	ldr	r3, [r5, #56]	@ 0x38
 8002eb6:	2b00      	cmp	r3, #0
 8002eb8:	d043      	beq.n	8002f42 <vQueueWaitForMessageRestricted+0xba>
	taskENTER_CRITICAL();
 8002eba:	f001 fa2b 	bl	8004314 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
 8002ebe:	f895 3045 	ldrb.w	r3, [r5, #69]	@ 0x45
 8002ec2:	b25c      	sxtb	r4, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8002ec4:	2c00      	cmp	r4, #0
 8002ec6:	dd14      	ble.n	8002ef2 <vQueueWaitForMessageRestricted+0x6a>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8002ec8:	f105 0624 	add.w	r6, r5, #36	@ 0x24
 8002ecc:	e003      	b.n	8002ed6 <vQueueWaitForMessageRestricted+0x4e>
			--cTxLock;
 8002ece:	1e63      	subs	r3, r4, #1
 8002ed0:	b2da      	uxtb	r2, r3
 8002ed2:	b25c      	sxtb	r4, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8002ed4:	b16a      	cbz	r2, 8002ef2 <vQueueWaitForMessageRestricted+0x6a>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8002ed6:	6a6b      	ldr	r3, [r5, #36]	@ 0x24
 8002ed8:	b15b      	cbz	r3, 8002ef2 <vQueueWaitForMessageRestricted+0x6a>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8002eda:	4630      	mov	r0, r6
 8002edc:	f000 fd84 	bl	80039e8 <xTaskRemoveFromEventList>
 8002ee0:	2800      	cmp	r0, #0
 8002ee2:	d0f4      	beq.n	8002ece <vQueueWaitForMessageRestricted+0x46>
						vTaskMissedYield();
 8002ee4:	f000 fe16 	bl	8003b14 <vTaskMissedYield>
			--cTxLock;
 8002ee8:	1e63      	subs	r3, r4, #1
 8002eea:	b2da      	uxtb	r2, r3
 8002eec:	b25c      	sxtb	r4, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8002eee:	2a00      	cmp	r2, #0
 8002ef0:	d1f1      	bne.n	8002ed6 <vQueueWaitForMessageRestricted+0x4e>
		pxQueue->cTxLock = queueUNLOCKED;
 8002ef2:	23ff      	movs	r3, #255	@ 0xff
 8002ef4:	f885 3045 	strb.w	r3, [r5, #69]	@ 0x45
	taskEXIT_CRITICAL();
 8002ef8:	f001 fa2e 	bl	8004358 <vPortExitCritical>
	taskENTER_CRITICAL();
 8002efc:	f001 fa0a 	bl	8004314 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
 8002f00:	f895 3044 	ldrb.w	r3, [r5, #68]	@ 0x44
 8002f04:	b25c      	sxtb	r4, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8002f06:	2c00      	cmp	r4, #0
 8002f08:	dd14      	ble.n	8002f34 <vQueueWaitForMessageRestricted+0xac>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8002f0a:	f105 0610 	add.w	r6, r5, #16
 8002f0e:	e003      	b.n	8002f18 <vQueueWaitForMessageRestricted+0x90>
				--cRxLock;
 8002f10:	1e63      	subs	r3, r4, #1
 8002f12:	b2da      	uxtb	r2, r3
 8002f14:	b25c      	sxtb	r4, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8002f16:	b16a      	cbz	r2, 8002f34 <vQueueWaitForMessageRestricted+0xac>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8002f18:	692b      	ldr	r3, [r5, #16]
 8002f1a:	b15b      	cbz	r3, 8002f34 <vQueueWaitForMessageRestricted+0xac>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8002f1c:	4630      	mov	r0, r6
 8002f1e:	f000 fd63 	bl	80039e8 <xTaskRemoveFromEventList>
 8002f22:	2800      	cmp	r0, #0
 8002f24:	d0f4      	beq.n	8002f10 <vQueueWaitForMessageRestricted+0x88>
					vTaskMissedYield();
 8002f26:	f000 fdf5 	bl	8003b14 <vTaskMissedYield>
				--cRxLock;
 8002f2a:	1e63      	subs	r3, r4, #1
 8002f2c:	b2da      	uxtb	r2, r3
 8002f2e:	b25c      	sxtb	r4, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8002f30:	2a00      	cmp	r2, #0
 8002f32:	d1f1      	bne.n	8002f18 <vQueueWaitForMessageRestricted+0x90>
		pxQueue->cRxLock = queueUNLOCKED;
 8002f34:	23ff      	movs	r3, #255	@ 0xff
 8002f36:	f885 3044 	strb.w	r3, [r5, #68]	@ 0x44
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
	}
 8002f3a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	taskEXIT_CRITICAL();
 8002f3e:	f001 ba0b 	b.w	8004358 <vPortExitCritical>
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
 8002f42:	4622      	mov	r2, r4
 8002f44:	4631      	mov	r1, r6
 8002f46:	f105 0024 	add.w	r0, r5, #36	@ 0x24
 8002f4a:	f000 fd2b 	bl	80039a4 <vTaskPlaceOnEventListRestricted>
 8002f4e:	e7b4      	b.n	8002eba <vQueueWaitForMessageRestricted+0x32>

08002f50 <prvAddNewTaskToReadyList>:
	}
}
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
 8002f50:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002f54:	b082      	sub	sp, #8
 8002f56:	4604      	mov	r4, r0
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
 8002f58:	f001 f9dc 	bl	8004314 <vPortEnterCritical>
	{
		uxCurrentNumberOfTasks++;
 8002f5c:	4a3b      	ldr	r2, [pc, #236]	@ (800304c <prvAddNewTaskToReadyList+0xfc>)
		if( pxCurrentTCB == NULL )
 8002f5e:	4d3c      	ldr	r5, [pc, #240]	@ (8003050 <prvAddNewTaskToReadyList+0x100>)
		uxCurrentNumberOfTasks++;
 8002f60:	6813      	ldr	r3, [r2, #0]
 8002f62:	3301      	adds	r3, #1
 8002f64:	6013      	str	r3, [r2, #0]
		if( pxCurrentTCB == NULL )
 8002f66:	682b      	ldr	r3, [r5, #0]
 8002f68:	2b00      	cmp	r3, #0
 8002f6a:	d047      	beq.n	8002ffc <prvAddNewTaskToReadyList+0xac>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
 8002f6c:	4e39      	ldr	r6, [pc, #228]	@ (8003054 <prvAddNewTaskToReadyList+0x104>)
 8002f6e:	6833      	ldr	r3, [r6, #0]
 8002f70:	2b00      	cmp	r3, #0
 8002f72:	d03b      	beq.n	8002fec <prvAddNewTaskToReadyList+0x9c>
 8002f74:	4f38      	ldr	r7, [pc, #224]	@ (8003058 <prvAddNewTaskToReadyList+0x108>)
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
 8002f76:	4a39      	ldr	r2, [pc, #228]	@ (800305c <prvAddNewTaskToReadyList+0x10c>)
		{
			/* Add a counter into the TCB for tracing only. */
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );
 8002f78:	4620      	mov	r0, r4
		uxTaskNumber++;
 8002f7a:	6813      	ldr	r3, [r2, #0]
 8002f7c:	3301      	adds	r3, #1
			pxNewTCB->uxTCBNumber = uxTaskNumber;
 8002f7e:	6463      	str	r3, [r4, #68]	@ 0x44
		uxTaskNumber++;
 8002f80:	6013      	str	r3, [r2, #0]
		traceTASK_CREATE( pxNewTCB );
 8002f82:	f002 fd23 	bl	80059cc <SEGGER_SYSVIEW_OnTaskCreate>
 8002f86:	4621      	mov	r1, r4
 8002f88:	6b23      	ldr	r3, [r4, #48]	@ 0x30
 8002f8a:	f851 cb34 	ldr.w	ip, [r1], #52
 8002f8e:	6ae2      	ldr	r2, [r4, #44]	@ 0x2c
 8002f90:	ebac 0c03 	sub.w	ip, ip, r3
 8002f94:	f8cd c000 	str.w	ip, [sp]
 8002f98:	4620      	mov	r0, r4
 8002f9a:	f001 fcab 	bl	80048f4 <SYSVIEW_AddTask>

		prvAddTaskToReadyList( pxNewTCB );
 8002f9e:	4620      	mov	r0, r4
 8002fa0:	f002 fd58 	bl	8005a54 <SEGGER_SYSVIEW_OnTaskStartReady>
 8002fa4:	2301      	movs	r3, #1
 8002fa6:	4a2e      	ldr	r2, [pc, #184]	@ (8003060 <prvAddNewTaskToReadyList+0x110>)
 8002fa8:	6ae0      	ldr	r0, [r4, #44]	@ 0x2c
 8002faa:	6811      	ldr	r1, [r2, #0]
 8002fac:	4083      	lsls	r3, r0
 8002fae:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8002fb2:	430b      	orrs	r3, r1
 8002fb4:	eb07 0080 	add.w	r0, r7, r0, lsl #2
 8002fb8:	1d21      	adds	r1, r4, #4
 8002fba:	6013      	str	r3, [r2, #0]
 8002fbc:	f7ff f8ac 	bl	8002118 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
 8002fc0:	f001 f9ca 	bl	8004358 <vPortExitCritical>

	if( xSchedulerRunning != pdFALSE )
 8002fc4:	6833      	ldr	r3, [r6, #0]
 8002fc6:	b173      	cbz	r3, 8002fe6 <prvAddNewTaskToReadyList+0x96>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 8002fc8:	682a      	ldr	r2, [r5, #0]
 8002fca:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
 8002fcc:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
 8002fce:	429a      	cmp	r2, r3
 8002fd0:	d209      	bcs.n	8002fe6 <prvAddNewTaskToReadyList+0x96>
		{
			taskYIELD_IF_USING_PREEMPTION();
 8002fd2:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 8002fd6:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 8002fda:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 8002fde:	f3bf 8f4f 	dsb	sy
 8002fe2:	f3bf 8f6f 	isb	sy
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 8002fe6:	b002      	add	sp, #8
 8002fe8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 8002fec:	682a      	ldr	r2, [r5, #0]
 8002fee:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
 8002ff0:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
 8002ff2:	4f19      	ldr	r7, [pc, #100]	@ (8003058 <prvAddNewTaskToReadyList+0x108>)
 8002ff4:	429a      	cmp	r2, r3
					pxCurrentTCB = pxNewTCB;
 8002ff6:	bf98      	it	ls
 8002ff8:	602c      	strls	r4, [r5, #0]
 8002ffa:	e7bc      	b.n	8002f76 <prvAddNewTaskToReadyList+0x26>
			pxCurrentTCB = pxNewTCB;
 8002ffc:	602c      	str	r4, [r5, #0]
			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 8002ffe:	6813      	ldr	r3, [r2, #0]
 8003000:	4f15      	ldr	r7, [pc, #84]	@ (8003058 <prvAddNewTaskToReadyList+0x108>)
 8003002:	2b01      	cmp	r3, #1
 8003004:	d001      	beq.n	800300a <prvAddNewTaskToReadyList+0xba>
 8003006:	4e13      	ldr	r6, [pc, #76]	@ (8003054 <prvAddNewTaskToReadyList+0x104>)

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
}
 8003008:	e7b5      	b.n	8002f76 <prvAddNewTaskToReadyList+0x26>
 800300a:	463e      	mov	r6, r7
 800300c:	f107 088c 	add.w	r8, r7, #140	@ 0x8c
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 8003010:	4630      	mov	r0, r6
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 8003012:	3614      	adds	r6, #20
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 8003014:	f7ff f870 	bl	80020f8 <vListInitialise>
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 8003018:	45b0      	cmp	r8, r6
 800301a:	d1f9      	bne.n	8003010 <prvAddNewTaskToReadyList+0xc0>
	vListInitialise( &xDelayedTaskList1 );
 800301c:	f8df 8044 	ldr.w	r8, [pc, #68]	@ 8003064 <prvAddNewTaskToReadyList+0x114>
	vListInitialise( &xDelayedTaskList2 );
 8003020:	4e11      	ldr	r6, [pc, #68]	@ (8003068 <prvAddNewTaskToReadyList+0x118>)
	vListInitialise( &xDelayedTaskList1 );
 8003022:	4640      	mov	r0, r8
 8003024:	f7ff f868 	bl	80020f8 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 8003028:	4630      	mov	r0, r6
 800302a:	f7ff f865 	bl	80020f8 <vListInitialise>
	vListInitialise( &xPendingReadyList );
 800302e:	480f      	ldr	r0, [pc, #60]	@ (800306c <prvAddNewTaskToReadyList+0x11c>)
 8003030:	f7ff f862 	bl	80020f8 <vListInitialise>
		vListInitialise( &xTasksWaitingTermination );
 8003034:	480e      	ldr	r0, [pc, #56]	@ (8003070 <prvAddNewTaskToReadyList+0x120>)
 8003036:	f7ff f85f 	bl	80020f8 <vListInitialise>
		vListInitialise( &xSuspendedTaskList );
 800303a:	480e      	ldr	r0, [pc, #56]	@ (8003074 <prvAddNewTaskToReadyList+0x124>)
 800303c:	f7ff f85c 	bl	80020f8 <vListInitialise>
	pxDelayedTaskList = &xDelayedTaskList1;
 8003040:	4b0d      	ldr	r3, [pc, #52]	@ (8003078 <prvAddNewTaskToReadyList+0x128>)
 8003042:	f8c3 8000 	str.w	r8, [r3]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 8003046:	4b0d      	ldr	r3, [pc, #52]	@ (800307c <prvAddNewTaskToReadyList+0x12c>)
 8003048:	601e      	str	r6, [r3, #0]
 800304a:	e7dc      	b.n	8003006 <prvAddNewTaskToReadyList+0xb6>
 800304c:	2000099c 	.word	0x2000099c
 8003050:	20000a9c 	.word	0x20000a9c
 8003054:	20000990 	.word	0x20000990
 8003058:	20000a10 	.word	0x20000a10
 800305c:	20000980 	.word	0x20000980
 8003060:	20000994 	.word	0x20000994
 8003064:	200009fc 	.word	0x200009fc
 8003068:	200009e8 	.word	0x200009e8
 800306c:	200009cc 	.word	0x200009cc
 8003070:	200009b8 	.word	0x200009b8
 8003074:	200009a0 	.word	0x200009a0
 8003078:	200009e4 	.word	0x200009e4
 800307c:	200009e0 	.word	0x200009e0

08003080 <prvAddCurrentTaskToDelayedList>:

#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
 8003080:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
 8003082:	4b20      	ldr	r3, [pc, #128]	@ (8003104 <prvAddCurrentTaskToDelayedList+0x84>)
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8003084:	4e20      	ldr	r6, [pc, #128]	@ (8003108 <prvAddCurrentTaskToDelayedList+0x88>)
{
 8003086:	4605      	mov	r5, r0
const TickType_t xConstTickCount = xTickCount;
 8003088:	681c      	ldr	r4, [r3, #0]
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800308a:	6830      	ldr	r0, [r6, #0]
{
 800308c:	460f      	mov	r7, r1
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800308e:	3004      	adds	r0, #4
 8003090:	f7ff f868 	bl	8002164 <uxListRemove>
 8003094:	b940      	cbnz	r0, 80030a8 <prvAddCurrentTaskToDelayedList+0x28>
	{
		/* The current task must be in a ready list, so there is no need to
		check, and the port reset macro can be called directly. */
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority ); /*lint !e931 pxCurrentTCB cannot change as it is the calling task.  pxCurrentTCB->uxPriority and uxTopReadyPriority cannot change as called with scheduler suspended or in a critical section. */
 8003096:	2201      	movs	r2, #1
 8003098:	6833      	ldr	r3, [r6, #0]
 800309a:	491c      	ldr	r1, [pc, #112]	@ (800310c <prvAddCurrentTaskToDelayedList+0x8c>)
 800309c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800309e:	409a      	lsls	r2, r3
 80030a0:	680b      	ldr	r3, [r1, #0]
 80030a2:	ea23 0302 	bic.w	r3, r3, r2
 80030a6:	600b      	str	r3, [r1, #0]
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 80030a8:	1c6b      	adds	r3, r5, #1
 80030aa:	d01e      	beq.n	80030ea <prvAddCurrentTaskToDelayedList+0x6a>
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 80030ac:	6833      	ldr	r3, [r6, #0]
 80030ae:	1964      	adds	r4, r4, r5

			if( xTimeToWake < xConstTickCount )
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
        traceMOVED_TASK_TO_OVERFLOW_DELAYED_LIST();
 80030b0:	f04f 0104 	mov.w	r1, #4
 80030b4:	6830      	ldr	r0, [r6, #0]
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 80030b6:	605c      	str	r4, [r3, #4]
			if( xTimeToWake < xConstTickCount )
 80030b8:	d309      	bcc.n	80030ce <prvAddCurrentTaskToDelayedList+0x4e>
        traceMOVED_TASK_TO_OVERFLOW_DELAYED_LIST();
 80030ba:	f002 fced 	bl	8005a98 <SEGGER_SYSVIEW_OnTaskStopReady>
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 80030be:	4b14      	ldr	r3, [pc, #80]	@ (8003110 <prvAddCurrentTaskToDelayedList+0x90>)
 80030c0:	6818      	ldr	r0, [r3, #0]
 80030c2:	6831      	ldr	r1, [r6, #0]

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 80030c4:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 80030c8:	3104      	adds	r1, #4
 80030ca:	f7ff b833 	b.w	8002134 <vListInsert>
        traceMOVED_TASK_TO_DELAYED_LIST();
 80030ce:	f002 fce3 	bl	8005a98 <SEGGER_SYSVIEW_OnTaskStopReady>
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 80030d2:	4b10      	ldr	r3, [pc, #64]	@ (8003114 <prvAddCurrentTaskToDelayedList+0x94>)
 80030d4:	6818      	ldr	r0, [r3, #0]
 80030d6:	6831      	ldr	r1, [r6, #0]
 80030d8:	3104      	adds	r1, #4
 80030da:	f7ff f82b 	bl	8002134 <vListInsert>
				if( xTimeToWake < xNextTaskUnblockTime )
 80030de:	4b0e      	ldr	r3, [pc, #56]	@ (8003118 <prvAddCurrentTaskToDelayedList+0x98>)
 80030e0:	681a      	ldr	r2, [r3, #0]
 80030e2:	42a2      	cmp	r2, r4
					xNextTaskUnblockTime = xTimeToWake;
 80030e4:	bf88      	it	hi
 80030e6:	601c      	strhi	r4, [r3, #0]
}
 80030e8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 80030ea:	2f00      	cmp	r7, #0
 80030ec:	d0de      	beq.n	80030ac <prvAddCurrentTaskToDelayedList+0x2c>
      traceMOVED_TASK_TO_SUSPENDED_LIST(pxCurrentTCB);
 80030ee:	6830      	ldr	r0, [r6, #0]
 80030f0:	211b      	movs	r1, #27
 80030f2:	f002 fcd1 	bl	8005a98 <SEGGER_SYSVIEW_OnTaskStopReady>
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 80030f6:	6831      	ldr	r1, [r6, #0]
 80030f8:	4808      	ldr	r0, [pc, #32]	@ (800311c <prvAddCurrentTaskToDelayedList+0x9c>)
 80030fa:	3104      	adds	r1, #4
}
 80030fc:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8003100:	f7ff b80a 	b.w	8002118 <vListInsertEnd>
 8003104:	20000998 	.word	0x20000998
 8003108:	20000a9c 	.word	0x20000a9c
 800310c:	20000994 	.word	0x20000994
 8003110:	200009e0 	.word	0x200009e0
 8003114:	200009e4 	.word	0x200009e4
 8003118:	2000097c 	.word	0x2000097c
 800311c:	200009a0 	.word	0x200009a0

08003120 <prvInitialiseNewTask.constprop.0>:
static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
 8003120:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8003124:	460d      	mov	r5, r1
 8003126:	9c0a      	ldr	r4, [sp, #40]	@ 0x28
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 8003128:	0096      	lsls	r6, r2, #2
 800312a:	4632      	mov	r2, r6
static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
 800312c:	4607      	mov	r7, r0
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 800312e:	21a5      	movs	r1, #165	@ 0xa5
 8003130:	6b20      	ldr	r0, [r4, #48]	@ 0x30
static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
 8003132:	4698      	mov	r8, r3
 8003134:	f8dd 9024 	ldr.w	r9, [sp, #36]	@ 0x24
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 8003138:	f003 fd78 	bl	8006c2c <memset>
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 800313c:	6b23      	ldr	r3, [r4, #48]	@ 0x30
 800313e:	3e04      	subs	r6, #4
 8003140:	441e      	add	r6, r3
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
 8003142:	f026 0607 	bic.w	r6, r6, #7
	if( pcName != NULL )
 8003146:	2d00      	cmp	r5, #0
 8003148:	d071      	beq.n	800322e <prvInitialiseNewTask.constprop.0+0x10e>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 800314a:	782b      	ldrb	r3, [r5, #0]
 800314c:	f884 3034 	strb.w	r3, [r4, #52]	@ 0x34
			if( pcName[ x ] == ( char ) 0x00 )
 8003150:	2b00      	cmp	r3, #0
 8003152:	d036      	beq.n	80031c2 <prvInitialiseNewTask.constprop.0+0xa2>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8003154:	786b      	ldrb	r3, [r5, #1]
 8003156:	f884 3035 	strb.w	r3, [r4, #53]	@ 0x35
			if( pcName[ x ] == ( char ) 0x00 )
 800315a:	b393      	cbz	r3, 80031c2 <prvInitialiseNewTask.constprop.0+0xa2>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 800315c:	78ab      	ldrb	r3, [r5, #2]
 800315e:	f884 3036 	strb.w	r3, [r4, #54]	@ 0x36
			if( pcName[ x ] == ( char ) 0x00 )
 8003162:	b373      	cbz	r3, 80031c2 <prvInitialiseNewTask.constprop.0+0xa2>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8003164:	78eb      	ldrb	r3, [r5, #3]
 8003166:	f884 3037 	strb.w	r3, [r4, #55]	@ 0x37
			if( pcName[ x ] == ( char ) 0x00 )
 800316a:	b353      	cbz	r3, 80031c2 <prvInitialiseNewTask.constprop.0+0xa2>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 800316c:	792b      	ldrb	r3, [r5, #4]
 800316e:	f884 3038 	strb.w	r3, [r4, #56]	@ 0x38
			if( pcName[ x ] == ( char ) 0x00 )
 8003172:	b333      	cbz	r3, 80031c2 <prvInitialiseNewTask.constprop.0+0xa2>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8003174:	796b      	ldrb	r3, [r5, #5]
 8003176:	f884 3039 	strb.w	r3, [r4, #57]	@ 0x39
			if( pcName[ x ] == ( char ) 0x00 )
 800317a:	b313      	cbz	r3, 80031c2 <prvInitialiseNewTask.constprop.0+0xa2>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 800317c:	79ab      	ldrb	r3, [r5, #6]
 800317e:	f884 303a 	strb.w	r3, [r4, #58]	@ 0x3a
			if( pcName[ x ] == ( char ) 0x00 )
 8003182:	b1f3      	cbz	r3, 80031c2 <prvInitialiseNewTask.constprop.0+0xa2>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8003184:	79eb      	ldrb	r3, [r5, #7]
 8003186:	f884 303b 	strb.w	r3, [r4, #59]	@ 0x3b
			if( pcName[ x ] == ( char ) 0x00 )
 800318a:	b1d3      	cbz	r3, 80031c2 <prvInitialiseNewTask.constprop.0+0xa2>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 800318c:	7a2b      	ldrb	r3, [r5, #8]
 800318e:	f884 303c 	strb.w	r3, [r4, #60]	@ 0x3c
			if( pcName[ x ] == ( char ) 0x00 )
 8003192:	b1b3      	cbz	r3, 80031c2 <prvInitialiseNewTask.constprop.0+0xa2>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8003194:	7a6b      	ldrb	r3, [r5, #9]
 8003196:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
			if( pcName[ x ] == ( char ) 0x00 )
 800319a:	b193      	cbz	r3, 80031c2 <prvInitialiseNewTask.constprop.0+0xa2>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 800319c:	7aab      	ldrb	r3, [r5, #10]
 800319e:	f884 303e 	strb.w	r3, [r4, #62]	@ 0x3e
			if( pcName[ x ] == ( char ) 0x00 )
 80031a2:	b173      	cbz	r3, 80031c2 <prvInitialiseNewTask.constprop.0+0xa2>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 80031a4:	7aeb      	ldrb	r3, [r5, #11]
 80031a6:	f884 303f 	strb.w	r3, [r4, #63]	@ 0x3f
			if( pcName[ x ] == ( char ) 0x00 )
 80031aa:	b153      	cbz	r3, 80031c2 <prvInitialiseNewTask.constprop.0+0xa2>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 80031ac:	7b2b      	ldrb	r3, [r5, #12]
 80031ae:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
			if( pcName[ x ] == ( char ) 0x00 )
 80031b2:	b133      	cbz	r3, 80031c2 <prvInitialiseNewTask.constprop.0+0xa2>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 80031b4:	7b6b      	ldrb	r3, [r5, #13]
 80031b6:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
			if( pcName[ x ] == ( char ) 0x00 )
 80031ba:	b113      	cbz	r3, 80031c2 <prvInitialiseNewTask.constprop.0+0xa2>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 80031bc:	7bab      	ldrb	r3, [r5, #14]
 80031be:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 80031c2:	2300      	movs	r3, #0
 80031c4:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 80031c8:	9d08      	ldr	r5, [sp, #32]
		pxNewTCB->uxMutexesHeld = 0;
 80031ca:	f04f 0a00 	mov.w	sl, #0
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 80031ce:	2d06      	cmp	r5, #6
 80031d0:	bf28      	it	cs
 80031d2:	2506      	movcs	r5, #6
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 80031d4:	1d20      	adds	r0, r4, #4
		pxNewTCB->uxMutexesHeld = 0;
 80031d6:	e9c4 5a13 	strd	r5, sl, [r4, #76]	@ 0x4c
	pxNewTCB->uxPriority = uxPriority;
 80031da:	62e5      	str	r5, [r4, #44]	@ 0x2c
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 80031dc:	f7fe ff98 	bl	8002110 <vListInitialiseItem>
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80031e0:	f1c5 0507 	rsb	r5, r5, #7
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 80031e4:	f104 0018 	add.w	r0, r4, #24
 80031e8:	f7fe ff92 	bl	8002110 <vListInitialiseItem>
		_REENT_INIT_PTR( ( &( pxNewTCB->xNewLib_reent ) ) );
 80031ec:	224c      	movs	r2, #76	@ 0x4c
 80031ee:	4651      	mov	r1, sl
		pxNewTCB->ulNotifiedValue = 0;
 80031f0:	f8c4 a0a0 	str.w	sl, [r4, #160]	@ 0xa0
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80031f4:	61a5      	str	r5, [r4, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 80031f6:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 80031f8:	6264      	str	r4, [r4, #36]	@ 0x24
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 80031fa:	f884 a0a4 	strb.w	sl, [r4, #164]	@ 0xa4
		_REENT_INIT_PTR( ( &( pxNewTCB->xNewLib_reent ) ) );
 80031fe:	f104 0054 	add.w	r0, r4, #84	@ 0x54
 8003202:	f003 fd13 	bl	8006c2c <memset>
 8003206:	4b0b      	ldr	r3, [pc, #44]	@ (8003234 <prvInitialiseNewTask.constprop.0+0x114>)
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8003208:	4639      	mov	r1, r7
		_REENT_INIT_PTR( ( &( pxNewTCB->xNewLib_reent ) ) );
 800320a:	f103 0268 	add.w	r2, r3, #104	@ 0x68
 800320e:	65a3      	str	r3, [r4, #88]	@ 0x58
 8003210:	33d0      	adds	r3, #208	@ 0xd0
 8003212:	65e2      	str	r2, [r4, #92]	@ 0x5c
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8003214:	4630      	mov	r0, r6
 8003216:	4642      	mov	r2, r8
		_REENT_INIT_PTR( ( &( pxNewTCB->xNewLib_reent ) ) );
 8003218:	6623      	str	r3, [r4, #96]	@ 0x60
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 800321a:	f001 f855 	bl	80042c8 <pxPortInitialiseStack>
 800321e:	6020      	str	r0, [r4, #0]
	if( pxCreatedTask != NULL )
 8003220:	f1b9 0f00 	cmp.w	r9, #0
 8003224:	d001      	beq.n	800322a <prvInitialiseNewTask.constprop.0+0x10a>
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 8003226:	f8c9 4000 	str.w	r4, [r9]
}
 800322a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
 800322e:	f884 5034 	strb.w	r5, [r4, #52]	@ 0x34
 8003232:	e7c9      	b.n	80031c8 <prvInitialiseNewTask.constprop.0+0xa8>
 8003234:	20001e4c 	.word	0x20001e4c

08003238 <prvIdleTask>:
{
 8003238:	b580      	push	{r7, lr}
 800323a:	4d23      	ldr	r5, [pc, #140]	@ (80032c8 <prvIdleTask+0x90>)
 800323c:	4f23      	ldr	r7, [pc, #140]	@ (80032cc <prvIdleTask+0x94>)
 800323e:	4e24      	ldr	r6, [pc, #144]	@ (80032d0 <prvIdleTask+0x98>)
 8003240:	f8df 8090 	ldr.w	r8, [pc, #144]	@ 80032d4 <prvIdleTask+0x9c>
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 8003244:	682b      	ldr	r3, [r5, #0]
 8003246:	b35b      	cbz	r3, 80032a0 <prvIdleTask+0x68>
			taskENTER_CRITICAL();
 8003248:	f001 f864 	bl	8004314 <vPortEnterCritical>
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 800324c:	68fb      	ldr	r3, [r7, #12]
 800324e:	68dc      	ldr	r4, [r3, #12]
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8003250:	1d20      	adds	r0, r4, #4
 8003252:	f7fe ff87 	bl	8002164 <uxListRemove>
				--uxCurrentNumberOfTasks;
 8003256:	6833      	ldr	r3, [r6, #0]
 8003258:	3b01      	subs	r3, #1
 800325a:	6033      	str	r3, [r6, #0]
				--uxDeletedTasksWaitingCleanUp;
 800325c:	682b      	ldr	r3, [r5, #0]
 800325e:	3b01      	subs	r3, #1
 8003260:	602b      	str	r3, [r5, #0]
			taskEXIT_CRITICAL();
 8003262:	f001 f879 	bl	8004358 <vPortExitCritical>
			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
 8003266:	f104 0054 	add.w	r0, r4, #84	@ 0x54
 800326a:	f003 fce7 	bl	8006c3c <_reclaim_reent>
			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
 800326e:	f894 30a5 	ldrb.w	r3, [r4, #165]	@ 0xa5
 8003272:	b163      	cbz	r3, 800328e <prvIdleTask+0x56>
			else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
 8003274:	2b01      	cmp	r3, #1
 8003276:	d022      	beq.n	80032be <prvIdleTask+0x86>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
 8003278:	2b02      	cmp	r3, #2
 800327a:	d0e3      	beq.n	8003244 <prvIdleTask+0xc>
 800327c:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8003280:	f383 8811 	msr	BASEPRI, r3
 8003284:	f3bf 8f6f 	isb	sy
 8003288:	f3bf 8f4f 	dsb	sy
 800328c:	e7fe      	b.n	800328c <prvIdleTask+0x54>
				vPortFree( pxTCB->pxStack );
 800328e:	6b20      	ldr	r0, [r4, #48]	@ 0x30
 8003290:	f001 fa76 	bl	8004780 <vPortFree>
				vPortFree( pxTCB );
 8003294:	4620      	mov	r0, r4
 8003296:	f001 fa73 	bl	8004780 <vPortFree>
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 800329a:	682b      	ldr	r3, [r5, #0]
 800329c:	2b00      	cmp	r3, #0
 800329e:	d1d3      	bne.n	8003248 <prvIdleTask+0x10>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 80032a0:	f8d8 3000 	ldr.w	r3, [r8]
 80032a4:	2b01      	cmp	r3, #1
 80032a6:	d9cd      	bls.n	8003244 <prvIdleTask+0xc>
				taskYIELD();
 80032a8:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 80032ac:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 80032b0:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 80032b4:	f3bf 8f4f 	dsb	sy
 80032b8:	f3bf 8f6f 	isb	sy
 80032bc:	e7c2      	b.n	8003244 <prvIdleTask+0xc>
				vPortFree( pxTCB );
 80032be:	4620      	mov	r0, r4
 80032c0:	f001 fa5e 	bl	8004780 <vPortFree>
 80032c4:	e7be      	b.n	8003244 <prvIdleTask+0xc>
 80032c6:	bf00      	nop
 80032c8:	200009b4 	.word	0x200009b4
 80032cc:	200009b8 	.word	0x200009b8
 80032d0:	2000099c 	.word	0x2000099c
 80032d4:	20000a10 	.word	0x20000a10

080032d8 <xTaskIncrementTick.part.0>:
BaseType_t xTaskIncrementTick( void )
 80032d8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
 80032dc:	4b4c      	ldr	r3, [pc, #304]	@ (8003410 <xTaskIncrementTick.part.0+0x138>)
BaseType_t xTaskIncrementTick( void )
 80032de:	b083      	sub	sp, #12
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
 80032e0:	681e      	ldr	r6, [r3, #0]
 80032e2:	3601      	adds	r6, #1
		xTickCount = xConstTickCount;
 80032e4:	601e      	str	r6, [r3, #0]
		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
 80032e6:	2e00      	cmp	r6, #0
 80032e8:	d047      	beq.n	800337a <xTaskIncrementTick.part.0+0xa2>
 80032ea:	4b4a      	ldr	r3, [pc, #296]	@ (8003414 <xTaskIncrementTick.part.0+0x13c>)
 80032ec:	9301      	str	r3, [sp, #4]
		if( xConstTickCount >= xNextTaskUnblockTime )
 80032ee:	681b      	ldr	r3, [r3, #0]
 80032f0:	429e      	cmp	r6, r3
 80032f2:	d34f      	bcc.n	8003394 <xTaskIncrementTick.part.0+0xbc>
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 80032f4:	4f48      	ldr	r7, [pc, #288]	@ (8003418 <xTaskIncrementTick.part.0+0x140>)
 80032f6:	683b      	ldr	r3, [r7, #0]
 80032f8:	681c      	ldr	r4, [r3, #0]
 80032fa:	2c00      	cmp	r4, #0
 80032fc:	d07f      	beq.n	80033fe <xTaskIncrementTick.part.0+0x126>
BaseType_t xSwitchRequired = pdFALSE;
 80032fe:	2400      	movs	r4, #0
 8003300:	f8df 9118 	ldr.w	r9, [pc, #280]	@ 800341c <xTaskIncrementTick.part.0+0x144>
 8003304:	f8df a118 	ldr.w	sl, [pc, #280]	@ 8003420 <xTaskIncrementTick.part.0+0x148>
					prvAddTaskToReadyList( pxTCB );
 8003308:	f8df 8118 	ldr.w	r8, [pc, #280]	@ 8003424 <xTaskIncrementTick.part.0+0x14c>
 800330c:	e028      	b.n	8003360 <xTaskIncrementTick.part.0+0x88>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800330e:	4628      	mov	r0, r5
 8003310:	f7fe ff28 	bl	8002164 <uxListRemove>
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8003314:	f8db 2028 	ldr.w	r2, [fp, #40]	@ 0x28
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8003318:	f10b 0018 	add.w	r0, fp, #24
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 800331c:	b10a      	cbz	r2, 8003322 <xTaskIncrementTick.part.0+0x4a>
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 800331e:	f7fe ff21 	bl	8002164 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 8003322:	4658      	mov	r0, fp
 8003324:	f002 fb96 	bl	8005a54 <SEGGER_SYSVIEW_OnTaskStartReady>
 8003328:	2201      	movs	r2, #1
 800332a:	f8db 002c 	ldr.w	r0, [fp, #44]	@ 0x2c
 800332e:	f8d8 3000 	ldr.w	r3, [r8]
 8003332:	4082      	lsls	r2, r0
 8003334:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8003338:	431a      	orrs	r2, r3
 800333a:	4629      	mov	r1, r5
 800333c:	eb09 0080 	add.w	r0, r9, r0, lsl #2
 8003340:	f8c8 2000 	str.w	r2, [r8]
 8003344:	f7fe fee8 	bl	8002118 <vListInsertEnd>
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8003348:	f8da 2000 	ldr.w	r2, [sl]
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 800334c:	6838      	ldr	r0, [r7, #0]
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 800334e:	f8db 102c 	ldr.w	r1, [fp, #44]	@ 0x2c
 8003352:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8003354:	6803      	ldr	r3, [r0, #0]
							xSwitchRequired = pdTRUE;
 8003356:	4291      	cmp	r1, r2
 8003358:	bf28      	it	cs
 800335a:	2401      	movcs	r4, #1
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 800335c:	2b00      	cmp	r3, #0
 800335e:	d052      	beq.n	8003406 <xTaskIncrementTick.part.0+0x12e>
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8003360:	683b      	ldr	r3, [r7, #0]
 8003362:	68db      	ldr	r3, [r3, #12]
 8003364:	f8d3 b00c 	ldr.w	fp, [r3, #12]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 8003368:	f8db 2004 	ldr.w	r2, [fp, #4]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800336c:	f10b 0504 	add.w	r5, fp, #4
					if( xConstTickCount < xItemValue )
 8003370:	4296      	cmp	r6, r2
 8003372:	d2cc      	bcs.n	800330e <xTaskIncrementTick.part.0+0x36>
						xNextTaskUnblockTime = xItemValue;
 8003374:	9b01      	ldr	r3, [sp, #4]
 8003376:	601a      	str	r2, [r3, #0]
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
 8003378:	e011      	b.n	800339e <xTaskIncrementTick.part.0+0xc6>
			taskSWITCH_DELAYED_LISTS();
 800337a:	4b27      	ldr	r3, [pc, #156]	@ (8003418 <xTaskIncrementTick.part.0+0x140>)
 800337c:	681a      	ldr	r2, [r3, #0]
 800337e:	6812      	ldr	r2, [r2, #0]
 8003380:	b30a      	cbz	r2, 80033c6 <xTaskIncrementTick.part.0+0xee>
 8003382:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8003386:	f383 8811 	msr	BASEPRI, r3
 800338a:	f3bf 8f6f 	isb	sy
 800338e:	f3bf 8f4f 	dsb	sy
 8003392:	e7fe      	b.n	8003392 <xTaskIncrementTick.part.0+0xba>
BaseType_t xSwitchRequired = pdFALSE;
 8003394:	2400      	movs	r4, #0
 8003396:	f8df 9084 	ldr.w	r9, [pc, #132]	@ 800341c <xTaskIncrementTick.part.0+0x144>
 800339a:	f8df a084 	ldr.w	sl, [pc, #132]	@ 8003420 <xTaskIncrementTick.part.0+0x148>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 800339e:	f8da 3000 	ldr.w	r3, [sl]
			if( xYieldPending != pdFALSE )
 80033a2:	4921      	ldr	r1, [pc, #132]	@ (8003428 <xTaskIncrementTick.part.0+0x150>)
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 80033a4:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80033a6:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80033aa:	009b      	lsls	r3, r3, #2
 80033ac:	f859 2003 	ldr.w	r2, [r9, r3]
			if( xYieldPending != pdFALSE )
 80033b0:	680b      	ldr	r3, [r1, #0]
				xSwitchRequired = pdTRUE;
 80033b2:	2a02      	cmp	r2, #2
 80033b4:	bf28      	it	cs
 80033b6:	2401      	movcs	r4, #1
				xSwitchRequired = pdTRUE;
 80033b8:	2b00      	cmp	r3, #0
}
 80033ba:	bf0c      	ite	eq
 80033bc:	4620      	moveq	r0, r4
 80033be:	2001      	movne	r0, #1
 80033c0:	b003      	add	sp, #12
 80033c2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			taskSWITCH_DELAYED_LISTS();
 80033c6:	4a19      	ldr	r2, [pc, #100]	@ (800342c <xTaskIncrementTick.part.0+0x154>)
 80033c8:	6818      	ldr	r0, [r3, #0]
 80033ca:	6811      	ldr	r1, [r2, #0]
 80033cc:	6019      	str	r1, [r3, #0]
 80033ce:	4918      	ldr	r1, [pc, #96]	@ (8003430 <xTaskIncrementTick.part.0+0x158>)
 80033d0:	6010      	str	r0, [r2, #0]
 80033d2:	680a      	ldr	r2, [r1, #0]
 80033d4:	3201      	adds	r2, #1
 80033d6:	600a      	str	r2, [r1, #0]
	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 80033d8:	681a      	ldr	r2, [r3, #0]
 80033da:	6812      	ldr	r2, [r2, #0]
 80033dc:	b932      	cbnz	r2, 80033ec <xTaskIncrementTick.part.0+0x114>
		xNextTaskUnblockTime = portMAX_DELAY;
 80033de:	f04f 33ff 	mov.w	r3, #4294967295
 80033e2:	4a0c      	ldr	r2, [pc, #48]	@ (8003414 <xTaskIncrementTick.part.0+0x13c>)
 80033e4:	6013      	str	r3, [r2, #0]
 80033e6:	9201      	str	r2, [sp, #4]
 80033e8:	4613      	mov	r3, r2
 80033ea:	e780      	b.n	80032ee <xTaskIncrementTick.part.0+0x16>
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 80033ec:	681b      	ldr	r3, [r3, #0]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 80033ee:	4a09      	ldr	r2, [pc, #36]	@ (8003414 <xTaskIncrementTick.part.0+0x13c>)
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 80033f0:	68db      	ldr	r3, [r3, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 80033f2:	9201      	str	r2, [sp, #4]
 80033f4:	68db      	ldr	r3, [r3, #12]
 80033f6:	685b      	ldr	r3, [r3, #4]
 80033f8:	6013      	str	r3, [r2, #0]
 80033fa:	4613      	mov	r3, r2
}
 80033fc:	e777      	b.n	80032ee <xTaskIncrementTick.part.0+0x16>
 80033fe:	f8df 901c 	ldr.w	r9, [pc, #28]	@ 800341c <xTaskIncrementTick.part.0+0x144>
 8003402:	f8df a01c 	ldr.w	sl, [pc, #28]	@ 8003420 <xTaskIncrementTick.part.0+0x148>
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8003406:	f04f 33ff 	mov.w	r3, #4294967295
 800340a:	9a01      	ldr	r2, [sp, #4]
 800340c:	6013      	str	r3, [r2, #0]
					break;
 800340e:	e7c6      	b.n	800339e <xTaskIncrementTick.part.0+0xc6>
 8003410:	20000998 	.word	0x20000998
 8003414:	2000097c 	.word	0x2000097c
 8003418:	200009e4 	.word	0x200009e4
 800341c:	20000a10 	.word	0x20000a10
 8003420:	20000a9c 	.word	0x20000a9c
 8003424:	20000994 	.word	0x20000994
 8003428:	20000988 	.word	0x20000988
 800342c:	200009e0 	.word	0x200009e0
 8003430:	20000984 	.word	0x20000984

08003434 <xTaskResumeAll.part.0>:
BaseType_t xTaskResumeAll( void )
 8003434:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		--uxSchedulerSuspended;
 8003438:	4d48      	ldr	r5, [pc, #288]	@ (800355c <xTaskResumeAll.part.0+0x128>)
BaseType_t xTaskResumeAll( void )
 800343a:	b083      	sub	sp, #12
	taskENTER_CRITICAL();
 800343c:	f000 ff6a 	bl	8004314 <vPortEnterCritical>
		--uxSchedulerSuspended;
 8003440:	682b      	ldr	r3, [r5, #0]
 8003442:	3b01      	subs	r3, #1
 8003444:	602b      	str	r3, [r5, #0]
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8003446:	682b      	ldr	r3, [r5, #0]
 8003448:	2b00      	cmp	r3, #0
 800344a:	d16e      	bne.n	800352a <xTaskResumeAll.part.0+0xf6>
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 800344c:	4b44      	ldr	r3, [pc, #272]	@ (8003560 <xTaskResumeAll.part.0+0x12c>)
 800344e:	681b      	ldr	r3, [r3, #0]
 8003450:	2b00      	cmp	r3, #0
 8003452:	d06a      	beq.n	800352a <xTaskResumeAll.part.0+0xf6>
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 8003454:	f8df b10c 	ldr.w	fp, [pc, #268]	@ 8003564 <xTaskResumeAll.part.0+0x130>
 8003458:	f8db 3000 	ldr.w	r3, [fp]
 800345c:	2b00      	cmp	r3, #0
 800345e:	d079      	beq.n	8003554 <xTaskResumeAll.part.0+0x120>
					prvAddTaskToReadyList( pxTCB );
 8003460:	2701      	movs	r7, #1
 8003462:	4b41      	ldr	r3, [pc, #260]	@ (8003568 <xTaskResumeAll.part.0+0x134>)
 8003464:	4e41      	ldr	r6, [pc, #260]	@ (800356c <xTaskResumeAll.part.0+0x138>)
 8003466:	f8df 9108 	ldr.w	r9, [pc, #264]	@ 8003570 <xTaskResumeAll.part.0+0x13c>
 800346a:	f8df 8108 	ldr.w	r8, [pc, #264]	@ 8003574 <xTaskResumeAll.part.0+0x140>
 800346e:	9301      	str	r3, [sp, #4]
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8003470:	f8db 300c 	ldr.w	r3, [fp, #12]
 8003474:	68dc      	ldr	r4, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8003476:	f104 0a04 	add.w	sl, r4, #4
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 800347a:	f104 0018 	add.w	r0, r4, #24
 800347e:	f7fe fe71 	bl	8002164 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8003482:	4650      	mov	r0, sl
 8003484:	f7fe fe6e 	bl	8002164 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 8003488:	4620      	mov	r0, r4
 800348a:	f002 fae3 	bl	8005a54 <SEGGER_SYSVIEW_OnTaskStartReady>
 800348e:	6ae0      	ldr	r0, [r4, #44]	@ 0x2c
 8003490:	6832      	ldr	r2, [r6, #0]
 8003492:	fa07 f300 	lsl.w	r3, r7, r0
 8003496:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800349a:	4313      	orrs	r3, r2
 800349c:	4651      	mov	r1, sl
 800349e:	eb09 0080 	add.w	r0, r9, r0, lsl #2
 80034a2:	6033      	str	r3, [r6, #0]
 80034a4:	f7fe fe38 	bl	8002118 <vListInsertEnd>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 80034a8:	f8d8 3000 	ldr.w	r3, [r8]
 80034ac:	6ae2      	ldr	r2, [r4, #44]	@ 0x2c
 80034ae:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80034b0:	429a      	cmp	r2, r3
 80034b2:	d341      	bcc.n	8003538 <xTaskResumeAll.part.0+0x104>
						xYieldPending = pdTRUE;
 80034b4:	9b01      	ldr	r3, [sp, #4]
 80034b6:	601f      	str	r7, [r3, #0]
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 80034b8:	f8db 3000 	ldr.w	r3, [fp]
 80034bc:	2b00      	cmp	r3, #0
 80034be:	d1d7      	bne.n	8003470 <xTaskResumeAll.part.0+0x3c>
	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 80034c0:	4b2d      	ldr	r3, [pc, #180]	@ (8003578 <xTaskResumeAll.part.0+0x144>)
 80034c2:	681a      	ldr	r2, [r3, #0]
 80034c4:	6812      	ldr	r2, [r2, #0]
 80034c6:	2a00      	cmp	r2, #0
 80034c8:	d03f      	beq.n	800354a <xTaskResumeAll.part.0+0x116>
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 80034ca:	681a      	ldr	r2, [r3, #0]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 80034cc:	4b2b      	ldr	r3, [pc, #172]	@ (800357c <xTaskResumeAll.part.0+0x148>)
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 80034ce:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 80034d0:	68d2      	ldr	r2, [r2, #12]
 80034d2:	6852      	ldr	r2, [r2, #4]
 80034d4:	601a      	str	r2, [r3, #0]
					TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
 80034d6:	4e2a      	ldr	r6, [pc, #168]	@ (8003580 <xTaskResumeAll.part.0+0x14c>)
 80034d8:	6834      	ldr	r4, [r6, #0]
					if( xPendedCounts > ( TickType_t ) 0U )
 80034da:	b194      	cbz	r4, 8003502 <xTaskResumeAll.part.0+0xce>
								xYieldPending = pdTRUE;
 80034dc:	2701      	movs	r7, #1
 80034de:	e006      	b.n	80034ee <xTaskResumeAll.part.0+0xba>
 80034e0:	f7ff fefa 	bl	80032d8 <xTaskIncrementTick.part.0>
							if( xTaskIncrementTick() != pdFALSE )
 80034e4:	b108      	cbz	r0, 80034ea <xTaskResumeAll.part.0+0xb6>
								xYieldPending = pdTRUE;
 80034e6:	9b01      	ldr	r3, [sp, #4]
 80034e8:	601f      	str	r7, [r3, #0]
						} while( xPendedCounts > ( TickType_t ) 0U );
 80034ea:	3c01      	subs	r4, #1
 80034ec:	d008      	beq.n	8003500 <xTaskResumeAll.part.0+0xcc>
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 80034ee:	682b      	ldr	r3, [r5, #0]
 80034f0:	2b00      	cmp	r3, #0
 80034f2:	d0f5      	beq.n	80034e0 <xTaskResumeAll.part.0+0xac>
		++xPendedTicks;
 80034f4:	6833      	ldr	r3, [r6, #0]
						} while( xPendedCounts > ( TickType_t ) 0U );
 80034f6:	3c01      	subs	r4, #1
		++xPendedTicks;
 80034f8:	f103 0301 	add.w	r3, r3, #1
 80034fc:	6033      	str	r3, [r6, #0]
						} while( xPendedCounts > ( TickType_t ) 0U );
 80034fe:	d1f6      	bne.n	80034ee <xTaskResumeAll.part.0+0xba>
						xPendedTicks = 0;
 8003500:	6034      	str	r4, [r6, #0]
				if( xYieldPending != pdFALSE )
 8003502:	9b01      	ldr	r3, [sp, #4]
 8003504:	681b      	ldr	r3, [r3, #0]
 8003506:	b183      	cbz	r3, 800352a <xTaskResumeAll.part.0+0xf6>
					taskYIELD_IF_USING_PREEMPTION();
 8003508:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 800350c:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 8003510:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 8003514:	f3bf 8f4f 	dsb	sy
 8003518:	f3bf 8f6f 	isb	sy
						xAlreadyYielded = pdTRUE;
 800351c:	2401      	movs	r4, #1
	taskEXIT_CRITICAL();
 800351e:	f000 ff1b 	bl	8004358 <vPortExitCritical>
}
 8003522:	4620      	mov	r0, r4
 8003524:	b003      	add	sp, #12
 8003526:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
BaseType_t xAlreadyYielded = pdFALSE;
 800352a:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
 800352c:	f000 ff14 	bl	8004358 <vPortExitCritical>
}
 8003530:	4620      	mov	r0, r4
 8003532:	b003      	add	sp, #12
 8003534:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 8003538:	f8db 3000 	ldr.w	r3, [fp]
 800353c:	2b00      	cmp	r3, #0
 800353e:	d197      	bne.n	8003470 <xTaskResumeAll.part.0+0x3c>
	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8003540:	4b0d      	ldr	r3, [pc, #52]	@ (8003578 <xTaskResumeAll.part.0+0x144>)
 8003542:	681a      	ldr	r2, [r3, #0]
 8003544:	6812      	ldr	r2, [r2, #0]
 8003546:	2a00      	cmp	r2, #0
 8003548:	d1bf      	bne.n	80034ca <xTaskResumeAll.part.0+0x96>
		xNextTaskUnblockTime = portMAX_DELAY;
 800354a:	f04f 32ff 	mov.w	r2, #4294967295
 800354e:	4b0b      	ldr	r3, [pc, #44]	@ (800357c <xTaskResumeAll.part.0+0x148>)
 8003550:	601a      	str	r2, [r3, #0]
 8003552:	e7c0      	b.n	80034d6 <xTaskResumeAll.part.0+0xa2>
 8003554:	4b04      	ldr	r3, [pc, #16]	@ (8003568 <xTaskResumeAll.part.0+0x134>)
 8003556:	9301      	str	r3, [sp, #4]
 8003558:	e7bd      	b.n	80034d6 <xTaskResumeAll.part.0+0xa2>
 800355a:	bf00      	nop
 800355c:	20000978 	.word	0x20000978
 8003560:	2000099c 	.word	0x2000099c
 8003564:	200009cc 	.word	0x200009cc
 8003568:	20000988 	.word	0x20000988
 800356c:	20000994 	.word	0x20000994
 8003570:	20000a10 	.word	0x20000a10
 8003574:	20000a9c 	.word	0x20000a9c
 8003578:	200009e4 	.word	0x200009e4
 800357c:	2000097c 	.word	0x2000097c
 8003580:	2000098c 	.word	0x2000098c

08003584 <xTaskCreateStatic>:
	{
 8003584:	b530      	push	{r4, r5, lr}
 8003586:	b087      	sub	sp, #28
 8003588:	9c0b      	ldr	r4, [sp, #44]	@ 0x2c
		configASSERT( puxStackBuffer != NULL );
 800358a:	b1c4      	cbz	r4, 80035be <xTaskCreateStatic+0x3a>
		configASSERT( pxTaskBuffer != NULL );
 800358c:	9d0c      	ldr	r5, [sp, #48]	@ 0x30
 800358e:	b16d      	cbz	r5, 80035ac <xTaskCreateStatic+0x28>
			volatile size_t xSize = sizeof( StaticTask_t );
 8003590:	25a8      	movs	r5, #168	@ 0xa8
 8003592:	9505      	str	r5, [sp, #20]
			configASSERT( xSize == sizeof( TCB_t ) );
 8003594:	9d05      	ldr	r5, [sp, #20]
 8003596:	2da8      	cmp	r5, #168	@ 0xa8
 8003598:	d01a      	beq.n	80035d0 <xTaskCreateStatic+0x4c>
 800359a:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800359e:	f383 8811 	msr	BASEPRI, r3
 80035a2:	f3bf 8f6f 	isb	sy
 80035a6:	f3bf 8f4f 	dsb	sy
 80035aa:	e7fe      	b.n	80035aa <xTaskCreateStatic+0x26>
 80035ac:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80035b0:	f383 8811 	msr	BASEPRI, r3
 80035b4:	f3bf 8f6f 	isb	sy
 80035b8:	f3bf 8f4f 	dsb	sy
		configASSERT( pxTaskBuffer != NULL );
 80035bc:	e7fe      	b.n	80035bc <xTaskCreateStatic+0x38>
 80035be:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80035c2:	f383 8811 	msr	BASEPRI, r3
 80035c6:	f3bf 8f6f 	isb	sy
 80035ca:	f3bf 8f4f 	dsb	sy
		configASSERT( puxStackBuffer != NULL );
 80035ce:	e7fe      	b.n	80035ce <xTaskCreateStatic+0x4a>
			pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
 80035d0:	9d0c      	ldr	r5, [sp, #48]	@ 0x30
 80035d2:	632c      	str	r4, [r5, #48]	@ 0x30
				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 80035d4:	2402      	movs	r4, #2
			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL );
 80035d6:	9502      	str	r5, [sp, #8]
 80035d8:	9d0a      	ldr	r5, [sp, #40]	@ 0x28
 80035da:	9500      	str	r5, [sp, #0]
			( void ) xSize; /* Prevent lint warning when configASSERT() is not used. */
 80035dc:	9d05      	ldr	r5, [sp, #20]
			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL );
 80035de:	ad04      	add	r5, sp, #16
 80035e0:	9501      	str	r5, [sp, #4]
				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 80035e2:	9d0c      	ldr	r5, [sp, #48]	@ 0x30
 80035e4:	f885 40a5 	strb.w	r4, [r5, #165]	@ 0xa5
			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL );
 80035e8:	f7ff fd9a 	bl	8003120 <prvInitialiseNewTask.constprop.0>
			prvAddNewTaskToReadyList( pxNewTCB );
 80035ec:	980c      	ldr	r0, [sp, #48]	@ 0x30
 80035ee:	f7ff fcaf 	bl	8002f50 <prvAddNewTaskToReadyList>
	}
 80035f2:	9804      	ldr	r0, [sp, #16]
 80035f4:	b007      	add	sp, #28
 80035f6:	bd30      	pop	{r4, r5, pc}

080035f8 <xTaskCreate>:
	{
 80035f8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80035fc:	4607      	mov	r7, r0
 80035fe:	b085      	sub	sp, #20
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
 8003600:	0090      	lsls	r0, r2, #2
	{
 8003602:	4615      	mov	r5, r2
 8003604:	4688      	mov	r8, r1
 8003606:	4699      	mov	r9, r3
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
 8003608:	f000 fffc 	bl	8004604 <pvPortMalloc>
			if( pxStack != NULL )
 800360c:	b1f0      	cbz	r0, 800364c <xTaskCreate+0x54>
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
 800360e:	4604      	mov	r4, r0
 8003610:	20a8      	movs	r0, #168	@ 0xa8
 8003612:	f000 fff7 	bl	8004604 <pvPortMalloc>
				if( pxNewTCB != NULL )
 8003616:	4606      	mov	r6, r0
 8003618:	b1a8      	cbz	r0, 8003646 <xTaskCreate+0x4e>
					pxNewTCB->pxStack = pxStack;
 800361a:	6304      	str	r4, [r0, #48]	@ 0x30
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
 800361c:	2400      	movs	r4, #0
 800361e:	f886 40a5 	strb.w	r4, [r6, #165]	@ 0xa5
			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
 8003622:	9c0d      	ldr	r4, [sp, #52]	@ 0x34
 8003624:	464b      	mov	r3, r9
 8003626:	9401      	str	r4, [sp, #4]
 8003628:	9c0c      	ldr	r4, [sp, #48]	@ 0x30
 800362a:	462a      	mov	r2, r5
 800362c:	4641      	mov	r1, r8
 800362e:	4638      	mov	r0, r7
 8003630:	9602      	str	r6, [sp, #8]
 8003632:	9400      	str	r4, [sp, #0]
 8003634:	f7ff fd74 	bl	8003120 <prvInitialiseNewTask.constprop.0>
			prvAddNewTaskToReadyList( pxNewTCB );
 8003638:	4630      	mov	r0, r6
 800363a:	f7ff fc89 	bl	8002f50 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
 800363e:	2001      	movs	r0, #1
	}
 8003640:	b005      	add	sp, #20
 8003642:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
					vPortFree( pxStack );
 8003646:	4620      	mov	r0, r4
 8003648:	f001 f89a 	bl	8004780 <vPortFree>
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 800364c:	f04f 30ff 	mov.w	r0, #4294967295
	}
 8003650:	b005      	add	sp, #20
 8003652:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8003656:	bf00      	nop

08003658 <vTaskDelay>:
	{
 8003658:	b570      	push	{r4, r5, r6, lr}
		if( xTicksToDelay > ( TickType_t ) 0U )
 800365a:	b950      	cbnz	r0, 8003672 <vTaskDelay+0x1a>
			portYIELD_WITHIN_API();
 800365c:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 8003660:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 8003664:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 8003668:	f3bf 8f4f 	dsb	sy
 800366c:	f3bf 8f6f 	isb	sy
	}
 8003670:	bd70      	pop	{r4, r5, r6, pc}
			configASSERT( uxSchedulerSuspended == 0 );
 8003672:	4d14      	ldr	r5, [pc, #80]	@ (80036c4 <vTaskDelay+0x6c>)
 8003674:	682e      	ldr	r6, [r5, #0]
 8003676:	b146      	cbz	r6, 800368a <vTaskDelay+0x32>
 8003678:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800367c:	f383 8811 	msr	BASEPRI, r3
 8003680:	f3bf 8f6f 	isb	sy
 8003684:	f3bf 8f4f 	dsb	sy
 8003688:	e7fe      	b.n	8003688 <vTaskDelay+0x30>
	++uxSchedulerSuspended;
 800368a:	682b      	ldr	r3, [r5, #0]
 800368c:	4604      	mov	r4, r0
 800368e:	3301      	adds	r3, #1
 8003690:	602b      	str	r3, [r5, #0]
				traceTASK_DELAY();
 8003692:	2023      	movs	r0, #35	@ 0x23
 8003694:	4621      	mov	r1, r4
 8003696:	f001 ffb5 	bl	8005604 <SEGGER_SYSVIEW_RecordU32>
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 800369a:	4631      	mov	r1, r6
 800369c:	4620      	mov	r0, r4
 800369e:	f7ff fcef 	bl	8003080 <prvAddCurrentTaskToDelayedList>
	configASSERT( uxSchedulerSuspended );
 80036a2:	682b      	ldr	r3, [r5, #0]
 80036a4:	b943      	cbnz	r3, 80036b8 <vTaskDelay+0x60>
 80036a6:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80036aa:	f383 8811 	msr	BASEPRI, r3
 80036ae:	f3bf 8f6f 	isb	sy
 80036b2:	f3bf 8f4f 	dsb	sy
 80036b6:	e7fe      	b.n	80036b6 <vTaskDelay+0x5e>
 80036b8:	f7ff febc 	bl	8003434 <xTaskResumeAll.part.0>
		if( xAlreadyYielded == pdFALSE )
 80036bc:	2800      	cmp	r0, #0
 80036be:	d0cd      	beq.n	800365c <vTaskDelay+0x4>
	}
 80036c0:	bd70      	pop	{r4, r5, r6, pc}
 80036c2:	bf00      	nop
 80036c4:	20000978 	.word	0x20000978

080036c8 <vTaskStartScheduler>:
{
 80036c8:	b5f0      	push	{r4, r5, r6, r7, lr}
		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
 80036ca:	2400      	movs	r4, #0
{
 80036cc:	b08b      	sub	sp, #44	@ 0x2c
		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
 80036ce:	aa07      	add	r2, sp, #28
 80036d0:	a906      	add	r1, sp, #24
 80036d2:	a805      	add	r0, sp, #20
		StackType_t *pxIdleTaskStackBuffer = NULL;
 80036d4:	e9cd 4405 	strd	r4, r4, [sp, #20]
		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
 80036d8:	f7fc fd80 	bl	80001dc <vApplicationGetIdleTaskMemory>
		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
 80036dc:	e9dd 3206 	ldrd	r3, r2, [sp, #24]
 80036e0:	9d05      	ldr	r5, [sp, #20]
		configASSERT( puxStackBuffer != NULL );
 80036e2:	b1bb      	cbz	r3, 8003714 <vTaskStartScheduler+0x4c>
		configASSERT( pxTaskBuffer != NULL );
 80036e4:	b16d      	cbz	r5, 8003702 <vTaskStartScheduler+0x3a>
			volatile size_t xSize = sizeof( StaticTask_t );
 80036e6:	21a8      	movs	r1, #168	@ 0xa8
 80036e8:	9109      	str	r1, [sp, #36]	@ 0x24
			configASSERT( xSize == sizeof( TCB_t ) );
 80036ea:	9909      	ldr	r1, [sp, #36]	@ 0x24
 80036ec:	29a8      	cmp	r1, #168	@ 0xa8
 80036ee:	d01a      	beq.n	8003726 <vTaskStartScheduler+0x5e>
 80036f0:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80036f4:	f383 8811 	msr	BASEPRI, r3
 80036f8:	f3bf 8f6f 	isb	sy
 80036fc:	f3bf 8f4f 	dsb	sy
 8003700:	e7fe      	b.n	8003700 <vTaskStartScheduler+0x38>
 8003702:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8003706:	f383 8811 	msr	BASEPRI, r3
 800370a:	f3bf 8f6f 	isb	sy
 800370e:	f3bf 8f4f 	dsb	sy
		configASSERT( pxTaskBuffer != NULL );
 8003712:	e7fe      	b.n	8003712 <vTaskStartScheduler+0x4a>
 8003714:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8003718:	f383 8811 	msr	BASEPRI, r3
 800371c:	f3bf 8f6f 	isb	sy
 8003720:	f3bf 8f4f 	dsb	sy
		configASSERT( puxStackBuffer != NULL );
 8003724:	e7fe      	b.n	8003724 <vTaskStartScheduler+0x5c>
				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 8003726:	f04f 0e02 	mov.w	lr, #2
			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL );
 800372a:	ae08      	add	r6, sp, #32
			pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
 800372c:	632b      	str	r3, [r5, #48]	@ 0x30
				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 800372e:	f885 e0a5 	strb.w	lr, [r5, #165]	@ 0xa5
			( void ) xSize; /* Prevent lint warning when configASSERT() is not used. */
 8003732:	9b09      	ldr	r3, [sp, #36]	@ 0x24
			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL );
 8003734:	4923      	ldr	r1, [pc, #140]	@ (80037c4 <vTaskStartScheduler+0xfc>)
 8003736:	4623      	mov	r3, r4
 8003738:	4823      	ldr	r0, [pc, #140]	@ (80037c8 <vTaskStartScheduler+0x100>)
 800373a:	e9cd 6501 	strd	r6, r5, [sp, #4]
 800373e:	9400      	str	r4, [sp, #0]
 8003740:	f7ff fcee 	bl	8003120 <prvInitialiseNewTask.constprop.0>
			prvAddNewTaskToReadyList( pxNewTCB );
 8003744:	4628      	mov	r0, r5
 8003746:	f7ff fc03 	bl	8002f50 <prvAddNewTaskToReadyList>
		return xReturn;
 800374a:	9b08      	ldr	r3, [sp, #32]
		if( xIdleTaskHandle != NULL )
 800374c:	b17b      	cbz	r3, 800376e <vTaskStartScheduler+0xa6>
			xReturn = xTimerCreateTimerTask();
 800374e:	f000 fc8f 	bl	8004070 <xTimerCreateTimerTask>
	if( xReturn == pdPASS )
 8003752:	2801      	cmp	r0, #1
			xReturn = xTimerCreateTimerTask();
 8003754:	4603      	mov	r3, r0
	if( xReturn == pdPASS )
 8003756:	d00c      	beq.n	8003772 <vTaskStartScheduler+0xaa>
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
 8003758:	3301      	adds	r3, #1
 800375a:	d108      	bne.n	800376e <vTaskStartScheduler+0xa6>
 800375c:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8003760:	f383 8811 	msr	BASEPRI, r3
 8003764:	f3bf 8f6f 	isb	sy
 8003768:	f3bf 8f4f 	dsb	sy
 800376c:	e7fe      	b.n	800376c <vTaskStartScheduler+0xa4>
}
 800376e:	b00b      	add	sp, #44	@ 0x2c
 8003770:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003772:	f04f 0250 	mov.w	r2, #80	@ 0x50
 8003776:	f382 8811 	msr	BASEPRI, r2
 800377a:	f3bf 8f6f 	isb	sy
 800377e:	f3bf 8f4f 	dsb	sy
		xNextTaskUnblockTime = portMAX_DELAY;
 8003782:	f04f 36ff 	mov.w	r6, #4294967295
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
 8003786:	4d11      	ldr	r5, [pc, #68]	@ (80037cc <vTaskStartScheduler+0x104>)
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
 8003788:	4811      	ldr	r0, [pc, #68]	@ (80037d0 <vTaskStartScheduler+0x108>)
		xNextTaskUnblockTime = portMAX_DELAY;
 800378a:	f8df e048 	ldr.w	lr, [pc, #72]	@ 80037d4 <vTaskStartScheduler+0x10c>
		xSchedulerRunning = pdTRUE;
 800378e:	4f12      	ldr	r7, [pc, #72]	@ (80037d8 <vTaskStartScheduler+0x110>)
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
 8003790:	682a      	ldr	r2, [r5, #0]
		xNextTaskUnblockTime = portMAX_DELAY;
 8003792:	f8ce 6000 	str.w	r6, [lr]
		xSchedulerRunning = pdTRUE;
 8003796:	603b      	str	r3, [r7, #0]
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
 8003798:	6004      	str	r4, [r0, #0]
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
 800379a:	4910      	ldr	r1, [pc, #64]	@ (80037dc <vTaskStartScheduler+0x114>)
		traceTASK_SWITCHED_IN();
 800379c:	6828      	ldr	r0, [r5, #0]
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
 800379e:	3254      	adds	r2, #84	@ 0x54
 80037a0:	600a      	str	r2, [r1, #0]
		traceTASK_SWITCHED_IN();
 80037a2:	3034      	adds	r0, #52	@ 0x34
 80037a4:	2205      	movs	r2, #5
 80037a6:	4907      	ldr	r1, [pc, #28]	@ (80037c4 <vTaskStartScheduler+0xfc>)
 80037a8:	f003 fa30 	bl	8006c0c <memcmp>
 80037ac:	b138      	cbz	r0, 80037be <vTaskStartScheduler+0xf6>
 80037ae:	6828      	ldr	r0, [r5, #0]
 80037b0:	f002 f92e 	bl	8005a10 <SEGGER_SYSVIEW_OnTaskStartExec>
}
 80037b4:	b00b      	add	sp, #44	@ 0x2c
 80037b6:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
		if( xPortStartScheduler() != pdFALSE )
 80037ba:	f000 be39 	b.w	8004430 <xPortStartScheduler>
		traceTASK_SWITCHED_IN();
 80037be:	f003 f85f 	bl	8006880 <SEGGER_SYSVIEW_OnIdle>
 80037c2:	e7f7      	b.n	80037b4 <vTaskStartScheduler+0xec>
 80037c4:	08006e60 	.word	0x08006e60
 80037c8:	08003239 	.word	0x08003239
 80037cc:	20000a9c 	.word	0x20000a9c
 80037d0:	20000998 	.word	0x20000998
 80037d4:	2000097c 	.word	0x2000097c
 80037d8:	20000990 	.word	0x20000990
 80037dc:	20000034 	.word	0x20000034

080037e0 <vTaskSuspendAll>:
	++uxSchedulerSuspended;
 80037e0:	4a02      	ldr	r2, [pc, #8]	@ (80037ec <vTaskSuspendAll+0xc>)
 80037e2:	6813      	ldr	r3, [r2, #0]
 80037e4:	3301      	adds	r3, #1
 80037e6:	6013      	str	r3, [r2, #0]
}
 80037e8:	4770      	bx	lr
 80037ea:	bf00      	nop
 80037ec:	20000978 	.word	0x20000978

080037f0 <xTaskResumeAll>:
	configASSERT( uxSchedulerSuspended );
 80037f0:	4b06      	ldr	r3, [pc, #24]	@ (800380c <xTaskResumeAll+0x1c>)
 80037f2:	681b      	ldr	r3, [r3, #0]
 80037f4:	b943      	cbnz	r3, 8003808 <xTaskResumeAll+0x18>
 80037f6:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80037fa:	f383 8811 	msr	BASEPRI, r3
 80037fe:	f3bf 8f6f 	isb	sy
 8003802:	f3bf 8f4f 	dsb	sy
 8003806:	e7fe      	b.n	8003806 <xTaskResumeAll+0x16>
 8003808:	f7ff be14 	b.w	8003434 <xTaskResumeAll.part.0>
 800380c:	20000978 	.word	0x20000978

08003810 <xTaskGetTickCount>:
		xTicks = xTickCount;
 8003810:	4b01      	ldr	r3, [pc, #4]	@ (8003818 <xTaskGetTickCount+0x8>)
 8003812:	6818      	ldr	r0, [r3, #0]
}
 8003814:	4770      	bx	lr
 8003816:	bf00      	nop
 8003818:	20000998 	.word	0x20000998

0800381c <xTaskGetTickCountFromISR>:
{
 800381c:	b508      	push	{r3, lr}
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 800381e:	f000 fe7d 	bl	800451c <vPortValidateInterruptPriority>
		xReturn = xTickCount;
 8003822:	4b01      	ldr	r3, [pc, #4]	@ (8003828 <xTaskGetTickCountFromISR+0xc>)
 8003824:	6818      	ldr	r0, [r3, #0]
}
 8003826:	bd08      	pop	{r3, pc}
 8003828:	20000998 	.word	0x20000998

0800382c <xTaskIncrementTick>:
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800382c:	4b05      	ldr	r3, [pc, #20]	@ (8003844 <xTaskIncrementTick+0x18>)
 800382e:	681b      	ldr	r3, [r3, #0]
 8003830:	b90b      	cbnz	r3, 8003836 <xTaskIncrementTick+0xa>
 8003832:	f7ff bd51 	b.w	80032d8 <xTaskIncrementTick.part.0>
		++xPendedTicks;
 8003836:	4a04      	ldr	r2, [pc, #16]	@ (8003848 <xTaskIncrementTick+0x1c>)
}
 8003838:	2000      	movs	r0, #0
		++xPendedTicks;
 800383a:	6813      	ldr	r3, [r2, #0]
 800383c:	3301      	adds	r3, #1
 800383e:	6013      	str	r3, [r2, #0]
}
 8003840:	4770      	bx	lr
 8003842:	bf00      	nop
 8003844:	20000978 	.word	0x20000978
 8003848:	2000098c 	.word	0x2000098c

0800384c <vTaskSwitchContext>:
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 800384c:	4b20      	ldr	r3, [pc, #128]	@ (80038d0 <vTaskSwitchContext+0x84>)
 800384e:	681b      	ldr	r3, [r3, #0]
 8003850:	b11b      	cbz	r3, 800385a <vTaskSwitchContext+0xe>
		xYieldPending = pdTRUE;
 8003852:	2201      	movs	r2, #1
 8003854:	4b1f      	ldr	r3, [pc, #124]	@ (80038d4 <vTaskSwitchContext+0x88>)
 8003856:	601a      	str	r2, [r3, #0]
 8003858:	4770      	bx	lr
		xYieldPending = pdFALSE;
 800385a:	491e      	ldr	r1, [pc, #120]	@ (80038d4 <vTaskSwitchContext+0x88>)
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 800385c:	4a1e      	ldr	r2, [pc, #120]	@ (80038d8 <vTaskSwitchContext+0x8c>)
		xYieldPending = pdFALSE;
 800385e:	600b      	str	r3, [r1, #0]
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8003860:	6813      	ldr	r3, [r2, #0]
		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
 8003862:	fab3 f383 	clz	r3, r3
 8003866:	b2db      	uxtb	r3, r3
 8003868:	f1c3 031f 	rsb	r3, r3, #31
 800386c:	491b      	ldr	r1, [pc, #108]	@ (80038dc <vTaskSwitchContext+0x90>)
 800386e:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8003872:	009a      	lsls	r2, r3, #2
 8003874:	5888      	ldr	r0, [r1, r2]
 8003876:	eb01 0383 	add.w	r3, r1, r3, lsl #2
 800387a:	b940      	cbnz	r0, 800388e <vTaskSwitchContext+0x42>
	__asm volatile
 800387c:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8003880:	f383 8811 	msr	BASEPRI, r3
 8003884:	f3bf 8f6f 	isb	sy
 8003888:	f3bf 8f4f 	dsb	sy
		configASSERT( pxTaskBuffer != NULL );
 800388c:	e7fe      	b.n	800388c <vTaskSwitchContext+0x40>
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 800388e:	6858      	ldr	r0, [r3, #4]
 8003890:	3208      	adds	r2, #8
 8003892:	6840      	ldr	r0, [r0, #4]
 8003894:	440a      	add	r2, r1
 8003896:	4290      	cmp	r0, r2
{
 8003898:	b510      	push	{r4, lr}
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 800389a:	6058      	str	r0, [r3, #4]
 800389c:	bf08      	it	eq
 800389e:	6840      	ldreq	r0, [r0, #4]
 80038a0:	4c0f      	ldr	r4, [pc, #60]	@ (80038e0 <vTaskSwitchContext+0x94>)
 80038a2:	bf08      	it	eq
 80038a4:	6058      	streq	r0, [r3, #4]
 80038a6:	68c3      	ldr	r3, [r0, #12]
		traceTASK_SWITCHED_IN();
 80038a8:	2205      	movs	r2, #5
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 80038aa:	6023      	str	r3, [r4, #0]
		traceTASK_SWITCHED_IN();
 80038ac:	6820      	ldr	r0, [r4, #0]
 80038ae:	490d      	ldr	r1, [pc, #52]	@ (80038e4 <vTaskSwitchContext+0x98>)
 80038b0:	3034      	adds	r0, #52	@ 0x34
 80038b2:	f003 f9ab 	bl	8006c0c <memcmp>
 80038b6:	b930      	cbnz	r0, 80038c6 <vTaskSwitchContext+0x7a>
 80038b8:	f002 ffe2 	bl	8006880 <SEGGER_SYSVIEW_OnIdle>
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
 80038bc:	6823      	ldr	r3, [r4, #0]
 80038be:	4a0a      	ldr	r2, [pc, #40]	@ (80038e8 <vTaskSwitchContext+0x9c>)
 80038c0:	3354      	adds	r3, #84	@ 0x54
 80038c2:	6013      	str	r3, [r2, #0]
}
 80038c4:	bd10      	pop	{r4, pc}
		traceTASK_SWITCHED_IN();
 80038c6:	6820      	ldr	r0, [r4, #0]
 80038c8:	f002 f8a2 	bl	8005a10 <SEGGER_SYSVIEW_OnTaskStartExec>
 80038cc:	e7f6      	b.n	80038bc <vTaskSwitchContext+0x70>
 80038ce:	bf00      	nop
 80038d0:	20000978 	.word	0x20000978
 80038d4:	20000988 	.word	0x20000988
 80038d8:	20000994 	.word	0x20000994
 80038dc:	20000a10 	.word	0x20000a10
 80038e0:	20000a9c 	.word	0x20000a9c
 80038e4:	08006e60 	.word	0x08006e60
 80038e8:	20000034 	.word	0x20000034

080038ec <vTaskPlaceOnEventList>:
	configASSERT( pxEventList );
 80038ec:	b348      	cbz	r0, 8003942 <vTaskPlaceOnEventList+0x56>
{
 80038ee:	b570      	push	{r4, r5, r6, lr}
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 80038f0:	4d25      	ldr	r5, [pc, #148]	@ (8003988 <vTaskPlaceOnEventList+0x9c>)
 80038f2:	460c      	mov	r4, r1
 80038f4:	6829      	ldr	r1, [r5, #0]
 80038f6:	3118      	adds	r1, #24
 80038f8:	f7fe fc1c 	bl	8002134 <vListInsert>
const TickType_t xConstTickCount = xTickCount;
 80038fc:	4b23      	ldr	r3, [pc, #140]	@ (800398c <vTaskPlaceOnEventList+0xa0>)
 80038fe:	681e      	ldr	r6, [r3, #0]
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8003900:	6828      	ldr	r0, [r5, #0]
 8003902:	3004      	adds	r0, #4
 8003904:	f7fe fc2e 	bl	8002164 <uxListRemove>
 8003908:	b940      	cbnz	r0, 800391c <vTaskPlaceOnEventList+0x30>
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority ); /*lint !e931 pxCurrentTCB cannot change as it is the calling task.  pxCurrentTCB->uxPriority and uxTopReadyPriority cannot change as called with scheduler suspended or in a critical section. */
 800390a:	2201      	movs	r2, #1
 800390c:	682b      	ldr	r3, [r5, #0]
 800390e:	4920      	ldr	r1, [pc, #128]	@ (8003990 <vTaskPlaceOnEventList+0xa4>)
 8003910:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8003912:	409a      	lsls	r2, r3
 8003914:	680b      	ldr	r3, [r1, #0]
 8003916:	ea23 0302 	bic.w	r3, r3, r2
 800391a:	600b      	str	r3, [r1, #0]
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 800391c:	1c63      	adds	r3, r4, #1
 800391e:	d019      	beq.n	8003954 <vTaskPlaceOnEventList+0x68>
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 8003920:	682b      	ldr	r3, [r5, #0]
 8003922:	19a4      	adds	r4, r4, r6
        traceMOVED_TASK_TO_OVERFLOW_DELAYED_LIST();
 8003924:	f04f 0104 	mov.w	r1, #4
 8003928:	6828      	ldr	r0, [r5, #0]
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 800392a:	605c      	str	r4, [r3, #4]
			if( xTimeToWake < xConstTickCount )
 800392c:	d31d      	bcc.n	800396a <vTaskPlaceOnEventList+0x7e>
        traceMOVED_TASK_TO_OVERFLOW_DELAYED_LIST();
 800392e:	f002 f8b3 	bl	8005a98 <SEGGER_SYSVIEW_OnTaskStopReady>
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8003932:	4b18      	ldr	r3, [pc, #96]	@ (8003994 <vTaskPlaceOnEventList+0xa8>)
 8003934:	6818      	ldr	r0, [r3, #0]
 8003936:	6829      	ldr	r1, [r5, #0]
}
 8003938:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 800393c:	3104      	adds	r1, #4
 800393e:	f7fe bbf9 	b.w	8002134 <vListInsert>
 8003942:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8003946:	f383 8811 	msr	BASEPRI, r3
 800394a:	f3bf 8f6f 	isb	sy
 800394e:	f3bf 8f4f 	dsb	sy
	configASSERT( pxEventList );
 8003952:	e7fe      	b.n	8003952 <vTaskPlaceOnEventList+0x66>
      traceMOVED_TASK_TO_SUSPENDED_LIST(pxCurrentTCB);
 8003954:	6828      	ldr	r0, [r5, #0]
 8003956:	211b      	movs	r1, #27
 8003958:	f002 f89e 	bl	8005a98 <SEGGER_SYSVIEW_OnTaskStopReady>
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 800395c:	6829      	ldr	r1, [r5, #0]
 800395e:	480e      	ldr	r0, [pc, #56]	@ (8003998 <vTaskPlaceOnEventList+0xac>)
 8003960:	3104      	adds	r1, #4
}
 8003962:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8003966:	f7fe bbd7 	b.w	8002118 <vListInsertEnd>
        traceMOVED_TASK_TO_DELAYED_LIST();
 800396a:	f002 f895 	bl	8005a98 <SEGGER_SYSVIEW_OnTaskStopReady>
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 800396e:	4b0b      	ldr	r3, [pc, #44]	@ (800399c <vTaskPlaceOnEventList+0xb0>)
 8003970:	6818      	ldr	r0, [r3, #0]
 8003972:	6829      	ldr	r1, [r5, #0]
 8003974:	3104      	adds	r1, #4
 8003976:	f7fe fbdd 	bl	8002134 <vListInsert>
				if( xTimeToWake < xNextTaskUnblockTime )
 800397a:	4b09      	ldr	r3, [pc, #36]	@ (80039a0 <vTaskPlaceOnEventList+0xb4>)
 800397c:	681a      	ldr	r2, [r3, #0]
 800397e:	4294      	cmp	r4, r2
					xNextTaskUnblockTime = xTimeToWake;
 8003980:	bf38      	it	cc
 8003982:	601c      	strcc	r4, [r3, #0]
}
 8003984:	bd70      	pop	{r4, r5, r6, pc}
 8003986:	bf00      	nop
 8003988:	20000a9c 	.word	0x20000a9c
 800398c:	20000998 	.word	0x20000998
 8003990:	20000994 	.word	0x20000994
 8003994:	200009e0 	.word	0x200009e0
 8003998:	200009a0 	.word	0x200009a0
 800399c:	200009e4 	.word	0x200009e4
 80039a0:	2000097c 	.word	0x2000097c

080039a4 <vTaskPlaceOnEventListRestricted>:
	{
 80039a4:	b538      	push	{r3, r4, r5, lr}
		configASSERT( pxEventList );
 80039a6:	b198      	cbz	r0, 80039d0 <vTaskPlaceOnEventListRestricted+0x2c>
		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 80039a8:	4615      	mov	r5, r2
 80039aa:	4b0e      	ldr	r3, [pc, #56]	@ (80039e4 <vTaskPlaceOnEventListRestricted+0x40>)
 80039ac:	460c      	mov	r4, r1
 80039ae:	6819      	ldr	r1, [r3, #0]
 80039b0:	3118      	adds	r1, #24
 80039b2:	f7fe fbb1 	bl	8002118 <vListInsertEnd>
			xTicksToWait = portMAX_DELAY;
 80039b6:	2d00      	cmp	r5, #0
 80039b8:	bf18      	it	ne
 80039ba:	f04f 34ff 	movne.w	r4, #4294967295
		traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
 80039be:	2024      	movs	r0, #36	@ 0x24
 80039c0:	f002 ffec 	bl	800699c <SEGGER_SYSVIEW_RecordVoid>
		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
 80039c4:	4629      	mov	r1, r5
 80039c6:	4620      	mov	r0, r4
	}
 80039c8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
 80039cc:	f7ff bb58 	b.w	8003080 <prvAddCurrentTaskToDelayedList>
 80039d0:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80039d4:	f383 8811 	msr	BASEPRI, r3
 80039d8:	f3bf 8f6f 	isb	sy
 80039dc:	f3bf 8f4f 	dsb	sy
		configASSERT( pxEventList );
 80039e0:	e7fe      	b.n	80039e0 <vTaskPlaceOnEventListRestricted+0x3c>
 80039e2:	bf00      	nop
 80039e4:	20000a9c 	.word	0x20000a9c

080039e8 <xTaskRemoveFromEventList>:
{
 80039e8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 80039ea:	68c3      	ldr	r3, [r0, #12]
 80039ec:	68dc      	ldr	r4, [r3, #12]
	configASSERT( pxUnblockedTCB );
 80039ee:	b36c      	cbz	r4, 8003a4c <xTaskRemoveFromEventList+0x64>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 80039f0:	f104 0518 	add.w	r5, r4, #24
 80039f4:	4628      	mov	r0, r5
 80039f6:	f7fe fbb5 	bl	8002164 <uxListRemove>
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 80039fa:	4b1a      	ldr	r3, [pc, #104]	@ (8003a64 <xTaskRemoveFromEventList+0x7c>)
 80039fc:	681b      	ldr	r3, [r3, #0]
 80039fe:	b173      	cbz	r3, 8003a1e <xTaskRemoveFromEventList+0x36>
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 8003a00:	4629      	mov	r1, r5
 8003a02:	4819      	ldr	r0, [pc, #100]	@ (8003a68 <xTaskRemoveFromEventList+0x80>)
 8003a04:	f7fe fb88 	bl	8002118 <vListInsertEnd>
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 8003a08:	4b18      	ldr	r3, [pc, #96]	@ (8003a6c <xTaskRemoveFromEventList+0x84>)
 8003a0a:	6ae2      	ldr	r2, [r4, #44]	@ 0x2c
 8003a0c:	681b      	ldr	r3, [r3, #0]
 8003a0e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8003a10:	429a      	cmp	r2, r3
 8003a12:	d924      	bls.n	8003a5e <xTaskRemoveFromEventList+0x76>
		xYieldPending = pdTRUE;
 8003a14:	2301      	movs	r3, #1
 8003a16:	4a16      	ldr	r2, [pc, #88]	@ (8003a70 <xTaskRemoveFromEventList+0x88>)
		xReturn = pdTRUE;
 8003a18:	4618      	mov	r0, r3
		xYieldPending = pdTRUE;
 8003a1a:	6013      	str	r3, [r2, #0]
}
 8003a1c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 8003a1e:	1d26      	adds	r6, r4, #4
 8003a20:	4630      	mov	r0, r6
 8003a22:	f7fe fb9f 	bl	8002164 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
 8003a26:	4620      	mov	r0, r4
 8003a28:	f002 f814 	bl	8005a54 <SEGGER_SYSVIEW_OnTaskStartReady>
 8003a2c:	2201      	movs	r2, #1
 8003a2e:	4d11      	ldr	r5, [pc, #68]	@ (8003a74 <xTaskRemoveFromEventList+0x8c>)
 8003a30:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
 8003a32:	682f      	ldr	r7, [r5, #0]
 8003a34:	4810      	ldr	r0, [pc, #64]	@ (8003a78 <xTaskRemoveFromEventList+0x90>)
 8003a36:	409a      	lsls	r2, r3
 8003a38:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8003a3c:	433a      	orrs	r2, r7
 8003a3e:	4631      	mov	r1, r6
 8003a40:	eb00 0083 	add.w	r0, r0, r3, lsl #2
 8003a44:	602a      	str	r2, [r5, #0]
 8003a46:	f7fe fb67 	bl	8002118 <vListInsertEnd>
 8003a4a:	e7dd      	b.n	8003a08 <xTaskRemoveFromEventList+0x20>
 8003a4c:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8003a50:	f383 8811 	msr	BASEPRI, r3
 8003a54:	f3bf 8f6f 	isb	sy
 8003a58:	f3bf 8f4f 	dsb	sy
	configASSERT( pxUnblockedTCB );
 8003a5c:	e7fe      	b.n	8003a5c <xTaskRemoveFromEventList+0x74>
		xReturn = pdFALSE;
 8003a5e:	2000      	movs	r0, #0
}
 8003a60:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8003a62:	bf00      	nop
 8003a64:	20000978 	.word	0x20000978
 8003a68:	200009cc 	.word	0x200009cc
 8003a6c:	20000a9c 	.word	0x20000a9c
 8003a70:	20000988 	.word	0x20000988
 8003a74:	20000994 	.word	0x20000994
 8003a78:	20000a10 	.word	0x20000a10

08003a7c <vTaskInternalSetTimeOutState>:
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 8003a7c:	4a03      	ldr	r2, [pc, #12]	@ (8003a8c <vTaskInternalSetTimeOutState+0x10>)
	pxTimeOut->xTimeOnEntering = xTickCount;
 8003a7e:	4b04      	ldr	r3, [pc, #16]	@ (8003a90 <vTaskInternalSetTimeOutState+0x14>)
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 8003a80:	6812      	ldr	r2, [r2, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
 8003a82:	681b      	ldr	r3, [r3, #0]
 8003a84:	e9c0 2300 	strd	r2, r3, [r0]
}
 8003a88:	4770      	bx	lr
 8003a8a:	bf00      	nop
 8003a8c:	20000984 	.word	0x20000984
 8003a90:	20000998 	.word	0x20000998

08003a94 <xTaskCheckForTimeOut>:
{
 8003a94:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	configASSERT( pxTimeOut );
 8003a96:	b1f8      	cbz	r0, 8003ad8 <xTaskCheckForTimeOut+0x44>
	configASSERT( pxTicksToWait );
 8003a98:	460d      	mov	r5, r1
 8003a9a:	b1a1      	cbz	r1, 8003ac6 <xTaskCheckForTimeOut+0x32>
 8003a9c:	4604      	mov	r4, r0
	taskENTER_CRITICAL();
 8003a9e:	f000 fc39 	bl	8004314 <vPortEnterCritical>
			if( *pxTicksToWait == portMAX_DELAY )
 8003aa2:	682b      	ldr	r3, [r5, #0]
		const TickType_t xConstTickCount = xTickCount;
 8003aa4:	4a19      	ldr	r2, [pc, #100]	@ (8003b0c <xTaskCheckForTimeOut+0x78>)
			if( *pxTicksToWait == portMAX_DELAY )
 8003aa6:	1c58      	adds	r0, r3, #1
		const TickType_t xConstTickCount = xTickCount;
 8003aa8:	6811      	ldr	r1, [r2, #0]
			if( *pxTicksToWait == portMAX_DELAY )
 8003aaa:	d029      	beq.n	8003b00 <xTaskCheckForTimeOut+0x6c>
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 8003aac:	e9d4 c000 	ldrd	ip, r0, [r4]
 8003ab0:	4e17      	ldr	r6, [pc, #92]	@ (8003b10 <xTaskCheckForTimeOut+0x7c>)
 8003ab2:	6837      	ldr	r7, [r6, #0]
 8003ab4:	45bc      	cmp	ip, r7
 8003ab6:	d018      	beq.n	8003aea <xTaskCheckForTimeOut+0x56>
 8003ab8:	4288      	cmp	r0, r1
 8003aba:	d816      	bhi.n	8003aea <xTaskCheckForTimeOut+0x56>
			xReturn = pdTRUE;
 8003abc:	2401      	movs	r4, #1
	taskEXIT_CRITICAL();
 8003abe:	f000 fc4b 	bl	8004358 <vPortExitCritical>
}
 8003ac2:	4620      	mov	r0, r4
 8003ac4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8003ac6:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8003aca:	f383 8811 	msr	BASEPRI, r3
 8003ace:	f3bf 8f6f 	isb	sy
 8003ad2:	f3bf 8f4f 	dsb	sy
	configASSERT( pxTicksToWait );
 8003ad6:	e7fe      	b.n	8003ad6 <xTaskCheckForTimeOut+0x42>
 8003ad8:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8003adc:	f383 8811 	msr	BASEPRI, r3
 8003ae0:	f3bf 8f6f 	isb	sy
 8003ae4:	f3bf 8f4f 	dsb	sy
	configASSERT( pxTimeOut );
 8003ae8:	e7fe      	b.n	8003ae8 <xTaskCheckForTimeOut+0x54>
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 8003aea:	eba1 0e00 	sub.w	lr, r1, r0
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
 8003aee:	4573      	cmp	r3, lr
 8003af0:	d908      	bls.n	8003b04 <xTaskCheckForTimeOut+0x70>
			*pxTicksToWait -= xElapsedTime;
 8003af2:	1a5b      	subs	r3, r3, r1
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 8003af4:	6831      	ldr	r1, [r6, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
 8003af6:	6812      	ldr	r2, [r2, #0]
			*pxTicksToWait -= xElapsedTime;
 8003af8:	4403      	add	r3, r0
 8003afa:	602b      	str	r3, [r5, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
 8003afc:	e9c4 1200 	strd	r1, r2, [r4]
				xReturn = pdFALSE;
 8003b00:	2400      	movs	r4, #0
 8003b02:	e7dc      	b.n	8003abe <xTaskCheckForTimeOut+0x2a>
			*pxTicksToWait = 0;
 8003b04:	2300      	movs	r3, #0
 8003b06:	602b      	str	r3, [r5, #0]
			xReturn = pdTRUE;
 8003b08:	e7d8      	b.n	8003abc <xTaskCheckForTimeOut+0x28>
 8003b0a:	bf00      	nop
 8003b0c:	20000998 	.word	0x20000998
 8003b10:	20000984 	.word	0x20000984

08003b14 <vTaskMissedYield>:
	xYieldPending = pdTRUE;
 8003b14:	2201      	movs	r2, #1
 8003b16:	4b01      	ldr	r3, [pc, #4]	@ (8003b1c <vTaskMissedYield+0x8>)
 8003b18:	601a      	str	r2, [r3, #0]
}
 8003b1a:	4770      	bx	lr
 8003b1c:	20000988 	.word	0x20000988

08003b20 <xTaskGetSchedulerState>:
		if( xSchedulerRunning == pdFALSE )
 8003b20:	4b05      	ldr	r3, [pc, #20]	@ (8003b38 <xTaskGetSchedulerState+0x18>)
 8003b22:	681b      	ldr	r3, [r3, #0]
 8003b24:	b133      	cbz	r3, 8003b34 <xTaskGetSchedulerState+0x14>
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8003b26:	4b05      	ldr	r3, [pc, #20]	@ (8003b3c <xTaskGetSchedulerState+0x1c>)
 8003b28:	6818      	ldr	r0, [r3, #0]
 8003b2a:	fab0 f080 	clz	r0, r0
 8003b2e:	0940      	lsrs	r0, r0, #5
 8003b30:	0040      	lsls	r0, r0, #1
 8003b32:	4770      	bx	lr
			xReturn = taskSCHEDULER_NOT_STARTED;
 8003b34:	2001      	movs	r0, #1
	}
 8003b36:	4770      	bx	lr
 8003b38:	20000990 	.word	0x20000990
 8003b3c:	20000978 	.word	0x20000978

08003b40 <xTaskPriorityInherit>:
	{
 8003b40:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		if( pxMutexHolder != NULL )
 8003b44:	4604      	mov	r4, r0
 8003b46:	b1e8      	cbz	r0, 8003b84 <xTaskPriorityInherit+0x44>
			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
 8003b48:	4d23      	ldr	r5, [pc, #140]	@ (8003bd8 <xTaskPriorityInherit+0x98>)
 8003b4a:	6ac3      	ldr	r3, [r0, #44]	@ 0x2c
 8003b4c:	682a      	ldr	r2, [r5, #0]
 8003b4e:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
 8003b50:	4293      	cmp	r3, r2
 8003b52:	d219      	bcs.n	8003b88 <xTaskPriorityInherit+0x48>
				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 8003b54:	6982      	ldr	r2, [r0, #24]
 8003b56:	2a00      	cmp	r2, #0
 8003b58:	db04      	blt.n	8003b64 <xTaskPriorityInherit+0x24>
					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8003b5a:	682a      	ldr	r2, [r5, #0]
 8003b5c:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
 8003b5e:	f1c2 0207 	rsb	r2, r2, #7
 8003b62:	6182      	str	r2, [r0, #24]
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
 8003b64:	4e1d      	ldr	r6, [pc, #116]	@ (8003bdc <xTaskPriorityInherit+0x9c>)
 8003b66:	6962      	ldr	r2, [r4, #20]
 8003b68:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8003b6c:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 8003b70:	429a      	cmp	r2, r3
 8003b72:	d012      	beq.n	8003b9a <xTaskPriorityInherit+0x5a>
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 8003b74:	682b      	ldr	r3, [r5, #0]
 8003b76:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8003b78:	62e3      	str	r3, [r4, #44]	@ 0x2c
				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );
 8003b7a:	2049      	movs	r0, #73	@ 0x49
 8003b7c:	4621      	mov	r1, r4
 8003b7e:	f001 fd41 	bl	8005604 <SEGGER_SYSVIEW_RecordU32>
				xReturn = pdTRUE;
 8003b82:	2001      	movs	r0, #1
	}
 8003b84:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
 8003b88:	682b      	ldr	r3, [r5, #0]
 8003b8a:	6cc0      	ldr	r0, [r0, #76]	@ 0x4c
 8003b8c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8003b8e:	4298      	cmp	r0, r3
 8003b90:	bf2c      	ite	cs
 8003b92:	2000      	movcs	r0, #0
 8003b94:	2001      	movcc	r0, #1
	}
 8003b96:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8003b9a:	f104 0804 	add.w	r8, r4, #4
 8003b9e:	4640      	mov	r0, r8
 8003ba0:	f7fe fae0 	bl	8002164 <uxListRemove>
						portRESET_READY_PRIORITY( pxMutexHolderTCB->uxPriority, uxTopReadyPriority );
 8003ba4:	4f0e      	ldr	r7, [pc, #56]	@ (8003be0 <xTaskPriorityInherit+0xa0>)
					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8003ba6:	b930      	cbnz	r0, 8003bb6 <xTaskPriorityInherit+0x76>
						portRESET_READY_PRIORITY( pxMutexHolderTCB->uxPriority, uxTopReadyPriority );
 8003ba8:	2201      	movs	r2, #1
 8003baa:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
 8003bac:	409a      	lsls	r2, r3
 8003bae:	683b      	ldr	r3, [r7, #0]
 8003bb0:	ea23 0302 	bic.w	r3, r3, r2
 8003bb4:	603b      	str	r3, [r7, #0]
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 8003bb6:	682b      	ldr	r3, [r5, #0]
					prvReaddTaskToReadyList( pxMutexHolderTCB );
 8003bb8:	683d      	ldr	r5, [r7, #0]
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 8003bba:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
					prvReaddTaskToReadyList( pxMutexHolderTCB );
 8003bbc:	2301      	movs	r3, #1
 8003bbe:	eb02 0082 	add.w	r0, r2, r2, lsl #2
 8003bc2:	4093      	lsls	r3, r2
 8003bc4:	432b      	orrs	r3, r5
 8003bc6:	4641      	mov	r1, r8
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 8003bc8:	62e2      	str	r2, [r4, #44]	@ 0x2c
					prvReaddTaskToReadyList( pxMutexHolderTCB );
 8003bca:	eb06 0080 	add.w	r0, r6, r0, lsl #2
 8003bce:	603b      	str	r3, [r7, #0]
 8003bd0:	f7fe faa2 	bl	8002118 <vListInsertEnd>
 8003bd4:	e7d1      	b.n	8003b7a <xTaskPriorityInherit+0x3a>
 8003bd6:	bf00      	nop
 8003bd8:	20000a9c 	.word	0x20000a9c
 8003bdc:	20000a10 	.word	0x20000a10
 8003be0:	20000994 	.word	0x20000994

08003be4 <xTaskPriorityDisinherit>:
		if( pxMutexHolder != NULL )
 8003be4:	b320      	cbz	r0, 8003c30 <xTaskPriorityDisinherit+0x4c>
			configASSERT( pxTCB == pxCurrentTCB );
 8003be6:	4b2b      	ldr	r3, [pc, #172]	@ (8003c94 <xTaskPriorityDisinherit+0xb0>)
	{
 8003be8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
			configASSERT( pxTCB == pxCurrentTCB );
 8003bec:	681b      	ldr	r3, [r3, #0]
 8003bee:	4604      	mov	r4, r0
 8003bf0:	4283      	cmp	r3, r0
 8003bf2:	d008      	beq.n	8003c06 <xTaskPriorityDisinherit+0x22>
 8003bf4:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8003bf8:	f383 8811 	msr	BASEPRI, r3
 8003bfc:	f3bf 8f6f 	isb	sy
 8003c00:	f3bf 8f4f 	dsb	sy
 8003c04:	e7fe      	b.n	8003c04 <xTaskPriorityDisinherit+0x20>
			configASSERT( pxTCB->uxMutexesHeld );
 8003c06:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8003c08:	b14b      	cbz	r3, 8003c1e <xTaskPriorityDisinherit+0x3a>
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 8003c0a:	6ac1      	ldr	r1, [r0, #44]	@ 0x2c
 8003c0c:	6cc2      	ldr	r2, [r0, #76]	@ 0x4c
			( pxTCB->uxMutexesHeld )--;
 8003c0e:	3b01      	subs	r3, #1
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 8003c10:	4291      	cmp	r1, r2
			( pxTCB->uxMutexesHeld )--;
 8003c12:	6503      	str	r3, [r0, #80]	@ 0x50
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 8003c14:	d000      	beq.n	8003c18 <xTaskPriorityDisinherit+0x34>
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 8003c16:	b16b      	cbz	r3, 8003c34 <xTaskPriorityDisinherit+0x50>
	BaseType_t xReturn = pdFALSE;
 8003c18:	2000      	movs	r0, #0
	}
 8003c1a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8003c1e:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8003c22:	f383 8811 	msr	BASEPRI, r3
 8003c26:	f3bf 8f6f 	isb	sy
 8003c2a:	f3bf 8f4f 	dsb	sy
			configASSERT( pxTCB->uxMutexesHeld );
 8003c2e:	e7fe      	b.n	8003c2e <xTaskPriorityDisinherit+0x4a>
	BaseType_t xReturn = pdFALSE;
 8003c30:	2000      	movs	r0, #0
	}
 8003c32:	4770      	bx	lr
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8003c34:	f100 0804 	add.w	r8, r0, #4
 8003c38:	4640      	mov	r0, r8
 8003c3a:	f7fe fa93 	bl	8002164 <uxListRemove>
 8003c3e:	b1c8      	cbz	r0, 8003c74 <xTaskPriorityDisinherit+0x90>
 8003c40:	4f15      	ldr	r7, [pc, #84]	@ (8003c98 <xTaskPriorityDisinherit+0xb4>)
 8003c42:	4e16      	ldr	r6, [pc, #88]	@ (8003c9c <xTaskPriorityDisinherit+0xb8>)
					prvReaddTaskToReadyList( pxTCB );
 8003c44:	2501      	movs	r5, #1
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
 8003c46:	4621      	mov	r1, r4
 8003c48:	204a      	movs	r0, #74	@ 0x4a
 8003c4a:	f001 fcdb 	bl	8005604 <SEGGER_SYSVIEW_RecordU32>
					pxTCB->uxPriority = pxTCB->uxBasePriority;
 8003c4e:	6ce0      	ldr	r0, [r4, #76]	@ 0x4c
					prvReaddTaskToReadyList( pxTCB );
 8003c50:	6832      	ldr	r2, [r6, #0]
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8003c52:	f1c0 0307 	rsb	r3, r0, #7
					pxTCB->uxPriority = pxTCB->uxBasePriority;
 8003c56:	62e0      	str	r0, [r4, #44]	@ 0x2c
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8003c58:	61a3      	str	r3, [r4, #24]
					prvReaddTaskToReadyList( pxTCB );
 8003c5a:	fa05 f300 	lsl.w	r3, r5, r0
 8003c5e:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8003c62:	4313      	orrs	r3, r2
 8003c64:	eb07 0080 	add.w	r0, r7, r0, lsl #2
 8003c68:	4641      	mov	r1, r8
 8003c6a:	6033      	str	r3, [r6, #0]
 8003c6c:	f7fe fa54 	bl	8002118 <vListInsertEnd>
					xReturn = pdTRUE;
 8003c70:	4628      	mov	r0, r5
		return xReturn;
 8003c72:	e7d2      	b.n	8003c1a <xTaskPriorityDisinherit+0x36>
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 8003c74:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
 8003c76:	4f08      	ldr	r7, [pc, #32]	@ (8003c98 <xTaskPriorityDisinherit+0xb4>)
 8003c78:	eb03 0283 	add.w	r2, r3, r3, lsl #2
 8003c7c:	0092      	lsls	r2, r2, #2
 8003c7e:	58ba      	ldr	r2, [r7, r2]
 8003c80:	4e06      	ldr	r6, [pc, #24]	@ (8003c9c <xTaskPriorityDisinherit+0xb8>)
 8003c82:	2a00      	cmp	r2, #0
 8003c84:	d1de      	bne.n	8003c44 <xTaskPriorityDisinherit+0x60>
 8003c86:	2201      	movs	r2, #1
 8003c88:	409a      	lsls	r2, r3
 8003c8a:	6833      	ldr	r3, [r6, #0]
 8003c8c:	ea23 0302 	bic.w	r3, r3, r2
 8003c90:	6033      	str	r3, [r6, #0]
 8003c92:	e7d7      	b.n	8003c44 <xTaskPriorityDisinherit+0x60>
 8003c94:	20000a9c 	.word	0x20000a9c
 8003c98:	20000a10 	.word	0x20000a10
 8003c9c:	20000994 	.word	0x20000994

08003ca0 <vTaskPriorityDisinheritAfterTimeout>:
		if( pxMutexHolder != NULL )
 8003ca0:	2800      	cmp	r0, #0
 8003ca2:	d04e      	beq.n	8003d42 <vTaskPriorityDisinheritAfterTimeout+0xa2>
	{
 8003ca4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
			configASSERT( pxTCB->uxMutexesHeld );
 8003ca6:	6d03      	ldr	r3, [r0, #80]	@ 0x50
 8003ca8:	4604      	mov	r4, r0
 8003caa:	b153      	cbz	r3, 8003cc2 <vTaskPriorityDisinheritAfterTimeout+0x22>
			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
 8003cac:	6cc0      	ldr	r0, [r0, #76]	@ 0x4c
			if( pxTCB->uxPriority != uxPriorityToUse )
 8003cae:	6ae2      	ldr	r2, [r4, #44]	@ 0x2c
			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
 8003cb0:	4281      	cmp	r1, r0
 8003cb2:	bf38      	it	cc
 8003cb4:	4601      	movcc	r1, r0
			if( pxTCB->uxPriority != uxPriorityToUse )
 8003cb6:	428a      	cmp	r2, r1
			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
 8003cb8:	460d      	mov	r5, r1
			if( pxTCB->uxPriority != uxPriorityToUse )
 8003cba:	d001      	beq.n	8003cc0 <vTaskPriorityDisinheritAfterTimeout+0x20>
				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
 8003cbc:	2b01      	cmp	r3, #1
 8003cbe:	d009      	beq.n	8003cd4 <vTaskPriorityDisinheritAfterTimeout+0x34>
	}
 8003cc0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8003cc2:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8003cc6:	f383 8811 	msr	BASEPRI, r3
 8003cca:	f3bf 8f6f 	isb	sy
 8003cce:	f3bf 8f4f 	dsb	sy
			configASSERT( pxTCB->uxMutexesHeld );
 8003cd2:	e7fe      	b.n	8003cd2 <vTaskPriorityDisinheritAfterTimeout+0x32>
					configASSERT( pxTCB != pxCurrentTCB );
 8003cd4:	4b20      	ldr	r3, [pc, #128]	@ (8003d58 <vTaskPriorityDisinheritAfterTimeout+0xb8>)
 8003cd6:	681b      	ldr	r3, [r3, #0]
 8003cd8:	42a3      	cmp	r3, r4
 8003cda:	d033      	beq.n	8003d44 <vTaskPriorityDisinheritAfterTimeout+0xa4>
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
 8003cdc:	4621      	mov	r1, r4
 8003cde:	204a      	movs	r0, #74	@ 0x4a
 8003ce0:	f001 fc90 	bl	8005604 <SEGGER_SYSVIEW_RecordU32>
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 8003ce4:	69a2      	ldr	r2, [r4, #24]
					uxPriorityUsedOnEntry = pxTCB->uxPriority;
 8003ce6:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 8003ce8:	4e1c      	ldr	r6, [pc, #112]	@ (8003d5c <vTaskPriorityDisinheritAfterTimeout+0xbc>)
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 8003cea:	2a00      	cmp	r2, #0
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 8003cec:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8003cf0:	6962      	ldr	r2, [r4, #20]
					pxTCB->uxPriority = uxPriorityToUse;
 8003cf2:	62e5      	str	r5, [r4, #44]	@ 0x2c
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 8003cf4:	eb06 0383 	add.w	r3, r6, r3, lsl #2
						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8003cf8:	bfa4      	itt	ge
 8003cfa:	f1c5 0507 	rsbge	r5, r5, #7
 8003cfe:	61a5      	strge	r5, [r4, #24]
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 8003d00:	429a      	cmp	r2, r3
 8003d02:	d1dd      	bne.n	8003cc0 <vTaskPriorityDisinheritAfterTimeout+0x20>
						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8003d04:	1d27      	adds	r7, r4, #4
 8003d06:	4638      	mov	r0, r7
 8003d08:	f7fe fa2c 	bl	8002164 <uxListRemove>
							portRESET_READY_PRIORITY( pxTCB->uxPriority, uxTopReadyPriority );
 8003d0c:	4d14      	ldr	r5, [pc, #80]	@ (8003d60 <vTaskPriorityDisinheritAfterTimeout+0xc0>)
						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8003d0e:	b930      	cbnz	r0, 8003d1e <vTaskPriorityDisinheritAfterTimeout+0x7e>
							portRESET_READY_PRIORITY( pxTCB->uxPriority, uxTopReadyPriority );
 8003d10:	2201      	movs	r2, #1
 8003d12:	6ae1      	ldr	r1, [r4, #44]	@ 0x2c
 8003d14:	682b      	ldr	r3, [r5, #0]
 8003d16:	408a      	lsls	r2, r1
 8003d18:	ea23 0302 	bic.w	r3, r3, r2
 8003d1c:	602b      	str	r3, [r5, #0]
						prvAddTaskToReadyList( pxTCB );
 8003d1e:	4620      	mov	r0, r4
 8003d20:	f001 fe98 	bl	8005a54 <SEGGER_SYSVIEW_OnTaskStartReady>
 8003d24:	2301      	movs	r3, #1
 8003d26:	6ae0      	ldr	r0, [r4, #44]	@ 0x2c
 8003d28:	682a      	ldr	r2, [r5, #0]
 8003d2a:	4083      	lsls	r3, r0
 8003d2c:	4313      	orrs	r3, r2
 8003d2e:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8003d32:	4639      	mov	r1, r7
 8003d34:	eb06 0080 	add.w	r0, r6, r0, lsl #2
 8003d38:	602b      	str	r3, [r5, #0]
	}
 8003d3a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
						prvAddTaskToReadyList( pxTCB );
 8003d3e:	f7fe b9eb 	b.w	8002118 <vListInsertEnd>
 8003d42:	4770      	bx	lr
 8003d44:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8003d48:	f383 8811 	msr	BASEPRI, r3
 8003d4c:	f3bf 8f6f 	isb	sy
 8003d50:	f3bf 8f4f 	dsb	sy
					configASSERT( pxTCB != pxCurrentTCB );
 8003d54:	e7fe      	b.n	8003d54 <vTaskPriorityDisinheritAfterTimeout+0xb4>
 8003d56:	bf00      	nop
 8003d58:	20000a9c 	.word	0x20000a9c
 8003d5c:	20000a10 	.word	0x20000a10
 8003d60:	20000994 	.word	0x20000994

08003d64 <pvTaskIncrementMutexHeldCount>:
		if( pxCurrentTCB != NULL )
 8003d64:	4b04      	ldr	r3, [pc, #16]	@ (8003d78 <pvTaskIncrementMutexHeldCount+0x14>)
 8003d66:	681a      	ldr	r2, [r3, #0]
 8003d68:	b11a      	cbz	r2, 8003d72 <pvTaskIncrementMutexHeldCount+0xe>
			( pxCurrentTCB->uxMutexesHeld )++;
 8003d6a:	6819      	ldr	r1, [r3, #0]
 8003d6c:	6d0a      	ldr	r2, [r1, #80]	@ 0x50
 8003d6e:	3201      	adds	r2, #1
 8003d70:	650a      	str	r2, [r1, #80]	@ 0x50
		return pxCurrentTCB;
 8003d72:	6818      	ldr	r0, [r3, #0]
	}
 8003d74:	4770      	bx	lr
 8003d76:	bf00      	nop
 8003d78:	20000a9c 	.word	0x20000a9c

08003d7c <prvSwitchTimerLists>:
	}
}
/*-----------------------------------------------------------*/

static void prvSwitchTimerLists( void )
{
 8003d7c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8003d80:	4e21      	ldr	r6, [pc, #132]	@ (8003e08 <prvSwitchTimerLists+0x8c>)
 8003d82:	b084      	sub	sp, #16

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 8003d84:	e00d      	b.n	8003da2 <prvSwitchTimerLists+0x26>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 8003d86:	68db      	ldr	r3, [r3, #12]

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8003d88:	68dc      	ldr	r4, [r3, #12]
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 8003d8a:	681f      	ldr	r7, [r3, #0]
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 8003d8c:	1d25      	adds	r5, r4, #4
 8003d8e:	4628      	mov	r0, r5
 8003d90:	f7fe f9e8 	bl	8002164 <uxListRemove>
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 8003d94:	6a23      	ldr	r3, [r4, #32]
 8003d96:	4620      	mov	r0, r4
 8003d98:	4798      	blx	r3

		if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 8003d9a:	f894 3028 	ldrb.w	r3, [r4, #40]	@ 0x28
 8003d9e:	075b      	lsls	r3, r3, #29
 8003da0:	d40a      	bmi.n	8003db8 <prvSwitchTimerLists+0x3c>
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 8003da2:	6833      	ldr	r3, [r6, #0]
 8003da4:	681a      	ldr	r2, [r3, #0]
 8003da6:	2a00      	cmp	r2, #0
 8003da8:	d1ed      	bne.n	8003d86 <prvSwitchTimerLists+0xa>
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
 8003daa:	4a18      	ldr	r2, [pc, #96]	@ (8003e0c <prvSwitchTimerLists+0x90>)
 8003dac:	6811      	ldr	r1, [r2, #0]
	pxOverflowTimerList = pxTemp;
 8003dae:	6013      	str	r3, [r2, #0]
	pxCurrentTimerList = pxOverflowTimerList;
 8003db0:	6031      	str	r1, [r6, #0]
}
 8003db2:	b004      	add	sp, #16
 8003db4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
 8003db8:	69a3      	ldr	r3, [r4, #24]
	if( xTimerQueue != NULL )
 8003dba:	f8df 8054 	ldr.w	r8, [pc, #84]	@ 8003e10 <prvSwitchTimerLists+0x94>
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
 8003dbe:	443b      	add	r3, r7
			if( xReloadTime > xNextExpireTime )
 8003dc0:	429f      	cmp	r7, r3
 8003dc2:	d206      	bcs.n	8003dd2 <prvSwitchTimerLists+0x56>
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 8003dc4:	4629      	mov	r1, r5
 8003dc6:	6830      	ldr	r0, [r6, #0]
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
 8003dc8:	6063      	str	r3, [r4, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 8003dca:	6124      	str	r4, [r4, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 8003dcc:	f7fe f9b2 	bl	8002134 <vListInsert>
 8003dd0:	e7e7      	b.n	8003da2 <prvSwitchTimerLists+0x26>
	if( xTimerQueue != NULL )
 8003dd2:	f8d8 3000 	ldr.w	r3, [r8]
 8003dd6:	b173      	cbz	r3, 8003df6 <prvSwitchTimerLists+0x7a>
		xMessage.xMessageID = xCommandID;
 8003dd8:	2500      	movs	r5, #0
		xMessage.u.xTimerParameters.pxTimer = xTimer;
 8003dda:	e9cd 7402 	strd	r7, r4, [sp, #8]
		xMessage.xMessageID = xCommandID;
 8003dde:	9501      	str	r5, [sp, #4]
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 8003de0:	f7ff fe9e 	bl	8003b20 <xTaskGetSchedulerState>
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
 8003de4:	462b      	mov	r3, r5
 8003de6:	462a      	mov	r2, r5
 8003de8:	f8d8 0000 	ldr.w	r0, [r8]
 8003dec:	a901      	add	r1, sp, #4
 8003dee:	f7fe fac7 	bl	8002380 <xQueueGenericSend>
				configASSERT( xResult );
 8003df2:	2800      	cmp	r0, #0
 8003df4:	d1d5      	bne.n	8003da2 <prvSwitchTimerLists+0x26>
 8003df6:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8003dfa:	f383 8811 	msr	BASEPRI, r3
 8003dfe:	f3bf 8f6f 	isb	sy
 8003e02:	f3bf 8f4f 	dsb	sy
 8003e06:	e7fe      	b.n	8003e06 <prvSwitchTimerLists+0x8a>
 8003e08:	20000b78 	.word	0x20000b78
 8003e0c:	20000b74 	.word	0x20000b74
 8003e10:	20000b70 	.word	0x20000b70

08003e14 <prvTimerTask>:
{
 8003e14:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
					portYIELD_WITHIN_API();
 8003e18:	f04f 29e0 	mov.w	r9, #3758153728	@ 0xe000e000
 8003e1c:	f04f 5880 	mov.w	r8, #268435456	@ 0x10000000
 8003e20:	4e8f      	ldr	r6, [pc, #572]	@ (8004060 <prvTimerTask+0x24c>)
 8003e22:	4d90      	ldr	r5, [pc, #576]	@ (8004064 <prvTimerTask+0x250>)
 8003e24:	4c90      	ldr	r4, [pc, #576]	@ (8004068 <prvTimerTask+0x254>)
{
 8003e26:	b089      	sub	sp, #36	@ 0x24
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
 8003e28:	6832      	ldr	r2, [r6, #0]
 8003e2a:	6817      	ldr	r7, [r2, #0]
 8003e2c:	2f00      	cmp	r7, #0
 8003e2e:	f040 809d 	bne.w	8003f6c <prvTimerTask+0x158>
	vTaskSuspendAll();
 8003e32:	f7ff fcd5 	bl	80037e0 <vTaskSuspendAll>
	xTimeNow = xTaskGetTickCount();
 8003e36:	f7ff fceb 	bl	8003810 <xTaskGetTickCount>
	if( xTimeNow < xLastTime )
 8003e3a:	682a      	ldr	r2, [r5, #0]
	xTimeNow = xTaskGetTickCount();
 8003e3c:	4682      	mov	sl, r0
	if( xTimeNow < xLastTime )
 8003e3e:	4290      	cmp	r0, r2
 8003e40:	f0c0 80a3 	bcc.w	8003f8a <prvTimerTask+0x176>
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
 8003e44:	4b89      	ldr	r3, [pc, #548]	@ (800406c <prvTimerTask+0x258>)
	xLastTime = xTimeNow;
 8003e46:	6028      	str	r0, [r5, #0]
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
 8003e48:	681a      	ldr	r2, [r3, #0]
 8003e4a:	6812      	ldr	r2, [r2, #0]
 8003e4c:	fab2 f282 	clz	r2, r2
 8003e50:	0952      	lsrs	r2, r2, #5
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
 8003e52:	6820      	ldr	r0, [r4, #0]
 8003e54:	eba7 010a 	sub.w	r1, r7, sl
 8003e58:	f7ff f816 	bl	8002e88 <vQueueWaitForMessageRestricted>
				if( xTaskResumeAll() == pdFALSE )
 8003e5c:	f7ff fcc8 	bl	80037f0 <xTaskResumeAll>
 8003e60:	b928      	cbnz	r0, 8003e6e <prvTimerTask+0x5a>
					portYIELD_WITHIN_API();
 8003e62:	f8c9 8d04 	str.w	r8, [r9, #3332]	@ 0xd04
 8003e66:	f3bf 8f4f 	dsb	sy
 8003e6a:	f3bf 8f6f 	isb	sy
	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
 8003e6e:	2200      	movs	r2, #0
 8003e70:	6820      	ldr	r0, [r4, #0]
 8003e72:	a902      	add	r1, sp, #8
 8003e74:	f7fe fc90 	bl	8002798 <xQueueReceive>
 8003e78:	2800      	cmp	r0, #0
 8003e7a:	d0d5      	beq.n	8003e28 <prvTimerTask+0x14>
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
 8003e7c:	9b02      	ldr	r3, [sp, #8]
 8003e7e:	2b00      	cmp	r3, #0
 8003e80:	dbf5      	blt.n	8003e6e <prvTimerTask+0x5a>
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
 8003e82:	9f04      	ldr	r7, [sp, #16]
			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
 8003e84:	697b      	ldr	r3, [r7, #20]
 8003e86:	b113      	cbz	r3, 8003e8e <prvTimerTask+0x7a>
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 8003e88:	1d38      	adds	r0, r7, #4
 8003e8a:	f7fe f96b 	bl	8002164 <uxListRemove>
	xTimeNow = xTaskGetTickCount();
 8003e8e:	f7ff fcbf 	bl	8003810 <xTaskGetTickCount>
	if( xTimeNow < xLastTime )
 8003e92:	682b      	ldr	r3, [r5, #0]
	xTimeNow = xTaskGetTickCount();
 8003e94:	4683      	mov	fp, r0
	if( xTimeNow < xLastTime )
 8003e96:	4298      	cmp	r0, r3
 8003e98:	d37e      	bcc.n	8003f98 <prvTimerTask+0x184>
			switch( xMessage.xMessageID )
 8003e9a:	9b02      	ldr	r3, [sp, #8]
	xLastTime = xTimeNow;
 8003e9c:	f8c5 b000 	str.w	fp, [r5]
			switch( xMessage.xMessageID )
 8003ea0:	2b09      	cmp	r3, #9
 8003ea2:	d8e4      	bhi.n	8003e6e <prvTimerTask+0x5a>
 8003ea4:	e8df f003 	tbb	[pc, r3]
 8003ea8:	52050505 	.word	0x52050505
 8003eac:	0505593c 	.word	0x0505593c
 8003eb0:	3c52      	.short	0x3c52
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 8003eb2:	f897 2028 	ldrb.w	r2, [r7, #40]	@ 0x28
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
 8003eb6:	9b03      	ldr	r3, [sp, #12]
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 8003eb8:	f042 0201 	orr.w	r2, r2, #1
 8003ebc:	f887 2028 	strb.w	r2, [r7, #40]	@ 0x28
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
 8003ec0:	69ba      	ldr	r2, [r7, #24]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 8003ec2:	613f      	str	r7, [r7, #16]
 8003ec4:	1899      	adds	r1, r3, r2
 8003ec6:	bf2c      	ite	cs
 8003ec8:	2001      	movcs	r0, #1
 8003eca:	2000      	movcc	r0, #0
	if( xNextExpiryTime <= xTimeNow )
 8003ecc:	4559      	cmp	r1, fp
	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 8003ece:	6079      	str	r1, [r7, #4]
	if( xNextExpiryTime <= xTimeNow )
 8003ed0:	d865      	bhi.n	8003f9e <prvTimerTask+0x18a>
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8003ed2:	ebab 0303 	sub.w	r3, fp, r3
 8003ed6:	429a      	cmp	r2, r3
 8003ed8:	d832      	bhi.n	8003f40 <prvTimerTask+0x12c>
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 8003eda:	6a3b      	ldr	r3, [r7, #32]
 8003edc:	4638      	mov	r0, r7
 8003ede:	4798      	blx	r3
						if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 8003ee0:	f897 3028 	ldrb.w	r3, [r7, #40]	@ 0x28
 8003ee4:	0759      	lsls	r1, r3, #29
 8003ee6:	d5c2      	bpl.n	8003e6e <prvTimerTask+0x5a>
	if( xTimerQueue != NULL )
 8003ee8:	6821      	ldr	r1, [r4, #0]
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
 8003eea:	9b03      	ldr	r3, [sp, #12]
 8003eec:	69ba      	ldr	r2, [r7, #24]
	if( xTimerQueue != NULL )
 8003eee:	b171      	cbz	r1, 8003f0e <prvTimerTask+0xfa>
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
 8003ef0:	4413      	add	r3, r2
		xMessage.u.xTimerParameters.pxTimer = xTimer;
 8003ef2:	e9cd 3706 	strd	r3, r7, [sp, #24]
		xMessage.xMessageID = xCommandID;
 8003ef6:	2700      	movs	r7, #0
 8003ef8:	9705      	str	r7, [sp, #20]
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 8003efa:	f7ff fe11 	bl	8003b20 <xTaskGetSchedulerState>
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
 8003efe:	463b      	mov	r3, r7
 8003f00:	463a      	mov	r2, r7
 8003f02:	6820      	ldr	r0, [r4, #0]
 8003f04:	a905      	add	r1, sp, #20
 8003f06:	f7fe fa3b 	bl	8002380 <xQueueGenericSend>
							configASSERT( xResult );
 8003f0a:	2800      	cmp	r0, #0
 8003f0c:	d1af      	bne.n	8003e6e <prvTimerTask+0x5a>
 8003f0e:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8003f12:	f383 8811 	msr	BASEPRI, r3
 8003f16:	f3bf 8f6f 	isb	sy
 8003f1a:	f3bf 8f4f 	dsb	sy
 8003f1e:	e7fe      	b.n	8003f1e <prvTimerTask+0x10a>
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 8003f20:	f897 2028 	ldrb.w	r2, [r7, #40]	@ 0x28
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
 8003f24:	9b03      	ldr	r3, [sp, #12]
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 8003f26:	f042 0201 	orr.w	r2, r2, #1
 8003f2a:	f887 2028 	strb.w	r2, [r7, #40]	@ 0x28
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
 8003f2e:	61bb      	str	r3, [r7, #24]
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
 8003f30:	2b00      	cmp	r3, #0
 8003f32:	f000 808b 	beq.w	800404c <prvTimerTask+0x238>
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
 8003f36:	445b      	add	r3, fp
	if( xNextExpiryTime <= xTimeNow )
 8003f38:	455b      	cmp	r3, fp
	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 8003f3a:	607b      	str	r3, [r7, #4]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 8003f3c:	613f      	str	r7, [r7, #16]
	if( xNextExpiryTime <= xTimeNow )
 8003f3e:	d832      	bhi.n	8003fa6 <prvTimerTask+0x192>
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 8003f40:	4b4a      	ldr	r3, [pc, #296]	@ (800406c <prvTimerTask+0x258>)
 8003f42:	1d39      	adds	r1, r7, #4
 8003f44:	6818      	ldr	r0, [r3, #0]
 8003f46:	f7fe f8f5 	bl	8002134 <vListInsert>
 8003f4a:	e790      	b.n	8003e6e <prvTimerTask+0x5a>
					pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
 8003f4c:	f897 3028 	ldrb.w	r3, [r7, #40]	@ 0x28
 8003f50:	f023 0301 	bic.w	r3, r3, #1
 8003f54:	f887 3028 	strb.w	r3, [r7, #40]	@ 0x28
					break;
 8003f58:	e789      	b.n	8003e6e <prvTimerTask+0x5a>
						if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
 8003f5a:	f897 3028 	ldrb.w	r3, [r7, #40]	@ 0x28
 8003f5e:	079a      	lsls	r2, r3, #30
 8003f60:	d541      	bpl.n	8003fe6 <prvTimerTask+0x1d2>
							pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
 8003f62:	f023 0301 	bic.w	r3, r3, #1
 8003f66:	f887 3028 	strb.w	r3, [r7, #40]	@ 0x28
 8003f6a:	e780      	b.n	8003e6e <prvTimerTask+0x5a>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 8003f6c:	68d3      	ldr	r3, [r2, #12]
 8003f6e:	681f      	ldr	r7, [r3, #0]
	vTaskSuspendAll();
 8003f70:	f7ff fc36 	bl	80037e0 <vTaskSuspendAll>
	xTimeNow = xTaskGetTickCount();
 8003f74:	f7ff fc4c 	bl	8003810 <xTaskGetTickCount>
	if( xTimeNow < xLastTime )
 8003f78:	682a      	ldr	r2, [r5, #0]
	xTimeNow = xTaskGetTickCount();
 8003f7a:	4682      	mov	sl, r0
	if( xTimeNow < xLastTime )
 8003f7c:	4282      	cmp	r2, r0
 8003f7e:	d804      	bhi.n	8003f8a <prvTimerTask+0x176>
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
 8003f80:	4287      	cmp	r7, r0
	xLastTime = xTimeNow;
 8003f82:	6028      	str	r0, [r5, #0]
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
 8003f84:	d914      	bls.n	8003fb0 <prvTimerTask+0x19c>
 8003f86:	2200      	movs	r2, #0
 8003f88:	e763      	b.n	8003e52 <prvTimerTask+0x3e>
		prvSwitchTimerLists();
 8003f8a:	f7ff fef7 	bl	8003d7c <prvSwitchTimerLists>
	xLastTime = xTimeNow;
 8003f8e:	f8c5 a000 	str.w	sl, [r5]
			( void ) xTaskResumeAll();
 8003f92:	f7ff fc2d 	bl	80037f0 <xTaskResumeAll>
 8003f96:	e76a      	b.n	8003e6e <prvTimerTask+0x5a>
		prvSwitchTimerLists();
 8003f98:	f7ff fef0 	bl	8003d7c <prvSwitchTimerLists>
		*pxTimerListsWereSwitched = pdTRUE;
 8003f9c:	e77d      	b.n	8003e9a <prvTimerTask+0x86>
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
 8003f9e:	455b      	cmp	r3, fp
 8003fa0:	d901      	bls.n	8003fa6 <prvTimerTask+0x192>
 8003fa2:	2800      	cmp	r0, #0
 8003fa4:	d099      	beq.n	8003eda <prvTimerTask+0xc6>
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 8003fa6:	6830      	ldr	r0, [r6, #0]
 8003fa8:	1d39      	adds	r1, r7, #4
 8003faa:	f7fe f8c3 	bl	8002134 <vListInsert>
 8003fae:	e75e      	b.n	8003e6e <prvTimerTask+0x5a>
				( void ) xTaskResumeAll();
 8003fb0:	f7ff fc1e 	bl	80037f0 <xTaskResumeAll>
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8003fb4:	6832      	ldr	r2, [r6, #0]
 8003fb6:	68d2      	ldr	r2, [r2, #12]
 8003fb8:	f8d2 b00c 	ldr.w	fp, [r2, #12]
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 8003fbc:	f10b 0104 	add.w	r1, fp, #4
 8003fc0:	4608      	mov	r0, r1
 8003fc2:	9101      	str	r1, [sp, #4]
 8003fc4:	f7fe f8ce 	bl	8002164 <uxListRemove>
	if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 8003fc8:	f89b 2028 	ldrb.w	r2, [fp, #40]	@ 0x28
 8003fcc:	9901      	ldr	r1, [sp, #4]
 8003fce:	f012 0f04 	tst.w	r2, #4
 8003fd2:	d10c      	bne.n	8003fee <prvTimerTask+0x1da>
		pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
 8003fd4:	f022 0201 	bic.w	r2, r2, #1
 8003fd8:	f88b 2028 	strb.w	r2, [fp, #40]	@ 0x28
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 8003fdc:	4658      	mov	r0, fp
 8003fde:	f8db 3020 	ldr.w	r3, [fp, #32]
 8003fe2:	4798      	blx	r3
}
 8003fe4:	e743      	b.n	8003e6e <prvTimerTask+0x5a>
							vPortFree( pxTimer );
 8003fe6:	4638      	mov	r0, r7
 8003fe8:	f000 fbca 	bl	8004780 <vPortFree>
 8003fec:	e73f      	b.n	8003e6e <prvTimerTask+0x5a>
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
 8003fee:	f8db 0018 	ldr.w	r0, [fp, #24]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 8003ff2:	f8cb b010 	str.w	fp, [fp, #16]
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
 8003ff6:	183a      	adds	r2, r7, r0
	if( xNextExpiryTime <= xTimeNow )
 8003ff8:	4552      	cmp	r2, sl
	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 8003ffa:	f8cb 2004 	str.w	r2, [fp, #4]
	if( xNextExpiryTime <= xTimeNow )
 8003ffe:	d903      	bls.n	8004008 <prvTimerTask+0x1f4>
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 8004000:	6830      	ldr	r0, [r6, #0]
 8004002:	f7fe f897 	bl	8002134 <vListInsert>
	return xProcessTimerNow;
 8004006:	e7e9      	b.n	8003fdc <prvTimerTask+0x1c8>
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8004008:	ebaa 0a07 	sub.w	sl, sl, r7
 800400c:	4550      	cmp	r0, sl
 800400e:	d818      	bhi.n	8004042 <prvTimerTask+0x22e>
	if( xTimerQueue != NULL )
 8004010:	6822      	ldr	r2, [r4, #0]
 8004012:	b16a      	cbz	r2, 8004030 <prvTimerTask+0x21c>
		xMessage.u.xTimerParameters.pxTimer = xTimer;
 8004014:	e9cd 7b06 	strd	r7, fp, [sp, #24]
		xMessage.xMessageID = xCommandID;
 8004018:	2700      	movs	r7, #0
 800401a:	9705      	str	r7, [sp, #20]
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 800401c:	f7ff fd80 	bl	8003b20 <xTaskGetSchedulerState>
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
 8004020:	463b      	mov	r3, r7
 8004022:	463a      	mov	r2, r7
 8004024:	6820      	ldr	r0, [r4, #0]
 8004026:	a905      	add	r1, sp, #20
 8004028:	f7fe f9aa 	bl	8002380 <xQueueGenericSend>
			configASSERT( xResult );
 800402c:	2800      	cmp	r0, #0
 800402e:	d1d5      	bne.n	8003fdc <prvTimerTask+0x1c8>
 8004030:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8004034:	f383 8811 	msr	BASEPRI, r3
 8004038:	f3bf 8f6f 	isb	sy
 800403c:	f3bf 8f4f 	dsb	sy
 8004040:	e7fe      	b.n	8004040 <prvTimerTask+0x22c>
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 8004042:	4b0a      	ldr	r3, [pc, #40]	@ (800406c <prvTimerTask+0x258>)
 8004044:	6818      	ldr	r0, [r3, #0]
 8004046:	f7fe f875 	bl	8002134 <vListInsert>
	return xProcessTimerNow;
 800404a:	e7c7      	b.n	8003fdc <prvTimerTask+0x1c8>
 800404c:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8004050:	f383 8811 	msr	BASEPRI, r3
 8004054:	f3bf 8f6f 	isb	sy
 8004058:	f3bf 8f4f 	dsb	sy
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
 800405c:	e7fe      	b.n	800405c <prvTimerTask+0x248>
 800405e:	bf00      	nop
 8004060:	20000b78 	.word	0x20000b78
 8004064:	20000b68 	.word	0x20000b68
 8004068:	20000b70 	.word	0x20000b70
 800406c:	20000b74 	.word	0x20000b74

08004070 <xTimerCreateTimerTask>:
{
 8004070:	b5f0      	push	{r4, r5, r6, r7, lr}
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
	{
		if( xTimerQueue == NULL )
 8004072:	4c23      	ldr	r4, [pc, #140]	@ (8004100 <xTimerCreateTimerTask+0x90>)
{
 8004074:	b089      	sub	sp, #36	@ 0x24
	taskENTER_CRITICAL();
 8004076:	f000 f94d 	bl	8004314 <vPortEnterCritical>
		if( xTimerQueue == NULL )
 800407a:	6825      	ldr	r5, [r4, #0]
 800407c:	b335      	cbz	r5, 80040cc <xTimerCreateTimerTask+0x5c>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
 800407e:	f000 f96b 	bl	8004358 <vPortExitCritical>
	if( xTimerQueue != NULL )
 8004082:	6823      	ldr	r3, [r4, #0]
 8004084:	b1cb      	cbz	r3, 80040ba <xTimerCreateTimerTask+0x4a>
			StaticTask_t *pxTimerTaskTCBBuffer = NULL;
 8004086:	2400      	movs	r4, #0
			xTimerTaskHandle = xTaskCreateStatic(	prvTimerTask,
 8004088:	2501      	movs	r5, #1
			vApplicationGetTimerTaskMemory( &pxTimerTaskTCBBuffer, &pxTimerTaskStackBuffer, &ulTimerTaskStackSize );
 800408a:	aa07      	add	r2, sp, #28
 800408c:	a906      	add	r1, sp, #24
 800408e:	a805      	add	r0, sp, #20
			StackType_t *pxTimerTaskStackBuffer = NULL;
 8004090:	e9cd 4405 	strd	r4, r4, [sp, #20]
			vApplicationGetTimerTaskMemory( &pxTimerTaskTCBBuffer, &pxTimerTaskStackBuffer, &ulTimerTaskStackSize );
 8004094:	f7fc f8b0 	bl	80001f8 <vApplicationGetTimerTaskMemory>
			xTimerTaskHandle = xTaskCreateStatic(	prvTimerTask,
 8004098:	9a05      	ldr	r2, [sp, #20]
 800409a:	4623      	mov	r3, r4
 800409c:	9202      	str	r2, [sp, #8]
 800409e:	9a06      	ldr	r2, [sp, #24]
 80040a0:	4918      	ldr	r1, [pc, #96]	@ (8004104 <xTimerCreateTimerTask+0x94>)
 80040a2:	e9cd 5200 	strd	r5, r2, [sp]
 80040a6:	4818      	ldr	r0, [pc, #96]	@ (8004108 <xTimerCreateTimerTask+0x98>)
 80040a8:	9a07      	ldr	r2, [sp, #28]
 80040aa:	f7ff fa6b 	bl	8003584 <xTaskCreateStatic>
 80040ae:	4b17      	ldr	r3, [pc, #92]	@ (800410c <xTimerCreateTimerTask+0x9c>)
 80040b0:	6018      	str	r0, [r3, #0]
			if( xTimerTaskHandle != NULL )
 80040b2:	b110      	cbz	r0, 80040ba <xTimerCreateTimerTask+0x4a>
}
 80040b4:	4628      	mov	r0, r5
 80040b6:	b009      	add	sp, #36	@ 0x24
 80040b8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80040ba:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80040be:	f383 8811 	msr	BASEPRI, r3
 80040c2:	f3bf 8f6f 	isb	sy
 80040c6:	f3bf 8f4f 	dsb	sy
	configASSERT( xReturn );
 80040ca:	e7fe      	b.n	80040ca <xTimerCreateTimerTask+0x5a>
			vListInitialise( &xActiveTimerList1 );
 80040cc:	4e10      	ldr	r6, [pc, #64]	@ (8004110 <xTimerCreateTimerTask+0xa0>)
			vListInitialise( &xActiveTimerList2 );
 80040ce:	4f11      	ldr	r7, [pc, #68]	@ (8004114 <xTimerCreateTimerTask+0xa4>)
			vListInitialise( &xActiveTimerList1 );
 80040d0:	4630      	mov	r0, r6
 80040d2:	f7fe f811 	bl	80020f8 <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
 80040d6:	4638      	mov	r0, r7
 80040d8:	f7fe f80e 	bl	80020f8 <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
 80040dc:	490e      	ldr	r1, [pc, #56]	@ (8004118 <xTimerCreateTimerTask+0xa8>)
			pxOverflowTimerList = &xActiveTimerList2;
 80040de:	4b0f      	ldr	r3, [pc, #60]	@ (800411c <xTimerCreateTimerTask+0xac>)
				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
 80040e0:	9500      	str	r5, [sp, #0]
 80040e2:	200a      	movs	r0, #10
			pxOverflowTimerList = &xActiveTimerList2;
 80040e4:	601f      	str	r7, [r3, #0]
			pxCurrentTimerList = &xActiveTimerList1;
 80040e6:	600e      	str	r6, [r1, #0]
				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
 80040e8:	4b0d      	ldr	r3, [pc, #52]	@ (8004120 <xTimerCreateTimerTask+0xb0>)
 80040ea:	210c      	movs	r1, #12
 80040ec:	4a0d      	ldr	r2, [pc, #52]	@ (8004124 <xTimerCreateTimerTask+0xb4>)
 80040ee:	f7fe f887 	bl	8002200 <xQueueGenericCreateStatic>
 80040f2:	6020      	str	r0, [r4, #0]
				if( xTimerQueue != NULL )
 80040f4:	2800      	cmp	r0, #0
 80040f6:	d0c2      	beq.n	800407e <xTimerCreateTimerTask+0xe>
					vQueueAddToRegistry( xTimerQueue, "TmrQ" );
 80040f8:	490b      	ldr	r1, [pc, #44]	@ (8004128 <xTimerCreateTimerTask+0xb8>)
 80040fa:	f7fe fe95 	bl	8002e28 <vQueueAddToRegistry>
 80040fe:	e7be      	b.n	800407e <xTimerCreateTimerTask+0xe>
 8004100:	20000b70 	.word	0x20000b70
 8004104:	08006e70 	.word	0x08006e70
 8004108:	08003e15 	.word	0x08003e15
 800410c:	20000b6c 	.word	0x20000b6c
 8004110:	20000b90 	.word	0x20000b90
 8004114:	20000b7c 	.word	0x20000b7c
 8004118:	20000b78 	.word	0x20000b78
 800411c:	20000b74 	.word	0x20000b74
 8004120:	20000aa0 	.word	0x20000aa0
 8004124:	20000af0 	.word	0x20000af0
 8004128:	08006e68 	.word	0x08006e68

0800412c <xTimerCreate>:
	{
 800412c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004130:	4607      	mov	r7, r0
 8004132:	b085      	sub	sp, #20
		pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of Timer_t is always a pointer to the timer's mame. */
 8004134:	202c      	movs	r0, #44	@ 0x2c
	{
 8004136:	4688      	mov	r8, r1
 8004138:	4616      	mov	r6, r2
 800413a:	461d      	mov	r5, r3
		pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of Timer_t is always a pointer to the timer's mame. */
 800413c:	f000 fa62 	bl	8004604 <pvPortMalloc>
		if( pxNewTimer != NULL )
 8004140:	4604      	mov	r4, r0
 8004142:	b1e8      	cbz	r0, 8004180 <xTimerCreate+0x54>
			pxNewTimer->ucStatus = 0x00;
 8004144:	2300      	movs	r3, #0
 8004146:	f880 3028 	strb.w	r3, [r0, #40]	@ 0x28
	configASSERT( ( xTimerPeriodInTicks > 0 ) );
 800414a:	f1b8 0f00 	cmp.w	r8, #0
 800414e:	d01b      	beq.n	8004188 <xTimerCreate+0x5c>
		if( xTimerQueue == NULL )
 8004150:	f8df 9088 	ldr.w	r9, [pc, #136]	@ 80041dc <xTimerCreate+0xb0>
	taskENTER_CRITICAL();
 8004154:	f000 f8de 	bl	8004314 <vPortEnterCritical>
		if( xTimerQueue == NULL )
 8004158:	f8d9 3000 	ldr.w	r3, [r9]
 800415c:	b1eb      	cbz	r3, 800419a <xTimerCreate+0x6e>
	taskEXIT_CRITICAL();
 800415e:	f000 f8fb 	bl	8004358 <vPortExitCritical>
		pxNewTimer->pxCallbackFunction = pxCallbackFunction;
 8004162:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
		pxNewTimer->pvTimerID = pvTimerID;
 8004164:	e9c4 8506 	strd	r8, r5, [r4, #24]
		pxNewTimer->pcTimerName = pcTimerName;
 8004168:	6027      	str	r7, [r4, #0]
		pxNewTimer->pxCallbackFunction = pxCallbackFunction;
 800416a:	6223      	str	r3, [r4, #32]
		vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
 800416c:	1d20      	adds	r0, r4, #4
 800416e:	f7fd ffcf 	bl	8002110 <vListInitialiseItem>
		if( uxAutoReload != pdFALSE )
 8004172:	b12e      	cbz	r6, 8004180 <xTimerCreate+0x54>
			pxNewTimer->ucStatus |= tmrSTATUS_IS_AUTORELOAD;
 8004174:	f894 3028 	ldrb.w	r3, [r4, #40]	@ 0x28
 8004178:	f043 0304 	orr.w	r3, r3, #4
 800417c:	f884 3028 	strb.w	r3, [r4, #40]	@ 0x28
	}
 8004180:	4620      	mov	r0, r4
 8004182:	b005      	add	sp, #20
 8004184:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8004188:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800418c:	f383 8811 	msr	BASEPRI, r3
 8004190:	f3bf 8f6f 	isb	sy
 8004194:	f3bf 8f4f 	dsb	sy
	configASSERT( ( xTimerPeriodInTicks > 0 ) );
 8004198:	e7fe      	b.n	8004198 <xTimerCreate+0x6c>
			vListInitialise( &xActiveTimerList1 );
 800419a:	f8df b044 	ldr.w	fp, [pc, #68]	@ 80041e0 <xTimerCreate+0xb4>
			vListInitialise( &xActiveTimerList2 );
 800419e:	f8df a044 	ldr.w	sl, [pc, #68]	@ 80041e4 <xTimerCreate+0xb8>
			vListInitialise( &xActiveTimerList1 );
 80041a2:	4658      	mov	r0, fp
 80041a4:	9303      	str	r3, [sp, #12]
 80041a6:	f7fd ffa7 	bl	80020f8 <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
 80041aa:	4650      	mov	r0, sl
 80041ac:	f7fd ffa4 	bl	80020f8 <vListInitialise>
				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
 80041b0:	9b03      	ldr	r3, [sp, #12]
 80041b2:	210c      	movs	r1, #12
 80041b4:	9300      	str	r3, [sp, #0]
			pxCurrentTimerList = &xActiveTimerList1;
 80041b6:	4b0c      	ldr	r3, [pc, #48]	@ (80041e8 <xTimerCreate+0xbc>)
				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
 80041b8:	200a      	movs	r0, #10
			pxCurrentTimerList = &xActiveTimerList1;
 80041ba:	f8c3 b000 	str.w	fp, [r3]
			pxOverflowTimerList = &xActiveTimerList2;
 80041be:	4b0b      	ldr	r3, [pc, #44]	@ (80041ec <xTimerCreate+0xc0>)
				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
 80041c0:	4a0b      	ldr	r2, [pc, #44]	@ (80041f0 <xTimerCreate+0xc4>)
			pxOverflowTimerList = &xActiveTimerList2;
 80041c2:	f8c3 a000 	str.w	sl, [r3]
				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
 80041c6:	4b0b      	ldr	r3, [pc, #44]	@ (80041f4 <xTimerCreate+0xc8>)
 80041c8:	f7fe f81a 	bl	8002200 <xQueueGenericCreateStatic>
 80041cc:	f8c9 0000 	str.w	r0, [r9]
				if( xTimerQueue != NULL )
 80041d0:	2800      	cmp	r0, #0
 80041d2:	d0c4      	beq.n	800415e <xTimerCreate+0x32>
					vQueueAddToRegistry( xTimerQueue, "TmrQ" );
 80041d4:	4908      	ldr	r1, [pc, #32]	@ (80041f8 <xTimerCreate+0xcc>)
 80041d6:	f7fe fe27 	bl	8002e28 <vQueueAddToRegistry>
 80041da:	e7c0      	b.n	800415e <xTimerCreate+0x32>
 80041dc:	20000b70 	.word	0x20000b70
 80041e0:	20000b90 	.word	0x20000b90
 80041e4:	20000b7c 	.word	0x20000b7c
 80041e8:	20000b78 	.word	0x20000b78
 80041ec:	20000b74 	.word	0x20000b74
 80041f0:	20000af0 	.word	0x20000af0
 80041f4:	20000aa0 	.word	0x20000aa0
 80041f8:	08006e68 	.word	0x08006e68

080041fc <xTimerGenericCommand>:
	configASSERT( xTimer );
 80041fc:	b1c8      	cbz	r0, 8004232 <xTimerGenericCommand+0x36>
{
 80041fe:	b530      	push	{r4, r5, lr}
	if( xTimerQueue != NULL )
 8004200:	4d18      	ldr	r5, [pc, #96]	@ (8004264 <xTimerGenericCommand+0x68>)
{
 8004202:	b085      	sub	sp, #20
	if( xTimerQueue != NULL )
 8004204:	682c      	ldr	r4, [r5, #0]
 8004206:	b18c      	cbz	r4, 800422c <xTimerGenericCommand+0x30>
		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
 8004208:	2905      	cmp	r1, #5
		xMessage.xMessageID = xCommandID;
 800420a:	e9cd 1201 	strd	r1, r2, [sp, #4]
		xMessage.u.xTimerParameters.pxTimer = xTimer;
 800420e:	9003      	str	r0, [sp, #12]
		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
 8004210:	dc18      	bgt.n	8004244 <xTimerGenericCommand+0x48>
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 8004212:	f7ff fc85 	bl	8003b20 <xTaskGetSchedulerState>
 8004216:	2802      	cmp	r0, #2
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
 8004218:	f04f 0300 	mov.w	r3, #0
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 800421c:	d01b      	beq.n	8004256 <xTimerGenericCommand+0x5a>
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
 800421e:	461a      	mov	r2, r3
 8004220:	6828      	ldr	r0, [r5, #0]
 8004222:	a901      	add	r1, sp, #4
 8004224:	f7fe f8ac 	bl	8002380 <xQueueGenericSend>
}
 8004228:	b005      	add	sp, #20
 800422a:	bd30      	pop	{r4, r5, pc}
BaseType_t xReturn = pdFAIL;
 800422c:	4620      	mov	r0, r4
}
 800422e:	b005      	add	sp, #20
 8004230:	bd30      	pop	{r4, r5, pc}
 8004232:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8004236:	f383 8811 	msr	BASEPRI, r3
 800423a:	f3bf 8f6f 	isb	sy
 800423e:	f3bf 8f4f 	dsb	sy
	configASSERT( xTimer );
 8004242:	e7fe      	b.n	8004242 <xTimerGenericCommand+0x46>
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
 8004244:	469c      	mov	ip, r3
 8004246:	4620      	mov	r0, r4
 8004248:	2300      	movs	r3, #0
 800424a:	4662      	mov	r2, ip
 800424c:	a901      	add	r1, sp, #4
 800424e:	f7fe fa2d 	bl	80026ac <xQueueGenericSendFromISR>
}
 8004252:	b005      	add	sp, #20
 8004254:	bd30      	pop	{r4, r5, pc}
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
 8004256:	9a08      	ldr	r2, [sp, #32]
 8004258:	6828      	ldr	r0, [r5, #0]
 800425a:	a901      	add	r1, sp, #4
 800425c:	f7fe f890 	bl	8002380 <xQueueGenericSend>
 8004260:	e7e5      	b.n	800422e <xTimerGenericCommand+0x32>
 8004262:	bf00      	nop
 8004264:	20000b70 	.word	0x20000b70

08004268 <prvPortStartFirstTask>:
}
/*-----------------------------------------------------------*/

static void prvPortStartFirstTask( void )
{
	__asm volatile(
 8004268:	4806      	ldr	r0, [pc, #24]	@ (8004284 <prvPortStartFirstTask+0x1c>)
 800426a:	6800      	ldr	r0, [r0, #0]
 800426c:	6800      	ldr	r0, [r0, #0]
 800426e:	f380 8808 	msr	MSP, r0
 8004272:	b662      	cpsie	i
 8004274:	b661      	cpsie	f
 8004276:	f3bf 8f4f 	dsb	sy
 800427a:	f3bf 8f6f 	isb	sy
 800427e:	df00      	svc	0
 8004280:	bf00      	nop
					" dsb					\n"
					" isb					\n"
					" svc 0					\n" /* System call to start first task. */
					" nop					\n"
				);
}
 8004282:	0000      	.short	0x0000
 8004284:	e000ed08 	.word	0xe000ed08

08004288 <prvTaskExitError>:
volatile uint32_t ulDummy = 0UL;
 8004288:	2200      	movs	r2, #0
	configASSERT( uxCriticalNesting == ~0UL );
 800428a:	4b0e      	ldr	r3, [pc, #56]	@ (80042c4 <prvTaskExitError+0x3c>)
{
 800428c:	b082      	sub	sp, #8
	configASSERT( uxCriticalNesting == ~0UL );
 800428e:	681b      	ldr	r3, [r3, #0]
volatile uint32_t ulDummy = 0UL;
 8004290:	9201      	str	r2, [sp, #4]
	configASSERT( uxCriticalNesting == ~0UL );
 8004292:	3301      	adds	r3, #1
 8004294:	d008      	beq.n	80042a8 <prvTaskExitError+0x20>
 8004296:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800429a:	f383 8811 	msr	BASEPRI, r3
 800429e:	f3bf 8f6f 	isb	sy
 80042a2:	f3bf 8f4f 	dsb	sy
 80042a6:	e7fe      	b.n	80042a6 <prvTaskExitError+0x1e>
 80042a8:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80042ac:	f383 8811 	msr	BASEPRI, r3
 80042b0:	f3bf 8f6f 	isb	sy
 80042b4:	f3bf 8f4f 	dsb	sy
	while( ulDummy == 0 )
 80042b8:	9b01      	ldr	r3, [sp, #4]
 80042ba:	2b00      	cmp	r3, #0
 80042bc:	d0fc      	beq.n	80042b8 <prvTaskExitError+0x30>
}
 80042be:	b002      	add	sp, #8
 80042c0:	4770      	bx	lr
 80042c2:	bf00      	nop
 80042c4:	20000028 	.word	0x20000028

080042c8 <pxPortInitialiseStack>:
{
 80042c8:	b410      	push	{r4}
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 80042ca:	f04f 7480 	mov.w	r4, #16777216	@ 0x1000000
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 80042ce:	4b06      	ldr	r3, [pc, #24]	@ (80042e8 <pxPortInitialiseStack+0x20>)
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
 80042d0:	f021 0101 	bic.w	r1, r1, #1
 80042d4:	e940 1402 	strd	r1, r4, [r0, #-8]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 80042d8:	f840 3c0c 	str.w	r3, [r0, #-12]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
 80042dc:	f840 2c20 	str.w	r2, [r0, #-32]
}
 80042e0:	bc10      	pop	{r4}
 80042e2:	3840      	subs	r0, #64	@ 0x40
 80042e4:	4770      	bx	lr
 80042e6:	bf00      	nop
 80042e8:	08004289 	.word	0x08004289
 80042ec:	00000000 	.word	0x00000000

080042f0 <SVC_Handler>:
	__asm volatile (
 80042f0:	4b07      	ldr	r3, [pc, #28]	@ (8004310 <pxCurrentTCBConst2>)
 80042f2:	6819      	ldr	r1, [r3, #0]
 80042f4:	6808      	ldr	r0, [r1, #0]
 80042f6:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 80042fa:	f380 8809 	msr	PSP, r0
 80042fe:	f3bf 8f6f 	isb	sy
 8004302:	f04f 0000 	mov.w	r0, #0
 8004306:	f380 8811 	msr	BASEPRI, r0
 800430a:	f04e 0e0d 	orr.w	lr, lr, #13
 800430e:	4770      	bx	lr

08004310 <pxCurrentTCBConst2>:
 8004310:	20000a9c 	.word	0x20000a9c

08004314 <vPortEnterCritical>:
 8004314:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8004318:	f383 8811 	msr	BASEPRI, r3
 800431c:	f3bf 8f6f 	isb	sy
 8004320:	f3bf 8f4f 	dsb	sy
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
	portDISABLE_INTERRUPTS();
	uxCriticalNesting++;
 8004324:	4a0b      	ldr	r2, [pc, #44]	@ (8004354 <vPortEnterCritical+0x40>)
 8004326:	6813      	ldr	r3, [r2, #0]
 8004328:	3301      	adds	r3, #1
	/* This is not the interrupt safe version of the enter critical function so
	assert() if it is being called from an interrupt context.  Only API
	functions that end in "FromISR" can be used in an interrupt.  Only assert if
	the critical nesting count is 1 to protect against recursive calls if the
	assert function also uses a critical section. */
	if( uxCriticalNesting == 1 )
 800432a:	2b01      	cmp	r3, #1
	uxCriticalNesting++;
 800432c:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 1 )
 800432e:	d000      	beq.n	8004332 <vPortEnterCritical+0x1e>
	{
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
	}
}
 8004330:	4770      	bx	lr
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
 8004332:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 8004336:	f8d3 3d04 	ldr.w	r3, [r3, #3332]	@ 0xd04
 800433a:	b2db      	uxtb	r3, r3
 800433c:	2b00      	cmp	r3, #0
 800433e:	d0f7      	beq.n	8004330 <vPortEnterCritical+0x1c>
 8004340:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8004344:	f383 8811 	msr	BASEPRI, r3
 8004348:	f3bf 8f6f 	isb	sy
 800434c:	f3bf 8f4f 	dsb	sy
 8004350:	e7fe      	b.n	8004350 <vPortEnterCritical+0x3c>
 8004352:	bf00      	nop
 8004354:	20000028 	.word	0x20000028

08004358 <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
	configASSERT( uxCriticalNesting );
 8004358:	4a08      	ldr	r2, [pc, #32]	@ (800437c <vPortExitCritical+0x24>)
 800435a:	6813      	ldr	r3, [r2, #0]
 800435c:	b943      	cbnz	r3, 8004370 <vPortExitCritical+0x18>
 800435e:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8004362:	f383 8811 	msr	BASEPRI, r3
 8004366:	f3bf 8f6f 	isb	sy
 800436a:	f3bf 8f4f 	dsb	sy
 800436e:	e7fe      	b.n	800436e <vPortExitCritical+0x16>
	uxCriticalNesting--;
 8004370:	3b01      	subs	r3, #1
 8004372:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
 8004374:	b90b      	cbnz	r3, 800437a <vPortExitCritical+0x22>
	__asm volatile
 8004376:	f383 8811 	msr	BASEPRI, r3
	{
		portENABLE_INTERRUPTS();
	}
}
 800437a:	4770      	bx	lr
 800437c:	20000028 	.word	0x20000028

08004380 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
 8004380:	f3ef 8009 	mrs	r0, PSP
 8004384:	f3bf 8f6f 	isb	sy
 8004388:	4b0d      	ldr	r3, [pc, #52]	@ (80043c0 <pxCurrentTCBConst>)
 800438a:	681a      	ldr	r2, [r3, #0]
 800438c:	e920 0ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8004390:	6010      	str	r0, [r2, #0]
 8004392:	e92d 4008 	stmdb	sp!, {r3, lr}
 8004396:	f04f 0050 	mov.w	r0, #80	@ 0x50
 800439a:	f380 8811 	msr	BASEPRI, r0
 800439e:	f7ff fa55 	bl	800384c <vTaskSwitchContext>
 80043a2:	f04f 0000 	mov.w	r0, #0
 80043a6:	f380 8811 	msr	BASEPRI, r0
 80043aa:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 80043ae:	6819      	ldr	r1, [r3, #0]
 80043b0:	6808      	ldr	r0, [r1, #0]
 80043b2:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 80043b6:	f380 8809 	msr	PSP, r0
 80043ba:	f3bf 8f6f 	isb	sy
 80043be:	4770      	bx	lr

080043c0 <pxCurrentTCBConst>:
 80043c0:	20000a9c 	.word	0x20000a9c

080043c4 <SysTick_Handler>:
	);
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
 80043c4:	b508      	push	{r3, lr}
	__asm volatile
 80043c6:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80043ca:	f383 8811 	msr	BASEPRI, r3
 80043ce:	f3bf 8f6f 	isb	sy
 80043d2:	f3bf 8f4f 	dsb	sy
	/* The SysTick runs at the lowest interrupt priority, so when this interrupt
	executes all interrupts must be unmasked.  There is therefore no need to
	save and then restore the interrupt mask value as its value is already
	known. */
	portDISABLE_INTERRUPTS();
  traceISR_ENTER();
 80043d6:	f001 fad1 	bl	800597c <SEGGER_SYSVIEW_RecordEnterISR>
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
 80043da:	f7ff fa27 	bl	800382c <xTaskIncrementTick>
 80043de:	b158      	cbz	r0, 80043f8 <SysTick_Handler+0x34>
		{
      traceISR_EXIT_TO_SCHEDULER();
 80043e0:	f002 f9c0 	bl	8006764 <SEGGER_SYSVIEW_RecordExitISRToScheduler>
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 80043e4:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 80043e8:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 80043ec:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
	__asm volatile
 80043f0:	2300      	movs	r3, #0
 80043f2:	f383 8811 	msr	BASEPRI, r3
		{
			traceISR_EXIT();
		}
	}
	portENABLE_INTERRUPTS();
}
 80043f6:	bd08      	pop	{r3, pc}
			traceISR_EXIT();
 80043f8:	f002 f926 	bl	8006648 <SEGGER_SYSVIEW_RecordExitISR>
 80043fc:	2300      	movs	r3, #0
 80043fe:	f383 8811 	msr	BASEPRI, r3
}
 8004402:	bd08      	pop	{r3, pc}

08004404 <vPortSetupTimerInterrupt>:
		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
	}
	#endif /* configUSE_TICKLESS_IDLE */

	/* Stop and clear the SysTick. */
	portNVIC_SYSTICK_CTRL_REG = 0UL;
 8004404:	f04f 22e0 	mov.w	r2, #3758153728	@ 0xe000e000
 8004408:	2300      	movs	r3, #0
	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;

	/* Configure SysTick to interrupt at the requested rate. */
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
 800440a:	2007      	movs	r0, #7
{
 800440c:	b410      	push	{r4}
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 800440e:	4c06      	ldr	r4, [pc, #24]	@ (8004428 <vPortSetupTimerInterrupt+0x24>)
	portNVIC_SYSTICK_CTRL_REG = 0UL;
 8004410:	6113      	str	r3, [r2, #16]
	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
 8004412:	6193      	str	r3, [r2, #24]
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 8004414:	6823      	ldr	r3, [r4, #0]
 8004416:	4905      	ldr	r1, [pc, #20]	@ (800442c <vPortSetupTimerInterrupt+0x28>)
}
 8004418:	bc10      	pop	{r4}
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 800441a:	fba1 1303 	umull	r1, r3, r1, r3
 800441e:	099b      	lsrs	r3, r3, #6
 8004420:	3b01      	subs	r3, #1
 8004422:	6153      	str	r3, [r2, #20]
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
 8004424:	6110      	str	r0, [r2, #16]
}
 8004426:	4770      	bx	lr
 8004428:	2000001c 	.word	0x2000001c
 800442c:	10624dd3 	.word	0x10624dd3

08004430 <xPortStartScheduler>:
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
 8004430:	f04f 0cff 	mov.w	ip, #255	@ 0xff
{
 8004434:	b530      	push	{r4, r5, lr}
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 8004436:	2407      	movs	r4, #7
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 8004438:	4b34      	ldr	r3, [pc, #208]	@ (800450c <xPortStartScheduler+0xdc>)
{
 800443a:	b085      	sub	sp, #20
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 800443c:	781a      	ldrb	r2, [r3, #0]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 800443e:	4934      	ldr	r1, [pc, #208]	@ (8004510 <xPortStartScheduler+0xe0>)
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 8004440:	b2d2      	uxtb	r2, r2
 8004442:	9202      	str	r2, [sp, #8]
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
 8004444:	f883 c000 	strb.w	ip, [r3]
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
 8004448:	781b      	ldrb	r3, [r3, #0]
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 800444a:	4832      	ldr	r0, [pc, #200]	@ (8004514 <xPortStartScheduler+0xe4>)
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
 800444c:	b2db      	uxtb	r3, r3
 800444e:	f88d 3007 	strb.w	r3, [sp, #7]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 8004452:	f89d 3007 	ldrb.w	r3, [sp, #7]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 8004456:	f89d 2007 	ldrb.w	r2, [sp, #7]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 800445a:	f003 0350 	and.w	r3, r3, #80	@ 0x50
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 800445e:	0612      	lsls	r2, r2, #24
 8004460:	bf48      	it	mi
 8004462:	2206      	movmi	r2, #6
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 8004464:	6004      	str	r4, [r0, #0]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 8004466:	700b      	strb	r3, [r1, #0]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 8004468:	d50e      	bpl.n	8004488 <xPortStartScheduler+0x58>
			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
 800446a:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800446e:	4611      	mov	r1, r2
 8004470:	005b      	lsls	r3, r3, #1
 8004472:	b2db      	uxtb	r3, r3
 8004474:	f88d 3007 	strb.w	r3, [sp, #7]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 8004478:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800447c:	3a01      	subs	r2, #1
 800447e:	061b      	lsls	r3, r3, #24
 8004480:	d4f3      	bmi.n	800446a <xPortStartScheduler+0x3a>
			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );
 8004482:	2903      	cmp	r1, #3
 8004484:	d009      	beq.n	800449a <xPortStartScheduler+0x6a>
 8004486:	6001      	str	r1, [r0, #0]
	__asm volatile
 8004488:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800448c:	f383 8811 	msr	BASEPRI, r3
 8004490:	f3bf 8f6f 	isb	sy
 8004494:	f3bf 8f4f 	dsb	sy
 8004498:	e7fe      	b.n	8004498 <xPortStartScheduler+0x68>
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
 800449a:	f44f 7440 	mov.w	r4, #768	@ 0x300
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 800449e:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
 80044a2:	6004      	str	r4, [r0, #0]
	uxCriticalNesting = 0;
 80044a4:	2400      	movs	r4, #0
		*pucFirstUserPriorityRegister = ulOriginalPriority;
 80044a6:	9a02      	ldr	r2, [sp, #8]
 80044a8:	4918      	ldr	r1, [pc, #96]	@ (800450c <xPortStartScheduler+0xdc>)
 80044aa:	b2d2      	uxtb	r2, r2
 80044ac:	700a      	strb	r2, [r1, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 80044ae:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	@ 0xd20
	uxCriticalNesting = 0;
 80044b2:	4d19      	ldr	r5, [pc, #100]	@ (8004518 <xPortStartScheduler+0xe8>)
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 80044b4:	f442 0270 	orr.w	r2, r2, #15728640	@ 0xf00000
 80044b8:	f8c3 2d20 	str.w	r2, [r3, #3360]	@ 0xd20
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
 80044bc:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	@ 0xd20
 80044c0:	f042 4270 	orr.w	r2, r2, #4026531840	@ 0xf0000000
 80044c4:	f8c3 2d20 	str.w	r2, [r3, #3360]	@ 0xd20
	vPortSetupTimerInterrupt();
 80044c8:	f7ff ff9c 	bl	8004404 <vPortSetupTimerInterrupt>
	uxCriticalNesting = 0;
 80044cc:	602c      	str	r4, [r5, #0]
	prvPortStartFirstTask();
 80044ce:	f7ff fecb 	bl	8004268 <prvPortStartFirstTask>
	vTaskSwitchContext();
 80044d2:	f7ff f9bb 	bl	800384c <vTaskSwitchContext>
	configASSERT( uxCriticalNesting == ~0UL );
 80044d6:	682b      	ldr	r3, [r5, #0]
volatile uint32_t ulDummy = 0UL;
 80044d8:	9403      	str	r4, [sp, #12]
	configASSERT( uxCriticalNesting == ~0UL );
 80044da:	3301      	adds	r3, #1
 80044dc:	d008      	beq.n	80044f0 <xPortStartScheduler+0xc0>
 80044de:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80044e2:	f383 8811 	msr	BASEPRI, r3
 80044e6:	f3bf 8f6f 	isb	sy
 80044ea:	f3bf 8f4f 	dsb	sy
 80044ee:	e7fe      	b.n	80044ee <xPortStartScheduler+0xbe>
 80044f0:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80044f4:	f383 8811 	msr	BASEPRI, r3
 80044f8:	f3bf 8f6f 	isb	sy
 80044fc:	f3bf 8f4f 	dsb	sy
	while( ulDummy == 0 )
 8004500:	9b03      	ldr	r3, [sp, #12]
 8004502:	2b00      	cmp	r3, #0
 8004504:	d0fc      	beq.n	8004500 <xPortStartScheduler+0xd0>
}
 8004506:	2000      	movs	r0, #0
 8004508:	b005      	add	sp, #20
 800450a:	bd30      	pop	{r4, r5, pc}
 800450c:	e000e400 	.word	0xe000e400
 8004510:	20000ba8 	.word	0x20000ba8
 8004514:	20000ba4 	.word	0x20000ba4
 8004518:	20000028 	.word	0x20000028

0800451c <vPortValidateInterruptPriority>:
	{
	uint32_t ulCurrentInterrupt;
	uint8_t ucCurrentPriority;

		/* Obtain the number of the currently executing interrupt. */
		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
 800451c:	f3ef 8305 	mrs	r3, IPSR

		/* Is the interrupt number a user defined interrupt? */
		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
 8004520:	2b0f      	cmp	r3, #15
 8004522:	d90e      	bls.n	8004542 <vPortValidateInterruptPriority+0x26>
		{
			/* Look up the interrupt's priority. */
			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
 8004524:	4911      	ldr	r1, [pc, #68]	@ (800456c <vPortValidateInterruptPriority+0x50>)
			interrupt entry is as fast and simple as possible.

			The following links provide detailed information:
			http://www.freertos.org/RTOS-Cortex-M3-M4.html
			http://www.freertos.org/FAQHelp.html */
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
 8004526:	4a12      	ldr	r2, [pc, #72]	@ (8004570 <vPortValidateInterruptPriority+0x54>)
			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
 8004528:	5c5b      	ldrb	r3, [r3, r1]
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
 800452a:	7812      	ldrb	r2, [r2, #0]
 800452c:	429a      	cmp	r2, r3
 800452e:	d908      	bls.n	8004542 <vPortValidateInterruptPriority+0x26>
 8004530:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8004534:	f383 8811 	msr	BASEPRI, r3
 8004538:	f3bf 8f6f 	isb	sy
 800453c:	f3bf 8f4f 	dsb	sy
 8004540:	e7fe      	b.n	8004540 <vPortValidateInterruptPriority+0x24>
		configuration then the correct setting can be achieved on all Cortex-M
		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
		scheduler.  Note however that some vendor specific peripheral libraries
		assume a non-zero priority group setting, in which cases using a value
		of zero will result in unpredictable behaviour. */
		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
 8004542:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 8004546:	4a0b      	ldr	r2, [pc, #44]	@ (8004574 <vPortValidateInterruptPriority+0x58>)
 8004548:	f8d3 3d0c 	ldr.w	r3, [r3, #3340]	@ 0xd0c
 800454c:	6812      	ldr	r2, [r2, #0]
 800454e:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
 8004552:	4293      	cmp	r3, r2
 8004554:	d908      	bls.n	8004568 <vPortValidateInterruptPriority+0x4c>
 8004556:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800455a:	f383 8811 	msr	BASEPRI, r3
 800455e:	f3bf 8f6f 	isb	sy
 8004562:	f3bf 8f4f 	dsb	sy
 8004566:	e7fe      	b.n	8004566 <vPortValidateInterruptPriority+0x4a>
	}
 8004568:	4770      	bx	lr
 800456a:	bf00      	nop
 800456c:	e000e3f0 	.word	0xe000e3f0
 8004570:	20000ba8 	.word	0x20000ba8
 8004574:	20000ba4 	.word	0x20000ba4

08004578 <vSetVarulMaxPRIGROUPValue>:
		Save the interrupt priority value that is about to be clobbered. */
		ulOriginalPriority = *pucFirstUserPriorityRegister;

		/* Determine the number of priority bits available.  First write to all
		possible bits. */
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
 8004578:	f04f 0cff 	mov.w	ip, #255	@ 0xff
	void vSetVarulMaxPRIGROUPValue(){
 800457c:	b410      	push	{r4}
		/* Use the same mask on the maximum system call priority. */
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;

		/* Calculate the maximum acceptable priority group value for the number
		of bits read back. */
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 800457e:	2407      	movs	r4, #7
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 8004580:	4b1d      	ldr	r3, [pc, #116]	@ (80045f8 <vSetVarulMaxPRIGROUPValue+0x80>)
	void vSetVarulMaxPRIGROUPValue(){
 8004582:	b083      	sub	sp, #12
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 8004584:	781a      	ldrb	r2, [r3, #0]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 8004586:	491d      	ldr	r1, [pc, #116]	@ (80045fc <vSetVarulMaxPRIGROUPValue+0x84>)
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 8004588:	b2d2      	uxtb	r2, r2
 800458a:	9201      	str	r2, [sp, #4]
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
 800458c:	f883 c000 	strb.w	ip, [r3]
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
 8004590:	781b      	ldrb	r3, [r3, #0]
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 8004592:	481b      	ldr	r0, [pc, #108]	@ (8004600 <vSetVarulMaxPRIGROUPValue+0x88>)
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
 8004594:	b2db      	uxtb	r3, r3
 8004596:	f88d 3003 	strb.w	r3, [sp, #3]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 800459a:	f89d 3003 	ldrb.w	r3, [sp, #3]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 800459e:	f89d 2003 	ldrb.w	r2, [sp, #3]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 80045a2:	f003 0350 	and.w	r3, r3, #80	@ 0x50
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 80045a6:	0612      	lsls	r2, r2, #24
 80045a8:	bf48      	it	mi
 80045aa:	2206      	movmi	r2, #6
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 80045ac:	6004      	str	r4, [r0, #0]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 80045ae:	700b      	strb	r3, [r1, #0]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 80045b0:	d50e      	bpl.n	80045d0 <vSetVarulMaxPRIGROUPValue+0x58>
		{
			ulMaxPRIGROUPValue--;
			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
 80045b2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80045b6:	4611      	mov	r1, r2
 80045b8:	005b      	lsls	r3, r3, #1
 80045ba:	b2db      	uxtb	r3, r3
 80045bc:	f88d 3003 	strb.w	r3, [sp, #3]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 80045c0:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80045c4:	3a01      	subs	r2, #1
 80045c6:	061b      	lsls	r3, r3, #24
 80045c8:	d4f3      	bmi.n	80045b2 <vSetVarulMaxPRIGROUPValue+0x3a>
		#ifdef configPRIO_BITS
		{
			/* Check the FreeRTOS configuration that defines the number of
			priority bits matches the number of priority bits actually queried
			from the hardware. */
			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );
 80045ca:	2903      	cmp	r1, #3
 80045cc:	d009      	beq.n	80045e2 <vSetVarulMaxPRIGROUPValue+0x6a>
 80045ce:	6001      	str	r1, [r0, #0]
 80045d0:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80045d4:	f383 8811 	msr	BASEPRI, r3
 80045d8:	f3bf 8f6f 	isb	sy
 80045dc:	f3bf 8f4f 	dsb	sy
 80045e0:	e7fe      	b.n	80045e0 <vSetVarulMaxPRIGROUPValue+0x68>
		#endif

		/* Shift the priority group value back to its position within the AIRCR
		register. */
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
 80045e2:	f44f 7140 	mov.w	r1, #768	@ 0x300

		/* Restore the clobbered interrupt priority register to its original
		value. */
		*pucFirstUserPriorityRegister = ulOriginalPriority;
 80045e6:	9b01      	ldr	r3, [sp, #4]
 80045e8:	4a03      	ldr	r2, [pc, #12]	@ (80045f8 <vSetVarulMaxPRIGROUPValue+0x80>)
 80045ea:	b2db      	uxtb	r3, r3
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
 80045ec:	6001      	str	r1, [r0, #0]
		*pucFirstUserPriorityRegister = ulOriginalPriority;
 80045ee:	7013      	strb	r3, [r2, #0]
	}
	#endif /* conifgASSERT_DEFINED */

	}
 80045f0:	b003      	add	sp, #12
 80045f2:	bc10      	pop	{r4}
 80045f4:	4770      	bx	lr
 80045f6:	bf00      	nop
 80045f8:	e000e400 	.word	0xe000e400
 80045fc:	20000ba8 	.word	0x20000ba8
 8004600:	20000ba4 	.word	0x20000ba4

08004604 <pvPortMalloc>:
static size_t xBlockAllocatedBit = 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 8004604:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8004608:	4604      	mov	r4, r0
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;

	vTaskSuspendAll();
 800460a:	f7ff f8e9 	bl	80037e0 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
 800460e:	4954      	ldr	r1, [pc, #336]	@ (8004760 <pvPortMalloc+0x15c>)
 8004610:	680d      	ldr	r5, [r1, #0]
 8004612:	2d00      	cmp	r5, #0
 8004614:	d036      	beq.n	8004684 <pvPortMalloc+0x80>

		/* Check the requested block size is not so large that the top bit is
		set.  The top bit of the block size member of the BlockLink_t structure
		is used to determine who owns the block - the application or the
		kernel, so it must be free. */
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
 8004616:	4b53      	ldr	r3, [pc, #332]	@ (8004764 <pvPortMalloc+0x160>)
 8004618:	681e      	ldr	r6, [r3, #0]
 800461a:	4234      	tst	r4, r6
 800461c:	d12c      	bne.n	8004678 <pvPortMalloc+0x74>
		{
			/* The wanted size is increased so it can contain a BlockLink_t
			structure in addition to the requested amount of bytes. */
			if( xWantedSize > 0 )
 800461e:	b35c      	cbz	r4, 8004678 <pvPortMalloc+0x74>
			{
				xWantedSize += xHeapStructSize;
 8004620:	f104 0008 	add.w	r0, r4, #8

				/* Ensure that blocks are always aligned to the required number
				of bytes. */
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 8004624:	0764      	lsls	r4, r4, #29
				{
					/* Byte alignment required. */
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 8004626:	bf1c      	itt	ne
 8004628:	f020 0007 	bicne.w	r0, r0, #7
 800462c:	3008      	addne	r0, #8
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 800462e:	b318      	cbz	r0, 8004678 <pvPortMalloc+0x74>
 8004630:	f8df e134 	ldr.w	lr, [pc, #308]	@ 8004768 <pvPortMalloc+0x164>
 8004634:	f8de c000 	ldr.w	ip, [lr]
 8004638:	4584      	cmp	ip, r0
 800463a:	d31d      	bcc.n	8004678 <pvPortMalloc+0x74>
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
 800463c:	4b4b      	ldr	r3, [pc, #300]	@ (800476c <pvPortMalloc+0x168>)
				pxPreviousBlock = &xStart;
 800463e:	461c      	mov	r4, r3
				pxBlock = xStart.pxNextFreeBlock;
 8004640:	681b      	ldr	r3, [r3, #0]
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 8004642:	e003      	b.n	800464c <pvPortMalloc+0x48>
 8004644:	681a      	ldr	r2, [r3, #0]
 8004646:	b122      	cbz	r2, 8004652 <pvPortMalloc+0x4e>
				{
					pxPreviousBlock = pxBlock;
 8004648:	461c      	mov	r4, r3
					pxBlock = pxBlock->pxNextFreeBlock;
 800464a:	4613      	mov	r3, r2
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 800464c:	6859      	ldr	r1, [r3, #4]
 800464e:	4281      	cmp	r1, r0
 8004650:	d3f8      	bcc.n	8004644 <pvPortMalloc+0x40>
				}

				/* If the end marker was reached then a block of adequate size
				was	not found. */
				if( pxBlock != pxEnd )
 8004652:	42ab      	cmp	r3, r5
 8004654:	d010      	beq.n	8004678 <pvPortMalloc+0x74>
					BlockLink_t structure at its start. */
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );

					/* This block is being returned for use so must be taken out
					of the list of free blocks. */
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 8004656:	681a      	ldr	r2, [r3, #0]
 8004658:	6022      	str	r2, [r4, #0]

					/* If the block is larger than required it can be split into
					two. */
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 800465a:	1a0c      	subs	r4, r1, r0
 800465c:	2c10      	cmp	r4, #16
 800465e:	d946      	bls.n	80046ee <pvPortMalloc+0xea>
					{
						/* This block is to be split into two.  Create a new
						block following the number of bytes requested. The void
						cast is used to prevent byte alignment warnings from the
						compiler. */
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 8004660:	181a      	adds	r2, r3, r0
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
 8004662:	0751      	lsls	r1, r2, #29
 8004664:	d02c      	beq.n	80046c0 <pvPortMalloc+0xbc>
 8004666:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800466a:	f383 8811 	msr	BASEPRI, r3
 800466e:	f3bf 8f6f 	isb	sy
 8004672:	f3bf 8f4f 	dsb	sy
 8004676:	e7fe      	b.n	8004676 <pvPortMalloc+0x72>
			mtCOVERAGE_TEST_MARKER();
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
 8004678:	f7ff f8ba 	bl	80037f0 <xTaskResumeAll>
void *pvReturn = NULL;
 800467c:	2400      	movs	r4, #0
	}
	#endif

	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
	return pvReturn;
}
 800467e:	4620      	mov	r0, r4
 8004680:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
uint8_t *pucAlignedHeap;
size_t uxAddress;
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;

	/* Ensure the heap starts on a correctly aligned boundary. */
	uxAddress = ( size_t ) ucHeap;
 8004684:	4b3a      	ldr	r3, [pc, #232]	@ (8004770 <pvPortMalloc+0x16c>)
	pucAlignedHeap = ( uint8_t * ) uxAddress;

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
	xStart.xBlockSize = ( size_t ) 0;
 8004686:	2000      	movs	r0, #0
	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 8004688:	075d      	lsls	r5, r3, #29
		uxAddress += ( portBYTE_ALIGNMENT - 1 );
 800468a:	bf1c      	itt	ne
 800468c:	3307      	addne	r3, #7
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 800468e:	f023 0307 	bicne.w	r3, r3, #7
 8004692:	461a      	mov	r2, r3
	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 8004694:	f04f 4700 	mov.w	r7, #2147483648	@ 0x80000000
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 8004698:	4d34      	ldr	r5, [pc, #208]	@ (800476c <pvPortMalloc+0x168>)
}
 800469a:	463e      	mov	r6, r7
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 800469c:	602b      	str	r3, [r5, #0]
	xStart.xBlockSize = ( size_t ) 0;
 800469e:	6068      	str	r0, [r5, #4]
	uxAddress -= xHeapStructSize;
 80046a0:	4d34      	ldr	r5, [pc, #208]	@ (8004774 <pvPortMalloc+0x170>)
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 80046a2:	f025 0507 	bic.w	r5, r5, #7
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 80046a6:	1aeb      	subs	r3, r5, r3
	pxEnd->pxNextFreeBlock = NULL;
 80046a8:	e9c5 0000 	strd	r0, r0, [r5]
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
 80046ac:	e9c2 5300 	strd	r5, r3, [r2]
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 80046b0:	4a31      	ldr	r2, [pc, #196]	@ (8004778 <pvPortMalloc+0x174>)
	pxEnd = ( void * ) uxAddress;
 80046b2:	600d      	str	r5, [r1, #0]
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 80046b4:	6013      	str	r3, [r2, #0]
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 80046b6:	4a2c      	ldr	r2, [pc, #176]	@ (8004768 <pvPortMalloc+0x164>)
 80046b8:	6013      	str	r3, [r2, #0]
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 80046ba:	4b2a      	ldr	r3, [pc, #168]	@ (8004764 <pvPortMalloc+0x160>)
 80046bc:	601f      	str	r7, [r3, #0]
}
 80046be:	e7ac      	b.n	800461a <pvPortMalloc+0x16>
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 80046c0:	492a      	ldr	r1, [pc, #168]	@ (800476c <pvPortMalloc+0x168>)
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 80046c2:	6054      	str	r4, [r2, #4]
						pxBlock->xBlockSize = xWantedSize;
 80046c4:	6058      	str	r0, [r3, #4]
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 80046c6:	460c      	mov	r4, r1
 80046c8:	6809      	ldr	r1, [r1, #0]
 80046ca:	428a      	cmp	r2, r1
 80046cc:	d8fb      	bhi.n	80046c6 <pvPortMalloc+0xc2>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 80046ce:	6867      	ldr	r7, [r4, #4]
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 80046d0:	f8d2 8004 	ldr.w	r8, [r2, #4]
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 80046d4:	eb04 0907 	add.w	r9, r4, r7
 80046d8:	454a      	cmp	r2, r9
 80046da:	d028      	beq.n	800472e <pvPortMalloc+0x12a>
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 80046dc:	eb02 0708 	add.w	r7, r2, r8
 80046e0:	42b9      	cmp	r1, r7
 80046e2:	d02b      	beq.n	800473c <pvPortMalloc+0x138>
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
 80046e4:	6011      	str	r1, [r2, #0]
 80046e6:	4601      	mov	r1, r0

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
 80046e8:	42a2      	cmp	r2, r4
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 80046ea:	bf18      	it	ne
 80046ec:	6022      	strne	r2, [r4, #0]
					pxBlock->pxNextFreeBlock = NULL;
 80046ee:	2500      	movs	r5, #0
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 80046f0:	4821      	ldr	r0, [pc, #132]	@ (8004778 <pvPortMalloc+0x174>)
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 80046f2:	ebac 0201 	sub.w	r2, ip, r1
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 80046f6:	6804      	ldr	r4, [r0, #0]
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 80046f8:	f8ce 2000 	str.w	r2, [lr]
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 80046fc:	42a2      	cmp	r2, r4
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
 80046fe:	bf38      	it	cc
 8004700:	6002      	strcc	r2, [r0, #0]
					xNumberOfSuccessfulAllocations++;
 8004702:	481e      	ldr	r0, [pc, #120]	@ (800477c <pvPortMalloc+0x178>)
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 8004704:	4331      	orrs	r1, r6
					xNumberOfSuccessfulAllocations++;
 8004706:	6802      	ldr	r2, [r0, #0]
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 8004708:	6059      	str	r1, [r3, #4]
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 800470a:	f103 0408 	add.w	r4, r3, #8
					xNumberOfSuccessfulAllocations++;
 800470e:	3201      	adds	r2, #1
					pxBlock->pxNextFreeBlock = NULL;
 8004710:	601d      	str	r5, [r3, #0]
					xNumberOfSuccessfulAllocations++;
 8004712:	6002      	str	r2, [r0, #0]
	( void ) xTaskResumeAll();
 8004714:	f7ff f86c 	bl	80037f0 <xTaskResumeAll>
	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
 8004718:	0763      	lsls	r3, r4, #29
 800471a:	d0b0      	beq.n	800467e <pvPortMalloc+0x7a>
 800471c:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8004720:	f383 8811 	msr	BASEPRI, r3
 8004724:	f3bf 8f6f 	isb	sy
 8004728:	f3bf 8f4f 	dsb	sy
 800472c:	e7fe      	b.n	800472c <pvPortMalloc+0x128>
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 800472e:	4447      	add	r7, r8
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 8004730:	19e0      	adds	r0, r4, r7
 8004732:	4281      	cmp	r1, r0
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 8004734:	6067      	str	r7, [r4, #4]
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 8004736:	d00a      	beq.n	800474e <pvPortMalloc+0x14a>
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 8004738:	6859      	ldr	r1, [r3, #4]
	if( pxIterator != pxBlockToInsert )
 800473a:	e7d8      	b.n	80046ee <pvPortMalloc+0xea>
		if( pxIterator->pxNextFreeBlock != pxEnd )
 800473c:	42a9      	cmp	r1, r5
 800473e:	d0d1      	beq.n	80046e4 <pvPortMalloc+0xe0>
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 8004740:	6848      	ldr	r0, [r1, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 8004742:	6809      	ldr	r1, [r1, #0]
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 8004744:	4440      	add	r0, r8
 8004746:	6050      	str	r0, [r2, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 8004748:	6011      	str	r1, [r2, #0]
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 800474a:	6859      	ldr	r1, [r3, #4]
 800474c:	e7cc      	b.n	80046e8 <pvPortMalloc+0xe4>
		if( pxIterator->pxNextFreeBlock != pxEnd )
 800474e:	42a9      	cmp	r1, r5
 8004750:	d0f2      	beq.n	8004738 <pvPortMalloc+0x134>
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 8004752:	6848      	ldr	r0, [r1, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 8004754:	680a      	ldr	r2, [r1, #0]
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 8004756:	4438      	add	r0, r7
 8004758:	6060      	str	r0, [r4, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 800475a:	6022      	str	r2, [r4, #0]
 800475c:	e7ec      	b.n	8004738 <pvPortMalloc+0x134>
 800475e:	bf00      	nop
 8004760:	20000bc0 	.word	0x20000bc0
 8004764:	20000bac 	.word	0x20000bac
 8004768:	20000bbc 	.word	0x20000bbc
 800476c:	20000bc4 	.word	0x20000bc4
 8004770:	20000bcc 	.word	0x20000bcc
 8004774:	200017c4 	.word	0x200017c4
 8004778:	20000bb8 	.word	0x20000bb8
 800477c:	20000bb4 	.word	0x20000bb4

08004780 <vPortFree>:
	if( pv != NULL )
 8004780:	b1d0      	cbz	r0, 80047b8 <vPortFree+0x38>
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 8004782:	4a2f      	ldr	r2, [pc, #188]	@ (8004840 <vPortFree+0xc0>)
 8004784:	f850 3c04 	ldr.w	r3, [r0, #-4]
 8004788:	6812      	ldr	r2, [r2, #0]
 800478a:	4213      	tst	r3, r2
 800478c:	d00b      	beq.n	80047a6 <vPortFree+0x26>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
 800478e:	f850 1c08 	ldr.w	r1, [r0, #-8]
 8004792:	b191      	cbz	r1, 80047ba <vPortFree+0x3a>
 8004794:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8004798:	f383 8811 	msr	BASEPRI, r3
 800479c:	f3bf 8f6f 	isb	sy
 80047a0:	f3bf 8f4f 	dsb	sy
 80047a4:	e7fe      	b.n	80047a4 <vPortFree+0x24>
 80047a6:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80047aa:	f383 8811 	msr	BASEPRI, r3
 80047ae:	f3bf 8f6f 	isb	sy
 80047b2:	f3bf 8f4f 	dsb	sy
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 80047b6:	e7fe      	b.n	80047b6 <vPortFree+0x36>
 80047b8:	4770      	bx	lr
{
 80047ba:	b530      	push	{r4, r5, lr}
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 80047bc:	ea23 0302 	bic.w	r3, r3, r2
{
 80047c0:	b083      	sub	sp, #12
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 80047c2:	f840 3c04 	str.w	r3, [r0, #-4]
					xFreeBytesRemaining += pxLink->xBlockSize;
 80047c6:	4d1f      	ldr	r5, [pc, #124]	@ (8004844 <vPortFree+0xc4>)
		puc -= xHeapStructSize;
 80047c8:	f1a0 0408 	sub.w	r4, r0, #8
 80047cc:	9001      	str	r0, [sp, #4]
				vTaskSuspendAll();
 80047ce:	f7ff f807 	bl	80037e0 <vTaskSuspendAll>
					xFreeBytesRemaining += pxLink->xBlockSize;
 80047d2:	9801      	ldr	r0, [sp, #4]
 80047d4:	682a      	ldr	r2, [r5, #0]
 80047d6:	f850 1c04 	ldr.w	r1, [r0, #-4]
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 80047da:	4b1b      	ldr	r3, [pc, #108]	@ (8004848 <vPortFree+0xc8>)
					xFreeBytesRemaining += pxLink->xBlockSize;
 80047dc:	440a      	add	r2, r1
 80047de:	602a      	str	r2, [r5, #0]
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 80047e0:	461a      	mov	r2, r3
 80047e2:	681b      	ldr	r3, [r3, #0]
 80047e4:	429c      	cmp	r4, r3
 80047e6:	d8fb      	bhi.n	80047e0 <vPortFree+0x60>
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 80047e8:	6855      	ldr	r5, [r2, #4]
 80047ea:	eb02 0e05 	add.w	lr, r2, r5
 80047ee:	4574      	cmp	r4, lr
 80047f0:	d011      	beq.n	8004816 <vPortFree+0x96>
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 80047f2:	eb04 0c01 	add.w	ip, r4, r1
 80047f6:	4563      	cmp	r3, ip
 80047f8:	d01d      	beq.n	8004836 <vPortFree+0xb6>
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
 80047fa:	f840 3c08 	str.w	r3, [r0, #-8]
	if( pxIterator != pxBlockToInsert )
 80047fe:	42a2      	cmp	r2, r4
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 8004800:	bf18      	it	ne
 8004802:	6014      	strne	r4, [r2, #0]
					xNumberOfSuccessfulFrees++;
 8004804:	4a11      	ldr	r2, [pc, #68]	@ (800484c <vPortFree+0xcc>)
 8004806:	6813      	ldr	r3, [r2, #0]
 8004808:	3301      	adds	r3, #1
 800480a:	6013      	str	r3, [r2, #0]
}
 800480c:	b003      	add	sp, #12
 800480e:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
				( void ) xTaskResumeAll();
 8004812:	f7fe bfed 	b.w	80037f0 <xTaskResumeAll>
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 8004816:	4429      	add	r1, r5
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 8004818:	1850      	adds	r0, r2, r1
 800481a:	4283      	cmp	r3, r0
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 800481c:	6051      	str	r1, [r2, #4]
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 800481e:	d1f1      	bne.n	8004804 <vPortFree+0x84>
		if( pxIterator->pxNextFreeBlock != pxEnd )
 8004820:	480b      	ldr	r0, [pc, #44]	@ (8004850 <vPortFree+0xd0>)
 8004822:	6800      	ldr	r0, [r0, #0]
 8004824:	4283      	cmp	r3, r0
 8004826:	d0ed      	beq.n	8004804 <vPortFree+0x84>
		pxBlockToInsert = pxIterator;
 8004828:	4614      	mov	r4, r2
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 800482a:	6858      	ldr	r0, [r3, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 800482c:	681b      	ldr	r3, [r3, #0]
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 800482e:	4401      	add	r1, r0
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 8004830:	6023      	str	r3, [r4, #0]
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 8004832:	6061      	str	r1, [r4, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 8004834:	e7e3      	b.n	80047fe <vPortFree+0x7e>
		if( pxIterator->pxNextFreeBlock != pxEnd )
 8004836:	4d06      	ldr	r5, [pc, #24]	@ (8004850 <vPortFree+0xd0>)
 8004838:	682d      	ldr	r5, [r5, #0]
 800483a:	42ab      	cmp	r3, r5
 800483c:	d1f5      	bne.n	800482a <vPortFree+0xaa>
 800483e:	e7dc      	b.n	80047fa <vPortFree+0x7a>
 8004840:	20000bac 	.word	0x20000bac
 8004844:	20000bbc 	.word	0x20000bbc
 8004848:	20000bc4 	.word	0x20000bc4
 800484c:	20000bb0 	.word	0x20000bb0
 8004850:	20000bc0 	.word	0x20000bc0

08004854 <_cbSendSystemDesc>:
*       _cbSendSystemDesc()
*
*  Function description
*    Sends SystemView description strings.
*/
static void _cbSendSystemDesc(void) {
 8004854:	b508      	push	{r3, lr}
  SEGGER_SYSVIEW_SendSysDesc("N="SYSVIEW_APP_NAME",D="SYSVIEW_DEVICE_NAME",O=FreeRTOS");
 8004856:	4804      	ldr	r0, [pc, #16]	@ (8004868 <_cbSendSystemDesc+0x14>)
 8004858:	f001 f866 	bl	8005928 <SEGGER_SYSVIEW_SendSysDesc>
  SEGGER_SYSVIEW_SendSysDesc("I#15=SysTick");
}
 800485c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  SEGGER_SYSVIEW_SendSysDesc("I#15=SysTick");
 8004860:	4802      	ldr	r0, [pc, #8]	@ (800486c <_cbSendSystemDesc+0x18>)
 8004862:	f001 b861 	b.w	8005928 <SEGGER_SYSVIEW_SendSysDesc>
 8004866:	bf00      	nop
 8004868:	08006e78 	.word	0x08006e78
 800486c:	08006ea0 	.word	0x08006ea0

08004870 <SEGGER_SYSVIEW_Conf>:
*
*       Global functions
*
**********************************************************************
*/
void SEGGER_SYSVIEW_Conf(void) {
 8004870:	b508      	push	{r3, lr}
  SEGGER_SYSVIEW_Init(SYSVIEW_TIMESTAMP_FREQ, SYSVIEW_CPU_FREQ, 
 8004872:	4a06      	ldr	r2, [pc, #24]	@ (800488c <SEGGER_SYSVIEW_Conf+0x1c>)
 8004874:	4b06      	ldr	r3, [pc, #24]	@ (8004890 <SEGGER_SYSVIEW_Conf+0x20>)
 8004876:	6811      	ldr	r1, [r2, #0]
 8004878:	4a06      	ldr	r2, [pc, #24]	@ (8004894 <SEGGER_SYSVIEW_Conf+0x24>)
 800487a:	4608      	mov	r0, r1
 800487c:	f000 fcaa 	bl	80051d4 <SEGGER_SYSVIEW_Init>
                      &SYSVIEW_X_OS_TraceAPI, _cbSendSystemDesc);
  SEGGER_SYSVIEW_SetRAMBase(SYSVIEW_RAM_BASE);
}
 8004880:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  SEGGER_SYSVIEW_SetRAMBase(SYSVIEW_RAM_BASE);
 8004884:	f04f 5000 	mov.w	r0, #536870912	@ 0x20000000
 8004888:	f000 bcd6 	b.w	8005238 <SEGGER_SYSVIEW_SetRAMBase>
 800488c:	2000001c 	.word	0x2000001c
 8004890:	08004855 	.word	0x08004855
 8004894:	08006f54 	.word	0x08006f54

08004898 <_cbGetTime>:
*  Function description
*    This function is part of the link between FreeRTOS and SYSVIEW.
*    Called from SystemView when asked by the host, returns the
*    current system time in micro seconds.
*/
static U64 _cbGetTime(void) {
 8004898:	b508      	push	{r3, lr}
  U64 Time;

  Time = xTaskGetTickCountFromISR();
 800489a:	f7fe ffbf 	bl	800381c <xTaskGetTickCountFromISR>
  Time *= portTICK_PERIOD_MS;
  Time *= 1000;
 800489e:	f44f 717a 	mov.w	r1, #1000	@ 0x3e8
  return Time;
}
 80048a2:	fba0 0101 	umull	r0, r1, r0, r1
 80048a6:	bd08      	pop	{r3, pc}

080048a8 <_cbSendTaskList>:
static void _cbSendTaskList(void) {
 80048a8:	b5f0      	push	{r4, r5, r6, r7, lr}
  for (n = 0; n < _NumTasks; n++) {
 80048aa:	4f10      	ldr	r7, [pc, #64]	@ (80048ec <_cbSendTaskList+0x44>)
static void _cbSendTaskList(void) {
 80048ac:	b087      	sub	sp, #28
  for (n = 0; n < _NumTasks; n++) {
 80048ae:	683b      	ldr	r3, [r7, #0]
 80048b0:	b1cb      	cbz	r3, 80048e6 <_cbSendTaskList+0x3e>
 80048b2:	2500      	movs	r5, #0
*    Record task information.
*/
void SYSVIEW_SendTaskInfo(U32 TaskID, const char* sName, unsigned Prio, U32 StackBase, unsigned StackSize) {
  SEGGER_SYSVIEW_TASKINFO TaskInfo;

  memset(&TaskInfo, 0, sizeof(TaskInfo)); // Fill all elements with 0 to allow extending the structure in future version without breaking the code
 80048b4:	462e      	mov	r6, r5
 80048b6:	4c0e      	ldr	r4, [pc, #56]	@ (80048f0 <_cbSendTaskList+0x48>)
  TaskInfo.TaskID     = TaskID;
 80048b8:	f8d4 c000 	ldr.w	ip, [r4]
    SYSVIEW_SendTaskInfo((U32)_aTasks[n].xHandle, _aTasks[n].pcTaskName, (unsigned)_aTasks[n].uxCurrentPriority, (U32)_aTasks[n].pxStack, (unsigned)_aTasks[n].uStackHighWaterMark);
 80048bc:	6923      	ldr	r3, [r4, #16]
  TaskInfo.TaskID     = TaskID;
 80048be:	f8cd c000 	str.w	ip, [sp]
  TaskInfo.sName      = sName;
 80048c2:	f8d4 c004 	ldr.w	ip, [r4, #4]
  TaskInfo.Prio       = Prio;
  TaskInfo.StackBase  = StackBase;
  TaskInfo.StackSize  = StackSize;
  SEGGER_SYSVIEW_SendTaskInfo(&TaskInfo);
 80048c6:	4668      	mov	r0, sp
    SYSVIEW_SendTaskInfo((U32)_aTasks[n].xHandle, _aTasks[n].pcTaskName, (unsigned)_aTasks[n].uxCurrentPriority, (U32)_aTasks[n].pxStack, (unsigned)_aTasks[n].uStackHighWaterMark);
 80048c8:	e9d4 1202 	ldrd	r1, r2, [r4, #8]
  memset(&TaskInfo, 0, sizeof(TaskInfo)); // Fill all elements with 0 to allow extending the structure in future version without breaking the code
 80048cc:	9605      	str	r6, [sp, #20]
  TaskInfo.Prio       = Prio;
 80048ce:	e9cd 2303 	strd	r2, r3, [sp, #12]
 80048d2:	e9cd c101 	strd	ip, r1, [sp, #4]
  SEGGER_SYSVIEW_SendTaskInfo(&TaskInfo);
 80048d6:	f000 ffa1 	bl	800581c <SEGGER_SYSVIEW_SendTaskInfo>
  for (n = 0; n < _NumTasks; n++) {
 80048da:	683b      	ldr	r3, [r7, #0]
 80048dc:	3501      	adds	r5, #1
 80048de:	42ab      	cmp	r3, r5
 80048e0:	f104 0414 	add.w	r4, r4, #20
 80048e4:	d8e8      	bhi.n	80048b8 <_cbSendTaskList+0x10>
}
 80048e6:	b007      	add	sp, #28
 80048e8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80048ea:	bf00      	nop
 80048ec:	200017cc 	.word	0x200017cc
 80048f0:	200017d0 	.word	0x200017d0

080048f4 <SYSVIEW_AddTask>:
void SYSVIEW_AddTask(U32 xHandle, const char* pcTaskName, unsigned uxCurrentPriority, U32  pxStack, unsigned uStackHighWaterMark) {
 80048f4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80048f8:	460c      	mov	r4, r1
 80048fa:	b086      	sub	sp, #24
 80048fc:	4616      	mov	r6, r2
 80048fe:	4607      	mov	r7, r0
  if (memcmp(pcTaskName, "IDLE", 5) == 0) {
 8004900:	2205      	movs	r2, #5
 8004902:	4620      	mov	r0, r4
 8004904:	4916      	ldr	r1, [pc, #88]	@ (8004960 <SYSVIEW_AddTask+0x6c>)
void SYSVIEW_AddTask(U32 xHandle, const char* pcTaskName, unsigned uxCurrentPriority, U32  pxStack, unsigned uStackHighWaterMark) {
 8004906:	461d      	mov	r5, r3
 8004908:	f8dd 8030 	ldr.w	r8, [sp, #48]	@ 0x30
  if (memcmp(pcTaskName, "IDLE", 5) == 0) {
 800490c:	f002 f97e 	bl	8006c0c <memcmp>
 8004910:	b1e0      	cbz	r0, 800494c <SYSVIEW_AddTask+0x58>
  if (_NumTasks >= SYSVIEW_FREERTOS_MAX_NOF_TASKS) {
 8004912:	4914      	ldr	r1, [pc, #80]	@ (8004964 <SYSVIEW_AddTask+0x70>)
 8004914:	680b      	ldr	r3, [r1, #0]
 8004916:	2b07      	cmp	r3, #7
 8004918:	d81b      	bhi.n	8004952 <SYSVIEW_AddTask+0x5e>
  memset(&TaskInfo, 0, sizeof(TaskInfo)); // Fill all elements with 0 to allow extending the structure in future version without breaking the code
 800491a:	2200      	movs	r2, #0
 800491c:	9205      	str	r2, [sp, #20]
  _aTasks[_NumTasks].xHandle = xHandle;
 800491e:	4a12      	ldr	r2, [pc, #72]	@ (8004968 <SYSVIEW_AddTask+0x74>)
 8004920:	eb03 0083 	add.w	r0, r3, r3, lsl #2
 8004924:	f842 7020 	str.w	r7, [r2, r0, lsl #2]
  _NumTasks++;
 8004928:	3301      	adds	r3, #1
  _aTasks[_NumTasks].xHandle = xHandle;
 800492a:	eb02 0280 	add.w	r2, r2, r0, lsl #2
  SEGGER_SYSVIEW_SendTaskInfo(&TaskInfo);
 800492e:	4668      	mov	r0, sp
  TaskInfo.sName      = sName;
 8004930:	e9cd 7400 	strd	r7, r4, [sp]
  TaskInfo.StackBase  = StackBase;
 8004934:	e9cd 6502 	strd	r6, r5, [sp, #8]
  _aTasks[_NumTasks].uxCurrentPriority = uxCurrentPriority;
 8004938:	e9c2 4601 	strd	r4, r6, [r2, #4]
  TaskInfo.StackSize  = StackSize;
 800493c:	f8cd 8010 	str.w	r8, [sp, #16]
  _aTasks[_NumTasks].pxStack = pxStack;
 8004940:	60d5      	str	r5, [r2, #12]
  _aTasks[_NumTasks].uStackHighWaterMark = uStackHighWaterMark;
 8004942:	f8c2 8010 	str.w	r8, [r2, #16]
  _NumTasks++;
 8004946:	600b      	str	r3, [r1, #0]
  SEGGER_SYSVIEW_SendTaskInfo(&TaskInfo);
 8004948:	f000 ff68 	bl	800581c <SEGGER_SYSVIEW_SendTaskInfo>
}
 800494c:	b006      	add	sp, #24
 800494e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    SEGGER_SYSVIEW_Warn("SYSTEMVIEW: Could not record task information. Maximum number of tasks reached.");
 8004952:	4806      	ldr	r0, [pc, #24]	@ (800496c <SYSVIEW_AddTask+0x78>)
}
 8004954:	b006      	add	sp, #24
 8004956:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    SEGGER_SYSVIEW_Warn("SYSTEMVIEW: Could not record task information. Maximum number of tasks reached.");
 800495a:	f002 b90d 	b.w	8006b78 <SEGGER_SYSVIEW_Warn>
 800495e:	bf00      	nop
 8004960:	08006e60 	.word	0x08006e60
 8004964:	200017cc 	.word	0x200017cc
 8004968:	200017d0 	.word	0x200017d0
 800496c:	08006eb0 	.word	0x08006eb0

08004970 <_cbOnUARTRx>:
	if (r == 0) {
		SEGGER_SYSVIEW_Start();
	}
}

static void _cbOnUARTRx(U8 Data) {
 8004970:	b510      	push	{r4, lr}
	if (_SVInfo.NumBytesHelloRcvd < _SERVER_HELLO_SIZE) {
 8004972:	4c0c      	ldr	r4, [pc, #48]	@ (80049a4 <_cbOnUARTRx+0x34>)
static void _cbOnUARTRx(U8 Data) {
 8004974:	b082      	sub	sp, #8
	if (_SVInfo.NumBytesHelloRcvd < _SERVER_HELLO_SIZE) {
 8004976:	7823      	ldrb	r3, [r4, #0]
static void _cbOnUARTRx(U8 Data) {
 8004978:	f88d 0007 	strb.w	r0, [sp, #7]
	if (_SVInfo.NumBytesHelloRcvd < _SERVER_HELLO_SIZE) {
 800497c:	2b03      	cmp	r3, #3
 800497e:	d803      	bhi.n	8004988 <_cbOnUARTRx+0x18>
		_SVInfo.NumBytesHelloRcvd++;
 8004980:	3301      	adds	r3, #1
 8004982:	7023      	strb	r3, [r4, #0]
		goto Done;
	}
	_StartSysView();
	SEGGER_RTT_WriteDownBuffer(_SVInfo.ChannelID, &Data, 1);
	Done: return;
}
 8004984:	b002      	add	sp, #8
 8004986:	bd10      	pop	{r4, pc}
	r = SEGGER_SYSVIEW_IsStarted();
 8004988:	f002 f924 	bl	8006bd4 <SEGGER_SYSVIEW_IsStarted>
	if (r == 0) {
 800498c:	b138      	cbz	r0, 800499e <_cbOnUARTRx+0x2e>
	SEGGER_RTT_WriteDownBuffer(_SVInfo.ChannelID, &Data, 1);
 800498e:	2201      	movs	r2, #1
 8004990:	6860      	ldr	r0, [r4, #4]
 8004992:	f10d 0107 	add.w	r1, sp, #7
 8004996:	f000 fa19 	bl	8004dcc <SEGGER_RTT_WriteDownBuffer>
}
 800499a:	b002      	add	sp, #8
 800499c:	bd10      	pop	{r4, pc}
		SEGGER_SYSVIEW_Start();
 800499e:	f001 fa2f 	bl	8005e00 <SEGGER_SYSVIEW_Start>
 80049a2:	e7f4      	b.n	800498e <_cbOnUARTRx+0x1e>
 80049a4:	2000002c 	.word	0x2000002c

080049a8 <_cbOnUARTTx>:

static int _cbOnUARTTx(U8 *pChar) {
 80049a8:	b510      	push	{r4, lr}
	int r;
	if (_SVInfo.NumBytesHelloSent < _TARGET_HELLO_SIZE) {
 80049aa:	4c09      	ldr	r4, [pc, #36]	@ (80049d0 <_cbOnUARTTx+0x28>)
static int _cbOnUARTTx(U8 *pChar) {
 80049ac:	4601      	mov	r1, r0
	if (_SVInfo.NumBytesHelloSent < _TARGET_HELLO_SIZE) {
 80049ae:	7863      	ldrb	r3, [r4, #1]
 80049b0:	2b03      	cmp	r3, #3
 80049b2:	d806      	bhi.n	80049c2 <_cbOnUARTTx+0x1a>
		*pChar = _abHelloMsg[_SVInfo.NumBytesHelloSent];
 80049b4:	4807      	ldr	r0, [pc, #28]	@ (80049d4 <_cbOnUARTTx+0x2c>)
		_SVInfo.NumBytesHelloSent++;
 80049b6:	1c5a      	adds	r2, r3, #1
		*pChar = _abHelloMsg[_SVInfo.NumBytesHelloSent];
 80049b8:	5cc3      	ldrb	r3, [r0, r3]
		_SVInfo.NumBytesHelloSent++;
 80049ba:	7062      	strb	r2, [r4, #1]
		*pChar = _abHelloMsg[_SVInfo.NumBytesHelloSent];
 80049bc:	700b      	strb	r3, [r1, #0]
		r = 1;
 80049be:	2001      	movs	r0, #1
	r = SEGGER_RTT_ReadUpBufferNoLock(_SVInfo.ChannelID, pChar, 1);
	if (r < 0) {
		r = 0;
	}
	Done: return r;
}
 80049c0:	bd10      	pop	{r4, pc}
	r = SEGGER_RTT_ReadUpBufferNoLock(_SVInfo.ChannelID, pChar, 1);
 80049c2:	2201      	movs	r2, #1
 80049c4:	6860      	ldr	r0, [r4, #4]
 80049c6:	f000 f893 	bl	8004af0 <SEGGER_RTT_ReadUpBufferNoLock>
	if (r < 0) {
 80049ca:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
}
 80049ce:	bd10      	pop	{r4, pc}
 80049d0:	2000002c 	.word	0x2000002c
 80049d4:	08006f5c 	.word	0x08006f5c

080049d8 <SEGGER_UART_init>:

void SEGGER_UART_init(U32 baud) {
 80049d8:	b410      	push	{r4}
            | (0 << 10)  // PCE = 0; No parity
            | (1 << 5)   // RXNEIE = 1; RX interrupt enabled
            | (1 << 3)   // TE = 1; Transmitter enabled
            | (1 << 2);  // RE = 1; Receiver enabled

    USART_CR2 = 0 | (0 << 12); // STOP = 00b; 1 stop bit
 80049da:	2100      	movs	r1, #0
    USART_CR1 = 0 | (0 << 15)  // OVER8 = 0; Oversampling by 16 (sửa từ 1 thành 0)
 80049dc:	f242 042c 	movw	r4, #8236	@ 0x202c
    RCC_APB2ENR |= (1 << 2) | (1 << 14); // Enable GPIOA and USART1 clocks
 80049e0:	4a1b      	ldr	r2, [pc, #108]	@ (8004a50 <SEGGER_UART_init+0x78>)
 80049e2:	6993      	ldr	r3, [r2, #24]
 80049e4:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 80049e8:	f043 0304 	orr.w	r3, r3, #4
 80049ec:	6193      	str	r3, [r2, #24]
    v = GPIO_CRH;
 80049ee:	f5a2 3288 	sub.w	r2, r2, #69632	@ 0x11000
 80049f2:	f8d2 3804 	ldr.w	r3, [r2, #2052]	@ 0x804
    v &= ~((0xF << ((GPIO_UART_TX_BIT - 8) * 4))
 80049f6:	f423 637f 	bic.w	r3, r3, #4080	@ 0xff0
    v |= (0xB << ((GPIO_UART_TX_BIT - 8) * 4))    // TX: AF push-pull, 50MHz
 80049fa:	f443 6396 	orr.w	r3, r3, #1200	@ 0x4b0
    GPIO_CRH = v;
 80049fe:	f8c2 3804 	str.w	r3, [r2, #2052]	@ 0x804

    USART_CR3 = 0 | (0 << 11)  // ONEBIT = 0; Three sample bit method
            | (0 << 7);  // DMAT = 0; DMA disabled (sửa từ 1 thành 0 để đơn giản)

    // Set baud rate - Công thức đúng cho oversampling 16
    Div = (UART_BASECLK + (Baudrate/2)) / Baudrate;  // Làm tròn
 8004a02:	4b14      	ldr	r3, [pc, #80]	@ (8004a54 <SEGGER_UART_init+0x7c>)
    USART_CR1 = 0 | (0 << 15)  // OVER8 = 0; Oversampling by 16 (sửa từ 1 thành 0)
 8004a04:	f502 5240 	add.w	r2, r2, #12288	@ 0x3000
    Div = (UART_BASECLK + (Baudrate/2)) / Baudrate;  // Làm tròn
 8004a08:	eb03 0350 	add.w	r3, r3, r0, lsr #1

    // Kiểm tra giới hạn
    if (Div < 1) {
 8004a0c:	4298      	cmp	r0, r3
    USART_CR1 = 0 | (0 << 15)  // OVER8 = 0; Oversampling by 16 (sửa từ 1 thành 0)
 8004a0e:	f8c2 480c 	str.w	r4, [r2, #2060]	@ 0x80c
    USART_CR2 = 0 | (0 << 12); // STOP = 00b; 1 stop bit
 8004a12:	f8c2 1810 	str.w	r1, [r2, #2064]	@ 0x810
    USART_CR3 = 0 | (0 << 11)  // ONEBIT = 0; Three sample bit method
 8004a16:	f8c2 1814 	str.w	r1, [r2, #2068]	@ 0x814
    if (Div < 1) {
 8004a1a:	d817      	bhi.n	8004a4c <SEGGER_UART_init+0x74>
    Div = (UART_BASECLK + (Baudrate/2)) / Baudrate;  // Làm tròn
 8004a1c:	fbb3 f0f0 	udiv	r0, r3, r0
        Div = 1;
    }
    if (Div > 0xFFFF) {
 8004a20:	f64f 73ff 	movw	r3, #65535	@ 0xffff
 8004a24:	4298      	cmp	r0, r3
 8004a26:	bf28      	it	cs
 8004a28:	4618      	movcs	r0, r3
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8004a2a:	2160      	movs	r1, #96	@ 0x60
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8004a2c:	2220      	movs	r2, #32
        Div = 0xFFFF;
    }

    USART_BRR = Div;  // Gán trực tiếp
 8004a2e:	4c0a      	ldr	r4, [pc, #40]	@ (8004a58 <SEGGER_UART_init+0x80>)
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8004a30:	4b0a      	ldr	r3, [pc, #40]	@ (8004a5c <SEGGER_UART_init+0x84>)
 8004a32:	f8c4 0808 	str.w	r0, [r4, #2056]	@ 0x808

    // Setup callbacks and enable interrupt
    _cbOnRx = cbOnRx;
 8004a36:	480a      	ldr	r0, [pc, #40]	@ (8004a60 <SEGGER_UART_init+0x88>)
 8004a38:	4c0a      	ldr	r4, [pc, #40]	@ (8004a64 <SEGGER_UART_init+0x8c>)
 8004a3a:	6004      	str	r4, [r0, #0]
    _cbOnTx = cbOnTx;
 8004a3c:	4c0a      	ldr	r4, [pc, #40]	@ (8004a68 <SEGGER_UART_init+0x90>)
 8004a3e:	480b      	ldr	r0, [pc, #44]	@ (8004a6c <SEGGER_UART_init+0x94>)
 8004a40:	6004      	str	r4, [r0, #0]
 8004a42:	f883 1325 	strb.w	r1, [r3, #805]	@ 0x325
}
 8004a46:	bc10      	pop	{r4}
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8004a48:	605a      	str	r2, [r3, #4]
 8004a4a:	4770      	bx	lr
        Div = 1;
 8004a4c:	2001      	movs	r0, #1
 8004a4e:	e7ec      	b.n	8004a2a <SEGGER_UART_init+0x52>
 8004a50:	40021000 	.word	0x40021000
 8004a54:	044aa200 	.word	0x044aa200
 8004a58:	40013000 	.word	0x40013000
 8004a5c:	e000e100 	.word	0xe000e100
 8004a60:	20001874 	.word	0x20001874
 8004a64:	08004971 	.word	0x08004971
 8004a68:	080049a9 	.word	0x080049a9
 8004a6c:	20001870 	.word	0x20001870

08004a70 <USART1_IRQHandler>:
void USART1_IRQHandler(void) {
 8004a70:	b510      	push	{r4, lr}
	UsartStatus = USART_SR;
 8004a72:	4b17      	ldr	r3, [pc, #92]	@ (8004ad0 <USART1_IRQHandler+0x60>)
void USART1_IRQHandler(void) {
 8004a74:	b082      	sub	sp, #8
	UsartStatus = USART_SR;
 8004a76:	f8d3 4800 	ldr.w	r4, [r3, #2048]	@ 0x800
	if (UsartStatus & (1 << USART_RXNE)) {
 8004a7a:	06a2      	lsls	r2, r4, #26
 8004a7c:	d507      	bpl.n	8004a8e <USART1_IRQHandler+0x1e>
		v = USART_DR;
 8004a7e:	f8d3 0804 	ldr.w	r0, [r3, #2052]	@ 0x804
		if ((UsartStatus & USART_RX_ERROR_FLAGS) == 0) {
 8004a82:	f014 0f0b 	tst.w	r4, #11
		v = USART_DR;
 8004a86:	b2c0      	uxtb	r0, r0
 8004a88:	f88d 0007 	strb.w	r0, [sp, #7]
		if ((UsartStatus & USART_RX_ERROR_FLAGS) == 0) {
 8004a8c:	d011      	beq.n	8004ab2 <USART1_IRQHandler+0x42>
	if (UsartStatus & (1 << USART_TXE)) {
 8004a8e:	0623      	lsls	r3, r4, #24
 8004a90:	d50d      	bpl.n	8004aae <USART1_IRQHandler+0x3e>
		if (_cbOnTx == NULL) {
 8004a92:	4b10      	ldr	r3, [pc, #64]	@ (8004ad4 <USART1_IRQHandler+0x64>)
 8004a94:	681b      	ldr	r3, [r3, #0]
 8004a96:	b153      	cbz	r3, 8004aae <USART1_IRQHandler+0x3e>
		r = _cbOnTx(&v);
 8004a98:	f10d 0007 	add.w	r0, sp, #7
 8004a9c:	4798      	blx	r3
		if (r == 0) {
 8004a9e:	b970      	cbnz	r0, 8004abe <USART1_IRQHandler+0x4e>
			USART_CR1 &= ~(1UL << USART_TXEIE);
 8004aa0:	4a0b      	ldr	r2, [pc, #44]	@ (8004ad0 <USART1_IRQHandler+0x60>)
 8004aa2:	f8d2 380c 	ldr.w	r3, [r2, #2060]	@ 0x80c
 8004aa6:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 8004aaa:	f8c2 380c 	str.w	r3, [r2, #2060]	@ 0x80c
}
 8004aae:	b002      	add	sp, #8
 8004ab0:	bd10      	pop	{r4, pc}
			if (_cbOnRx) {
 8004ab2:	4b09      	ldr	r3, [pc, #36]	@ (8004ad8 <USART1_IRQHandler+0x68>)
 8004ab4:	681b      	ldr	r3, [r3, #0]
 8004ab6:	2b00      	cmp	r3, #0
 8004ab8:	d0e9      	beq.n	8004a8e <USART1_IRQHandler+0x1e>
				_cbOnRx(v);
 8004aba:	4798      	blx	r3
 8004abc:	e7e7      	b.n	8004a8e <USART1_IRQHandler+0x1e>
			USART_SR;
 8004abe:	4b04      	ldr	r3, [pc, #16]	@ (8004ad0 <USART1_IRQHandler+0x60>)
			USART_DR = v;
 8004ac0:	f89d 2007 	ldrb.w	r2, [sp, #7]
			USART_SR;
 8004ac4:	f8d3 1800 	ldr.w	r1, [r3, #2048]	@ 0x800
			USART_DR = v;
 8004ac8:	f8c3 2804 	str.w	r2, [r3, #2052]	@ 0x804
}
 8004acc:	b002      	add	sp, #8
 8004ace:	bd10      	pop	{r4, pc}
 8004ad0:	40013000 	.word	0x40013000
 8004ad4:	20001870 	.word	0x20001870
 8004ad8:	20001874 	.word	0x20001874

08004adc <HIF_UART_EnableTXEInterrupt>:
	USART_CR1 |= (1 << USART_TXEIE);
 8004adc:	4a03      	ldr	r2, [pc, #12]	@ (8004aec <HIF_UART_EnableTXEInterrupt+0x10>)
 8004ade:	f8d2 380c 	ldr.w	r3, [r2, #2060]	@ 0x80c
 8004ae2:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 8004ae6:	f8c2 380c 	str.w	r3, [r2, #2060]	@ 0x80c
}
 8004aea:	4770      	bx	lr
 8004aec:	40013000 	.word	0x40013000

08004af0 <SEGGER_RTT_ReadUpBufferNoLock>:
*    Number of bytes that have been read.
*
*  Additional information
*    This function must not be called when J-Link might also do RTT.
*/
unsigned SEGGER_RTT_ReadUpBufferNoLock(unsigned BufferIndex, void* pData, unsigned BufferSize) {
 8004af0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  unsigned                WrOff;
  unsigned char*          pBuffer;
  SEGGER_RTT_BUFFER_UP*   pRing;
  volatile char*          pSrc;

  INIT();
 8004af4:	4c54      	ldr	r4, [pc, #336]	@ (8004c48 <SEGGER_RTT_ReadUpBufferNoLock+0x158>)
unsigned SEGGER_RTT_ReadUpBufferNoLock(unsigned BufferIndex, void* pData, unsigned BufferSize) {
 8004af6:	b083      	sub	sp, #12
  INIT();
 8004af8:	7823      	ldrb	r3, [r4, #0]
unsigned SEGGER_RTT_ReadUpBufferNoLock(unsigned BufferIndex, void* pData, unsigned BufferSize) {
 8004afa:	4606      	mov	r6, r0
  INIT();
 8004afc:	2b53      	cmp	r3, #83	@ 0x53
unsigned SEGGER_RTT_ReadUpBufferNoLock(unsigned BufferIndex, void* pData, unsigned BufferSize) {
 8004afe:	4690      	mov	r8, r2
 8004b00:	9100      	str	r1, [sp, #0]
  INIT();
 8004b02:	d03d      	beq.n	8004b80 <SEGGER_RTT_ReadUpBufferNoLock+0x90>
  memset((SEGGER_RTT_CB*)p, 0, sizeof(_SEGGER_RTT));         // Make sure that the RTT CB is always zero initialized.
 8004b04:	2278      	movs	r2, #120	@ 0x78
 8004b06:	2100      	movs	r1, #0
 8004b08:	f104 0030 	add.w	r0, r4, #48	@ 0x30
 8004b0c:	f002 f88e 	bl	8006c2c <memset>
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
 8004b10:	f04f 0c03 	mov.w	ip, #3
  p->aUp[0].RdOff         = 0u;
 8004b14:	2300      	movs	r3, #0
  p->aUp[0].SizeOfBuffer  = BUFFER_SIZE_UP;
 8004b16:	f04f 0902 	mov.w	r9, #2
    p->acID[i] = _aInitStr[sizeof(_aInitStr) - 2 - i];  // Skip terminating \0 at the end of the array
 8004b1a:	2045      	movs	r0, #69	@ 0x45
 8004b1c:	2547      	movs	r5, #71	@ 0x47
 8004b1e:	2152      	movs	r1, #82	@ 0x52
 8004b20:	2254      	movs	r2, #84	@ 0x54
  p->aDown[0].SizeOfBuffer  = BUFFER_SIZE_DOWN;
 8004b22:	f04f 0b10 	mov.w	fp, #16
    p->acID[i] = _aInitStr[sizeof(_aInitStr) - 2 - i];  // Skip terminating \0 at the end of the array
 8004b26:	f04f 0a53 	mov.w	sl, #83	@ 0x53
 8004b2a:	f04f 0e20 	mov.w	lr, #32
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
 8004b2e:	f8c4 c010 	str.w	ip, [r4, #16]
  p->aUp[0].sName         = "Terminal";
 8004b32:	4f46      	ldr	r7, [pc, #280]	@ (8004c4c <SEGGER_RTT_ReadUpBufferNoLock+0x15c>)
  p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
 8004b34:	f8c4 c014 	str.w	ip, [r4, #20]
  p->aUp[0].pBuffer       = _acUpBuffer;
 8004b38:	f8df c114 	ldr.w	ip, [pc, #276]	@ 8004c50 <SEGGER_RTT_ReadUpBufferNoLock+0x160>
  p->aUp[0].sName         = "Terminal";
 8004b3c:	61a7      	str	r7, [r4, #24]
  p->aUp[0].pBuffer       = _acUpBuffer;
 8004b3e:	f8c4 c01c 	str.w	ip, [r4, #28]
  p->aUp[0].SizeOfBuffer  = BUFFER_SIZE_UP;
 8004b42:	f8c4 9020 	str.w	r9, [r4, #32]
  p->aUp[0].RdOff         = 0u;
 8004b46:	62a3      	str	r3, [r4, #40]	@ 0x28
  p->aUp[0].WrOff         = 0u;
 8004b48:	6263      	str	r3, [r4, #36]	@ 0x24
  p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
 8004b4a:	62e3      	str	r3, [r4, #44]	@ 0x2c
  p->aDown[0].sName         = "Terminal";
 8004b4c:	6627      	str	r7, [r4, #96]	@ 0x60
  p->aDown[0].pBuffer       = _acDownBuffer;
 8004b4e:	4f41      	ldr	r7, [pc, #260]	@ (8004c54 <SEGGER_RTT_ReadUpBufferNoLock+0x164>)
 8004b50:	6667      	str	r7, [r4, #100]	@ 0x64
  p->aDown[0].SizeOfBuffer  = BUFFER_SIZE_DOWN;
 8004b52:	f8c4 b068 	str.w	fp, [r4, #104]	@ 0x68
  p->aDown[0].RdOff         = 0u;
 8004b56:	6723      	str	r3, [r4, #112]	@ 0x70
  p->aDown[0].WrOff         = 0u;
 8004b58:	66e3      	str	r3, [r4, #108]	@ 0x6c
  p->aDown[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
 8004b5a:	6763      	str	r3, [r4, #116]	@ 0x74
    p->acID[i] = _aInitStr[sizeof(_aInitStr) - 2 - i];  // Skip terminating \0 at the end of the array
 8004b5c:	f884 a000 	strb.w	sl, [r4]
 8004b60:	7060      	strb	r0, [r4, #1]
 8004b62:	70a5      	strb	r5, [r4, #2]
 8004b64:	70e5      	strb	r5, [r4, #3]
 8004b66:	7120      	strb	r0, [r4, #4]
 8004b68:	7161      	strb	r1, [r4, #5]
 8004b6a:	f884 e006 	strb.w	lr, [r4, #6]
 8004b6e:	71e1      	strb	r1, [r4, #7]
 8004b70:	7222      	strb	r2, [r4, #8]
 8004b72:	7262      	strb	r2, [r4, #9]
 8004b74:	72a3      	strb	r3, [r4, #10]
 8004b76:	72e3      	strb	r3, [r4, #11]
 8004b78:	7323      	strb	r3, [r4, #12]
 8004b7a:	7363      	strb	r3, [r4, #13]
 8004b7c:	73a3      	strb	r3, [r4, #14]
 8004b7e:	73e3      	strb	r3, [r4, #15]
  pRing = (SEGGER_RTT_BUFFER_UP*)((uintptr_t)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
  pBuffer = (unsigned char*)pData;
  RdOff = pRing->RdOff;
 8004b80:	eb06 0946 	add.w	r9, r6, r6, lsl #1
 8004b84:	eb04 09c9 	add.w	r9, r4, r9, lsl #3
 8004b88:	f8d9 7028 	ldr.w	r7, [r9, #40]	@ 0x28
  WrOff = pRing->WrOff;
 8004b8c:	f8d9 a024 	ldr.w	sl, [r9, #36]	@ 0x24
  RdOff = pRing->RdOff;
 8004b90:	ea4f 0b46 	mov.w	fp, r6, lsl #1
  NumBytesRead = 0u;
  //
  // Read from current read position to wrap-around of buffer, first
  //
  if (RdOff > WrOff) {
 8004b94:	4557      	cmp	r7, sl
 8004b96:	d81d      	bhi.n	8004bd4 <SEGGER_RTT_ReadUpBufferNoLock+0xe4>
    }
  }
  //
  // Read remaining items of buffer
  //
  NumBytesRem = WrOff - RdOff;
 8004b98:	ebaa 0507 	sub.w	r5, sl, r7
  NumBytesRem = MIN(NumBytesRem, BufferSize);
 8004b9c:	4545      	cmp	r5, r8
 8004b9e:	bf28      	it	cs
 8004ba0:	4645      	movcs	r5, r8
  if (NumBytesRem > 0u) {
 8004ba2:	b91d      	cbnz	r5, 8004bac <SEGGER_RTT_ReadUpBufferNoLock+0xbc>
  if (NumBytesRead) {
    pRing->RdOff = RdOff;
  }
  //
  return NumBytesRead;
}
 8004ba4:	4628      	mov	r0, r5
 8004ba6:	b003      	add	sp, #12
 8004ba8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    pSrc = (pRing->pBuffer + RdOff) + SEGGER_RTT_UNCACHED_OFF;
 8004bac:	1c73      	adds	r3, r6, #1
 8004bae:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8004bb2:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
 8004bb6:	6859      	ldr	r1, [r3, #4]
    SEGGER_RTT_MEMCPY(pBuffer, (void*)pSrc, NumBytesRem);
 8004bb8:	462a      	mov	r2, r5
 8004bba:	4439      	add	r1, r7
 8004bbc:	9800      	ldr	r0, [sp, #0]
 8004bbe:	f002 f8c1 	bl	8006d44 <memcpy>
    RdOff        += NumBytesRem;
 8004bc2:	442f      	add	r7, r5
}
 8004bc4:	4628      	mov	r0, r5
    pRing->RdOff = RdOff;
 8004bc6:	44b3      	add	fp, r6
 8004bc8:	eb04 04cb 	add.w	r4, r4, fp, lsl #3
 8004bcc:	62a7      	str	r7, [r4, #40]	@ 0x28
}
 8004bce:	b003      	add	sp, #12
 8004bd0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    NumBytesRem = pRing->SizeOfBuffer - RdOff;
 8004bd4:	f8d9 5020 	ldr.w	r5, [r9, #32]
    pSrc = (pRing->pBuffer + RdOff) + SEGGER_RTT_UNCACHED_OFF;
 8004bd8:	1c73      	adds	r3, r6, #1
    NumBytesRem = pRing->SizeOfBuffer - RdOff;
 8004bda:	1bed      	subs	r5, r5, r7
    NumBytesRem = MIN(NumBytesRem, BufferSize);
 8004bdc:	4545      	cmp	r5, r8
 8004bde:	bf28      	it	cs
 8004be0:	4645      	movcs	r5, r8
    pSrc = (pRing->pBuffer + RdOff) + SEGGER_RTT_UNCACHED_OFF;
 8004be2:	eb03 0243 	add.w	r2, r3, r3, lsl #1
 8004be6:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
 8004bea:	6851      	ldr	r1, [r2, #4]
    SEGGER_RTT_MEMCPY(pBuffer, (void*)pSrc, NumBytesRem);
 8004bec:	9800      	ldr	r0, [sp, #0]
 8004bee:	462a      	mov	r2, r5
 8004bf0:	4439      	add	r1, r7
    pSrc = (pRing->pBuffer + RdOff) + SEGGER_RTT_UNCACHED_OFF;
 8004bf2:	9301      	str	r3, [sp, #4]
    SEGGER_RTT_MEMCPY(pBuffer, (void*)pSrc, NumBytesRem);
 8004bf4:	f002 f8a6 	bl	8006d44 <memcpy>
    if (RdOff == pRing->SizeOfBuffer) {
 8004bf8:	f8d9 2020 	ldr.w	r2, [r9, #32]
    RdOff        += NumBytesRem;
 8004bfc:	442f      	add	r7, r5
    if (RdOff == pRing->SizeOfBuffer) {
 8004bfe:	42ba      	cmp	r2, r7
    BufferSize   -= NumBytesRem;
 8004c00:	eba8 0805 	sub.w	r8, r8, r5
  NumBytesRem = WrOff - RdOff;
 8004c04:	bf14      	ite	ne
 8004c06:	ebaa 0a07 	subne.w	sl, sl, r7
      RdOff = 0u;
 8004c0a:	2700      	moveq	r7, #0
  NumBytesRem = MIN(NumBytesRem, BufferSize);
 8004c0c:	45d0      	cmp	r8, sl
 8004c0e:	bf28      	it	cs
 8004c10:	46d0      	movcs	r8, sl
    if (RdOff == pRing->SizeOfBuffer) {
 8004c12:	9b01      	ldr	r3, [sp, #4]
  if (NumBytesRem > 0u) {
 8004c14:	f1b8 0f00 	cmp.w	r8, #0
 8004c18:	d105      	bne.n	8004c26 <SEGGER_RTT_ReadUpBufferNoLock+0x136>
  if (NumBytesRead) {
 8004c1a:	2d00      	cmp	r5, #0
 8004c1c:	d1d2      	bne.n	8004bc4 <SEGGER_RTT_ReadUpBufferNoLock+0xd4>
}
 8004c1e:	4628      	mov	r0, r5
 8004c20:	b003      	add	sp, #12
 8004c22:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    pSrc = (pRing->pBuffer + RdOff) + SEGGER_RTT_UNCACHED_OFF;
 8004c26:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8004c2a:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
 8004c2e:	6859      	ldr	r1, [r3, #4]
    pBuffer      += NumBytesRem;
 8004c30:	9800      	ldr	r0, [sp, #0]
    SEGGER_RTT_MEMCPY(pBuffer, (void*)pSrc, NumBytesRem);
 8004c32:	4439      	add	r1, r7
    pBuffer      += NumBytesRem;
 8004c34:	4428      	add	r0, r5
    SEGGER_RTT_MEMCPY(pBuffer, (void*)pSrc, NumBytesRem);
 8004c36:	4642      	mov	r2, r8
    NumBytesRead += NumBytesRem;
 8004c38:	4445      	add	r5, r8
    SEGGER_RTT_MEMCPY(pBuffer, (void*)pSrc, NumBytesRem);
 8004c3a:	f002 f883 	bl	8006d44 <memcpy>
    RdOff        += NumBytesRem;
 8004c3e:	4447      	add	r7, r8
  if (NumBytesRead) {
 8004c40:	2d00      	cmp	r5, #0
 8004c42:	d0ec      	beq.n	8004c1e <SEGGER_RTT_ReadUpBufferNoLock+0x12e>
 8004c44:	e7be      	b.n	8004bc4 <SEGGER_RTT_ReadUpBufferNoLock+0xd4>
 8004c46:	bf00      	nop
 8004c48:	2000188c 	.word	0x2000188c
 8004c4c:	08006f00 	.word	0x08006f00
 8004c50:	20001888 	.word	0x20001888
 8004c54:	20001878 	.word	0x20001878

08004c58 <SEGGER_RTT_ReadNoLock>:
*    BufferSize   Size of the target application buffer.
*
*  Return value
*    Number of bytes that have been read.
*/
unsigned SEGGER_RTT_ReadNoLock(unsigned BufferIndex, void* pData, unsigned BufferSize) {
 8004c58:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  unsigned                WrOff;
  unsigned char*          pBuffer;
  SEGGER_RTT_BUFFER_DOWN* pRing;
  volatile char*          pSrc;
  //
  INIT();
 8004c5c:	4c57      	ldr	r4, [pc, #348]	@ (8004dbc <SEGGER_RTT_ReadNoLock+0x164>)
unsigned SEGGER_RTT_ReadNoLock(unsigned BufferIndex, void* pData, unsigned BufferSize) {
 8004c5e:	4605      	mov	r5, r0
  INIT();
 8004c60:	7823      	ldrb	r3, [r4, #0]
unsigned SEGGER_RTT_ReadNoLock(unsigned BufferIndex, void* pData, unsigned BufferSize) {
 8004c62:	460f      	mov	r7, r1
  INIT();
 8004c64:	2b53      	cmp	r3, #83	@ 0x53
unsigned SEGGER_RTT_ReadNoLock(unsigned BufferIndex, void* pData, unsigned BufferSize) {
 8004c66:	4616      	mov	r6, r2
 8004c68:	b083      	sub	sp, #12
  INIT();
 8004c6a:	d045      	beq.n	8004cf8 <SEGGER_RTT_ReadNoLock+0xa0>
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
 8004c6c:	f04f 0803 	mov.w	r8, #3
  memset((SEGGER_RTT_CB*)p, 0, sizeof(_SEGGER_RTT));         // Make sure that the RTT CB is always zero initialized.
 8004c70:	2278      	movs	r2, #120	@ 0x78
 8004c72:	2100      	movs	r1, #0
 8004c74:	f104 0030 	add.w	r0, r4, #48	@ 0x30
 8004c78:	f001 ffd8 	bl	8006c2c <memset>
  p->aUp[0].SizeOfBuffer  = BUFFER_SIZE_UP;
 8004c7c:	f04f 0a02 	mov.w	sl, #2
  p->aUp[0].RdOff         = 0u;
 8004c80:	2300      	movs	r3, #0
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
 8004c82:	f8c4 8010 	str.w	r8, [r4, #16]
  p->aUp[0].sName         = "Terminal";
 8004c86:	f8df e138 	ldr.w	lr, [pc, #312]	@ 8004dc0 <SEGGER_RTT_ReadNoLock+0x168>
  p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
 8004c8a:	f8c4 8014 	str.w	r8, [r4, #20]
  p->aUp[0].pBuffer       = _acUpBuffer;
 8004c8e:	f8df 8134 	ldr.w	r8, [pc, #308]	@ 8004dc4 <SEGGER_RTT_ReadNoLock+0x16c>
  p->aUp[0].sName         = "Terminal";
 8004c92:	f8c4 e018 	str.w	lr, [r4, #24]
  p->aUp[0].pBuffer       = _acUpBuffer;
 8004c96:	f8c4 801c 	str.w	r8, [r4, #28]
  p->aUp[0].SizeOfBuffer  = BUFFER_SIZE_UP;
 8004c9a:	f8c4 a020 	str.w	sl, [r4, #32]
  p->aUp[0].RdOff         = 0u;
 8004c9e:	62a3      	str	r3, [r4, #40]	@ 0x28
  p->aUp[0].WrOff         = 0u;
 8004ca0:	6263      	str	r3, [r4, #36]	@ 0x24
  p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
 8004ca2:	62e3      	str	r3, [r4, #44]	@ 0x2c
  p->aDown[0].sName         = "Terminal";
 8004ca4:	f8c4 e060 	str.w	lr, [r4, #96]	@ 0x60
  p->aDown[0].pBuffer       = _acDownBuffer;
 8004ca8:	f8df e11c 	ldr.w	lr, [pc, #284]	@ 8004dc8 <SEGGER_RTT_ReadNoLock+0x170>
    p->acID[i] = _aInitStr[sizeof(_aInitStr) - 2 - i];  // Skip terminating \0 at the end of the array
 8004cac:	2045      	movs	r0, #69	@ 0x45
  p->aDown[0].pBuffer       = _acDownBuffer;
 8004cae:	f8c4 e064 	str.w	lr, [r4, #100]	@ 0x64
    p->acID[i] = _aInitStr[sizeof(_aInitStr) - 2 - i];  // Skip terminating \0 at the end of the array
 8004cb2:	f04f 0c47 	mov.w	ip, #71	@ 0x47
 8004cb6:	2152      	movs	r1, #82	@ 0x52
 8004cb8:	2254      	movs	r2, #84	@ 0x54
 8004cba:	f04f 0b53 	mov.w	fp, #83	@ 0x53
 8004cbe:	f04f 0920 	mov.w	r9, #32
  p->aDown[0].SizeOfBuffer  = BUFFER_SIZE_DOWN;
 8004cc2:	f04f 0e10 	mov.w	lr, #16
 8004cc6:	f8c4 e068 	str.w	lr, [r4, #104]	@ 0x68
  p->aDown[0].RdOff         = 0u;
 8004cca:	6723      	str	r3, [r4, #112]	@ 0x70
  p->aDown[0].WrOff         = 0u;
 8004ccc:	66e3      	str	r3, [r4, #108]	@ 0x6c
  p->aDown[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
 8004cce:	6763      	str	r3, [r4, #116]	@ 0x74
    p->acID[i] = _aInitStr[sizeof(_aInitStr) - 2 - i];  // Skip terminating \0 at the end of the array
 8004cd0:	f884 b000 	strb.w	fp, [r4]
 8004cd4:	7060      	strb	r0, [r4, #1]
 8004cd6:	f884 c002 	strb.w	ip, [r4, #2]
 8004cda:	f884 c003 	strb.w	ip, [r4, #3]
 8004cde:	7120      	strb	r0, [r4, #4]
 8004ce0:	7161      	strb	r1, [r4, #5]
 8004ce2:	f884 9006 	strb.w	r9, [r4, #6]
 8004ce6:	71e1      	strb	r1, [r4, #7]
 8004ce8:	7222      	strb	r2, [r4, #8]
 8004cea:	7262      	strb	r2, [r4, #9]
 8004cec:	72a3      	strb	r3, [r4, #10]
 8004cee:	72e3      	strb	r3, [r4, #11]
 8004cf0:	7323      	strb	r3, [r4, #12]
 8004cf2:	7363      	strb	r3, [r4, #13]
 8004cf4:	73a3      	strb	r3, [r4, #14]
 8004cf6:	73e3      	strb	r3, [r4, #15]
  pRing = (SEGGER_RTT_BUFFER_DOWN*)((uintptr_t)&_SEGGER_RTT.aDown[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
  pBuffer = (unsigned char*)pData;
  RdOff = pRing->RdOff;
 8004cf8:	eb05 0845 	add.w	r8, r5, r5, lsl #1
 8004cfc:	eb04 08c8 	add.w	r8, r4, r8, lsl #3
  WrOff = pRing->WrOff;
 8004d00:	f8d8 b06c 	ldr.w	fp, [r8, #108]	@ 0x6c
  RdOff = pRing->RdOff;
 8004d04:	f8d8 9070 	ldr.w	r9, [r8, #112]	@ 0x70
 8004d08:	006b      	lsls	r3, r5, #1
  NumBytesRead = 0u;
  //
  // Read from current read position to wrap-around of buffer, first
  //
  if (RdOff > WrOff) {
 8004d0a:	45d9      	cmp	r9, fp
 8004d0c:	d81d      	bhi.n	8004d4a <SEGGER_RTT_ReadNoLock+0xf2>
    }
  }
  //
  // Read remaining items of buffer
  //
  NumBytesRem = WrOff - RdOff;
 8004d0e:	ebab 0b09 	sub.w	fp, fp, r9
  NumBytesRem = MIN(NumBytesRem, BufferSize);
 8004d12:	455e      	cmp	r6, fp
 8004d14:	bf28      	it	cs
 8004d16:	465e      	movcs	r6, fp
 8004d18:	46b2      	mov	sl, r6
  if (NumBytesRem > 0u) {
 8004d1a:	b91e      	cbnz	r6, 8004d24 <SEGGER_RTT_ReadNoLock+0xcc>
  if (NumBytesRead) {
    pRing->RdOff = RdOff;
  }
  //
  return NumBytesRead;
}
 8004d1c:	4650      	mov	r0, sl
 8004d1e:	b003      	add	sp, #12
 8004d20:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    pSrc = (pRing->pBuffer + RdOff) + SEGGER_RTT_UNCACHED_OFF;
 8004d24:	f8d8 1064 	ldr.w	r1, [r8, #100]	@ 0x64
    SEGGER_RTT_MEMCPY(pBuffer, (void*)pSrc, NumBytesRem);
 8004d28:	4638      	mov	r0, r7
 8004d2a:	4449      	add	r1, r9
 8004d2c:	4632      	mov	r2, r6
 8004d2e:	9301      	str	r3, [sp, #4]
 8004d30:	f002 f808 	bl	8006d44 <memcpy>
    RdOff        += NumBytesRem;
 8004d34:	9b01      	ldr	r3, [sp, #4]
 8004d36:	44b1      	add	r9, r6
}
 8004d38:	4650      	mov	r0, sl
    pRing->RdOff = RdOff;
 8004d3a:	442b      	add	r3, r5
 8004d3c:	eb04 04c3 	add.w	r4, r4, r3, lsl #3
 8004d40:	f8c4 9070 	str.w	r9, [r4, #112]	@ 0x70
}
 8004d44:	b003      	add	sp, #12
 8004d46:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    NumBytesRem = pRing->SizeOfBuffer - RdOff;
 8004d4a:	f8d8 2068 	ldr.w	r2, [r8, #104]	@ 0x68
    pSrc = (pRing->pBuffer + RdOff) + SEGGER_RTT_UNCACHED_OFF;
 8004d4e:	f8d8 1064 	ldr.w	r1, [r8, #100]	@ 0x64
    NumBytesRem = pRing->SizeOfBuffer - RdOff;
 8004d52:	eba2 0a09 	sub.w	sl, r2, r9
    NumBytesRem = MIN(NumBytesRem, BufferSize);
 8004d56:	45b2      	cmp	sl, r6
 8004d58:	bf28      	it	cs
 8004d5a:	46b2      	movcs	sl, r6
    SEGGER_RTT_MEMCPY(pBuffer, (void*)pSrc, NumBytesRem);
 8004d5c:	4449      	add	r1, r9
 8004d5e:	4652      	mov	r2, sl
 8004d60:	4638      	mov	r0, r7
 8004d62:	9301      	str	r3, [sp, #4]
 8004d64:	f001 ffee 	bl	8006d44 <memcpy>
    if (RdOff == pRing->SizeOfBuffer) {
 8004d68:	f8d8 2068 	ldr.w	r2, [r8, #104]	@ 0x68
    RdOff        += NumBytesRem;
 8004d6c:	44d1      	add	r9, sl
    if (RdOff == pRing->SizeOfBuffer) {
 8004d6e:	454a      	cmp	r2, r9
    BufferSize   -= NumBytesRem;
 8004d70:	eba6 060a 	sub.w	r6, r6, sl
  NumBytesRem = WrOff - RdOff;
 8004d74:	bf14      	ite	ne
 8004d76:	ebab 0b09 	subne.w	fp, fp, r9
      RdOff = 0u;
 8004d7a:	f04f 0900 	moveq.w	r9, #0
  NumBytesRem = MIN(NumBytesRem, BufferSize);
 8004d7e:	455e      	cmp	r6, fp
 8004d80:	bf28      	it	cs
 8004d82:	465e      	movcs	r6, fp
    if (RdOff == pRing->SizeOfBuffer) {
 8004d84:	9b01      	ldr	r3, [sp, #4]
  if (NumBytesRem > 0u) {
 8004d86:	b936      	cbnz	r6, 8004d96 <SEGGER_RTT_ReadNoLock+0x13e>
  if (NumBytesRead) {
 8004d88:	f1ba 0f00 	cmp.w	sl, #0
 8004d8c:	d1d4      	bne.n	8004d38 <SEGGER_RTT_ReadNoLock+0xe0>
}
 8004d8e:	4650      	mov	r0, sl
 8004d90:	b003      	add	sp, #12
 8004d92:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    pSrc = (pRing->pBuffer + RdOff) + SEGGER_RTT_UNCACHED_OFF;
 8004d96:	195a      	adds	r2, r3, r5
 8004d98:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
 8004d9c:	6e51      	ldr	r1, [r2, #100]	@ 0x64
    pBuffer      += NumBytesRem;
 8004d9e:	eb07 000a 	add.w	r0, r7, sl
    SEGGER_RTT_MEMCPY(pBuffer, (void*)pSrc, NumBytesRem);
 8004da2:	4449      	add	r1, r9
 8004da4:	4632      	mov	r2, r6
    NumBytesRead += NumBytesRem;
 8004da6:	44b2      	add	sl, r6
    pSrc = (pRing->pBuffer + RdOff) + SEGGER_RTT_UNCACHED_OFF;
 8004da8:	9301      	str	r3, [sp, #4]
    RdOff        += NumBytesRem;
 8004daa:	44b1      	add	r9, r6
    SEGGER_RTT_MEMCPY(pBuffer, (void*)pSrc, NumBytesRem);
 8004dac:	f001 ffca 	bl	8006d44 <memcpy>
    RdOff        += NumBytesRem;
 8004db0:	9b01      	ldr	r3, [sp, #4]
  if (NumBytesRead) {
 8004db2:	f1ba 0f00 	cmp.w	sl, #0
 8004db6:	d0ea      	beq.n	8004d8e <SEGGER_RTT_ReadNoLock+0x136>
 8004db8:	e7be      	b.n	8004d38 <SEGGER_RTT_ReadNoLock+0xe0>
 8004dba:	bf00      	nop
 8004dbc:	2000188c 	.word	0x2000188c
 8004dc0:	08006f00 	.word	0x08006f00
 8004dc4:	20001888 	.word	0x20001888
 8004dc8:	20001878 	.word	0x20001878

08004dcc <SEGGER_RTT_WriteDownBuffer>:
*    This function locks against all other RTT operations. I.e. during
*    the write operation, writing from the application is also locked.
*    If only one consumer writes to the down buffer,
*    call SEGGER_RTT_WriteDownBufferNoLock() instead.
*/
unsigned SEGGER_RTT_WriteDownBuffer(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
 8004dcc:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  unsigned Status;

  INIT();
 8004dd0:	4c78      	ldr	r4, [pc, #480]	@ (8004fb4 <SEGGER_RTT_WriteDownBuffer+0x1e8>)
unsigned SEGGER_RTT_WriteDownBuffer(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
 8004dd2:	4607      	mov	r7, r0
  INIT();
 8004dd4:	7823      	ldrb	r3, [r4, #0]
unsigned SEGGER_RTT_WriteDownBuffer(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
 8004dd6:	460e      	mov	r6, r1
  INIT();
 8004dd8:	2b53      	cmp	r3, #83	@ 0x53
unsigned SEGGER_RTT_WriteDownBuffer(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
 8004dda:	4615      	mov	r5, r2
  INIT();
 8004ddc:	d045      	beq.n	8004e6a <SEGGER_RTT_WriteDownBuffer+0x9e>
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
 8004dde:	f04f 0803 	mov.w	r8, #3
  memset((SEGGER_RTT_CB*)p, 0, sizeof(_SEGGER_RTT));         // Make sure that the RTT CB is always zero initialized.
 8004de2:	2278      	movs	r2, #120	@ 0x78
 8004de4:	2100      	movs	r1, #0
 8004de6:	f104 0030 	add.w	r0, r4, #48	@ 0x30
 8004dea:	f001 ff1f 	bl	8006c2c <memset>
  p->aUp[0].SizeOfBuffer  = BUFFER_SIZE_UP;
 8004dee:	f04f 0a02 	mov.w	sl, #2
  p->aUp[0].RdOff         = 0u;
 8004df2:	2300      	movs	r3, #0
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
 8004df4:	f8c4 8010 	str.w	r8, [r4, #16]
  p->aUp[0].sName         = "Terminal";
 8004df8:	f8df e1bc 	ldr.w	lr, [pc, #444]	@ 8004fb8 <SEGGER_RTT_WriteDownBuffer+0x1ec>
  p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
 8004dfc:	f8c4 8014 	str.w	r8, [r4, #20]
  p->aUp[0].pBuffer       = _acUpBuffer;
 8004e00:	f8df 81b8 	ldr.w	r8, [pc, #440]	@ 8004fbc <SEGGER_RTT_WriteDownBuffer+0x1f0>
  p->aUp[0].sName         = "Terminal";
 8004e04:	f8c4 e018 	str.w	lr, [r4, #24]
  p->aUp[0].pBuffer       = _acUpBuffer;
 8004e08:	f8c4 801c 	str.w	r8, [r4, #28]
  p->aUp[0].SizeOfBuffer  = BUFFER_SIZE_UP;
 8004e0c:	f8c4 a020 	str.w	sl, [r4, #32]
  p->aUp[0].RdOff         = 0u;
 8004e10:	62a3      	str	r3, [r4, #40]	@ 0x28
  p->aUp[0].WrOff         = 0u;
 8004e12:	6263      	str	r3, [r4, #36]	@ 0x24
  p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
 8004e14:	62e3      	str	r3, [r4, #44]	@ 0x2c
  p->aDown[0].sName         = "Terminal";
 8004e16:	f8c4 e060 	str.w	lr, [r4, #96]	@ 0x60
  p->aDown[0].pBuffer       = _acDownBuffer;
 8004e1a:	f8df e1a4 	ldr.w	lr, [pc, #420]	@ 8004fc0 <SEGGER_RTT_WriteDownBuffer+0x1f4>
    p->acID[i] = _aInitStr[sizeof(_aInitStr) - 2 - i];  // Skip terminating \0 at the end of the array
 8004e1e:	2045      	movs	r0, #69	@ 0x45
  p->aDown[0].pBuffer       = _acDownBuffer;
 8004e20:	f8c4 e064 	str.w	lr, [r4, #100]	@ 0x64
    p->acID[i] = _aInitStr[sizeof(_aInitStr) - 2 - i];  // Skip terminating \0 at the end of the array
 8004e24:	f04f 0c47 	mov.w	ip, #71	@ 0x47
 8004e28:	2152      	movs	r1, #82	@ 0x52
 8004e2a:	2254      	movs	r2, #84	@ 0x54
 8004e2c:	f04f 0b53 	mov.w	fp, #83	@ 0x53
 8004e30:	f04f 0920 	mov.w	r9, #32
  p->aDown[0].SizeOfBuffer  = BUFFER_SIZE_DOWN;
 8004e34:	f04f 0e10 	mov.w	lr, #16
 8004e38:	f8c4 e068 	str.w	lr, [r4, #104]	@ 0x68
  p->aDown[0].RdOff         = 0u;
 8004e3c:	6723      	str	r3, [r4, #112]	@ 0x70
  p->aDown[0].WrOff         = 0u;
 8004e3e:	66e3      	str	r3, [r4, #108]	@ 0x6c
  p->aDown[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
 8004e40:	6763      	str	r3, [r4, #116]	@ 0x74
    p->acID[i] = _aInitStr[sizeof(_aInitStr) - 2 - i];  // Skip terminating \0 at the end of the array
 8004e42:	f884 b000 	strb.w	fp, [r4]
 8004e46:	7060      	strb	r0, [r4, #1]
 8004e48:	f884 c002 	strb.w	ip, [r4, #2]
 8004e4c:	f884 c003 	strb.w	ip, [r4, #3]
 8004e50:	7120      	strb	r0, [r4, #4]
 8004e52:	7161      	strb	r1, [r4, #5]
 8004e54:	f884 9006 	strb.w	r9, [r4, #6]
 8004e58:	71e1      	strb	r1, [r4, #7]
 8004e5a:	7222      	strb	r2, [r4, #8]
 8004e5c:	7262      	strb	r2, [r4, #9]
 8004e5e:	72a3      	strb	r3, [r4, #10]
 8004e60:	72e3      	strb	r3, [r4, #11]
 8004e62:	7323      	strb	r3, [r4, #12]
 8004e64:	7363      	strb	r3, [r4, #13]
 8004e66:	73a3      	strb	r3, [r4, #14]
 8004e68:	73e3      	strb	r3, [r4, #15]
  SEGGER_RTT_LOCK();
 8004e6a:	f3ef 8811 	mrs	r8, BASEPRI
 8004e6e:	f04f 0120 	mov.w	r1, #32
 8004e72:	f381 8811 	msr	BASEPRI, r1
  pRing = (SEGGER_RTT_BUFFER_UP*)((uintptr_t)&_SEGGER_RTT.aDown[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
 8004e76:	eb07 0747 	add.w	r7, r7, r7, lsl #1
 8004e7a:	eb04 04c7 	add.w	r4, r4, r7, lsl #3
  switch (pRing->Flags) {
 8004e7e:	f8d4 b074 	ldr.w	fp, [r4, #116]	@ 0x74
  pRing = (SEGGER_RTT_BUFFER_UP*)((uintptr_t)&_SEGGER_RTT.aDown[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
 8004e82:	3460      	adds	r4, #96	@ 0x60
  switch (pRing->Flags) {
 8004e84:	f1bb 0f01 	cmp.w	fp, #1
 8004e88:	d061      	beq.n	8004f4e <SEGGER_RTT_WriteDownBuffer+0x182>
 8004e8a:	f1bb 0f02 	cmp.w	fp, #2
 8004e8e:	d02a      	beq.n	8004ee6 <SEGGER_RTT_WriteDownBuffer+0x11a>
 8004e90:	f1bb 0f00 	cmp.w	fp, #0
 8004e94:	d006      	beq.n	8004ea4 <SEGGER_RTT_WriteDownBuffer+0xd8>
    Status = 0u;
 8004e96:	f04f 0b00 	mov.w	fp, #0
  Status = SEGGER_RTT_WriteDownBufferNoLock(BufferIndex, pBuffer, NumBytes);  // Call the non-locking write function
  SEGGER_RTT_UNLOCK();
 8004e9a:	f388 8811 	msr	BASEPRI, r8
  return Status;
}
 8004e9e:	4658      	mov	r0, fp
 8004ea0:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  RdOff = pRing->RdOff;
 8004ea4:	6923      	ldr	r3, [r4, #16]
  WrOff = pRing->WrOff;
 8004ea6:	68e7      	ldr	r7, [r4, #12]
  if (RdOff <= WrOff) {
 8004ea8:	42bb      	cmp	r3, r7
    r = pRing->SizeOfBuffer - 1u - WrOff + RdOff;
 8004eaa:	bf9c      	itt	ls
 8004eac:	68a2      	ldrls	r2, [r4, #8]
 8004eae:	189b      	addls	r3, r3, r2
    r = RdOff - WrOff - 1u;
 8004eb0:	3b01      	subs	r3, #1
 8004eb2:	1bdb      	subs	r3, r3, r7
    if (Avail < NumBytes) {
 8004eb4:	429d      	cmp	r5, r3
 8004eb6:	d8f0      	bhi.n	8004e9a <SEGGER_RTT_WriteDownBuffer+0xce>
    pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
 8004eb8:	e9d4 0901 	ldrd	r0, r9, [r4, #4]
  Rem = pRing->SizeOfBuffer - WrOff;
 8004ebc:	eba9 0a07 	sub.w	sl, r9, r7
  if (Rem > NumBytes) {
 8004ec0:	4555      	cmp	r5, sl
    pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
 8004ec2:	4438      	add	r0, r7
    pRing->WrOff = WrOff + NumBytes;
 8004ec4:	442f      	add	r7, r5
  if (Rem > NumBytes) {
 8004ec6:	d370      	bcc.n	8004faa <SEGGER_RTT_WriteDownBuffer+0x1de>
    SEGGER_RTT_MEMCPY((void*)pDst, pData, NumBytesAtOnce);
 8004ec8:	4652      	mov	r2, sl
 8004eca:	4631      	mov	r1, r6
    NumBytesAtOnce = NumBytes - Rem;
 8004ecc:	eba7 0709 	sub.w	r7, r7, r9
    SEGGER_RTT_MEMCPY((void*)pDst, pData, NumBytesAtOnce);
 8004ed0:	f001 ff38 	bl	8006d44 <memcpy>
    SEGGER_RTT_MEMCPY((void*)pDst, pData + Rem, NumBytesAtOnce);
 8004ed4:	463a      	mov	r2, r7
 8004ed6:	6860      	ldr	r0, [r4, #4]
 8004ed8:	eb06 010a 	add.w	r1, r6, sl
 8004edc:	f001 ff32 	bl	8006d44 <memcpy>
      Status = NumBytes;
 8004ee0:	46ab      	mov	fp, r5
    pRing->WrOff = NumBytesAtOnce;
 8004ee2:	60e7      	str	r7, [r4, #12]
 8004ee4:	e7d9      	b.n	8004e9a <SEGGER_RTT_WriteDownBuffer+0xce>
  NumBytesWritten = 0u;
 8004ee6:	f04f 0b00 	mov.w	fp, #0
    pRing->WrOff = WrOff;
 8004eea:	46da      	mov	sl, fp
  WrOff = pRing->WrOff;
 8004eec:	f8d4 900c 	ldr.w	r9, [r4, #12]
    r = pRing->SizeOfBuffer - 1u - WrOff + RdOff;
 8004ef0:	68a3      	ldr	r3, [r4, #8]
    RdOff = pRing->RdOff;                         // May be changed by host (debug probe) in the meantime
 8004ef2:	6922      	ldr	r2, [r4, #16]
    NumBytesToWrite = MIN(NumBytesToWrite, (pRing->SizeOfBuffer - WrOff));      // Number of bytes that can be written until buffer wrap-around
 8004ef4:	eba3 0709 	sub.w	r7, r3, r9
    if (RdOff > WrOff) {
 8004ef8:	454a      	cmp	r2, r9
      NumBytesToWrite = RdOff - WrOff - 1u;
 8004efa:	f102 31ff 	add.w	r1, r2, #4294967295
      NumBytesToWrite = pRing->SizeOfBuffer - (WrOff - RdOff + 1u);
 8004efe:	bf9b      	ittet	ls
 8004f00:	f102 32ff 	addls.w	r2, r2, #4294967295
 8004f04:	18d2      	addls	r2, r2, r3
      NumBytesToWrite = RdOff - WrOff - 1u;
 8004f06:	eba1 0209 	subhi.w	r2, r1, r9
      NumBytesToWrite = pRing->SizeOfBuffer - (WrOff - RdOff + 1u);
 8004f0a:	eba2 0209 	subls.w	r2, r2, r9
    NumBytesToWrite = MIN(NumBytesToWrite, NumBytes);
 8004f0e:	42af      	cmp	r7, r5
 8004f10:	bf28      	it	cs
 8004f12:	462f      	movcs	r7, r5
 8004f14:	4297      	cmp	r7, r2
 8004f16:	bf28      	it	cs
 8004f18:	4617      	movcs	r7, r2
    pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
 8004f1a:	6860      	ldr	r0, [r4, #4]
    SEGGER_RTT_MEMCPY((void*)pDst, pBuffer, NumBytesToWrite);
 8004f1c:	4631      	mov	r1, r6
 8004f1e:	4448      	add	r0, r9
 8004f20:	463a      	mov	r2, r7
 8004f22:	f001 ff0f 	bl	8006d44 <memcpy>
    if (WrOff == pRing->SizeOfBuffer) {
 8004f26:	68a3      	ldr	r3, [r4, #8]
    WrOff           += NumBytesToWrite;
 8004f28:	44b9      	add	r9, r7
    if (WrOff == pRing->SizeOfBuffer) {
 8004f2a:	4599      	cmp	r9, r3
    NumBytes        -= NumBytesToWrite;
 8004f2c:	eba5 0507 	sub.w	r5, r5, r7
    NumBytesWritten += NumBytesToWrite;
 8004f30:	44bb      	add	fp, r7
    pBuffer         += NumBytesToWrite;
 8004f32:	443e      	add	r6, r7
    if (WrOff == pRing->SizeOfBuffer) {
 8004f34:	d004      	beq.n	8004f40 <SEGGER_RTT_WriteDownBuffer+0x174>
    pRing->WrOff = WrOff;
 8004f36:	f8c4 900c 	str.w	r9, [r4, #12]
  } while (NumBytes);
 8004f3a:	2d00      	cmp	r5, #0
 8004f3c:	d1d9      	bne.n	8004ef2 <SEGGER_RTT_WriteDownBuffer+0x126>
 8004f3e:	e7ac      	b.n	8004e9a <SEGGER_RTT_WriteDownBuffer+0xce>
    pRing->WrOff = WrOff;
 8004f40:	f8c4 a00c 	str.w	sl, [r4, #12]
  } while (NumBytes);
 8004f44:	2d00      	cmp	r5, #0
 8004f46:	d0a8      	beq.n	8004e9a <SEGGER_RTT_WriteDownBuffer+0xce>
 8004f48:	f04f 0900 	mov.w	r9, #0
 8004f4c:	e7d1      	b.n	8004ef2 <SEGGER_RTT_WriteDownBuffer+0x126>
  RdOff = pRing->RdOff;
 8004f4e:	6923      	ldr	r3, [r4, #16]
    r = pRing->SizeOfBuffer - 1u - WrOff + RdOff;
 8004f50:	e9d4 9702 	ldrd	r9, r7, [r4, #8]
  if (RdOff <= WrOff) {
 8004f54:	42bb      	cmp	r3, r7
    r = pRing->SizeOfBuffer - 1u - WrOff + RdOff;
 8004f56:	bf9a      	itte	ls
 8004f58:	eb03 0b09 	addls.w	fp, r3, r9
 8004f5c:	f10b 3bff 	addls.w	fp, fp, #4294967295
    r = RdOff - WrOff - 1u;
 8004f60:	f103 3bff 	addhi.w	fp, r3, #4294967295
 8004f64:	ebab 0b07 	sub.w	fp, fp, r7
    Status = Avail < NumBytes ? Avail : NumBytes;
 8004f68:	45ab      	cmp	fp, r5
 8004f6a:	bf28      	it	cs
 8004f6c:	46ab      	movcs	fp, r5
    pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
 8004f6e:	6860      	ldr	r0, [r4, #4]
  Rem = pRing->SizeOfBuffer - WrOff;
 8004f70:	eba9 0507 	sub.w	r5, r9, r7
  if (Rem > NumBytes) {
 8004f74:	45ab      	cmp	fp, r5
    pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
 8004f76:	4438      	add	r0, r7
  if (Rem > NumBytes) {
 8004f78:	d311      	bcc.n	8004f9e <SEGGER_RTT_WriteDownBuffer+0x1d2>
    NumBytesAtOnce = NumBytes - Rem;
 8004f7a:	eba7 0709 	sub.w	r7, r7, r9
    SEGGER_RTT_MEMCPY((void*)pDst, pData, NumBytesAtOnce);
 8004f7e:	462a      	mov	r2, r5
 8004f80:	4631      	mov	r1, r6
    NumBytesAtOnce = NumBytes - Rem;
 8004f82:	445f      	add	r7, fp
    SEGGER_RTT_MEMCPY((void*)pDst, pData, NumBytesAtOnce);
 8004f84:	f001 fede 	bl	8006d44 <memcpy>
    SEGGER_RTT_MEMCPY((void*)pDst, pData + Rem, NumBytesAtOnce);
 8004f88:	463a      	mov	r2, r7
 8004f8a:	6860      	ldr	r0, [r4, #4]
 8004f8c:	1971      	adds	r1, r6, r5
 8004f8e:	f001 fed9 	bl	8006d44 <memcpy>
    pRing->WrOff = NumBytesAtOnce;
 8004f92:	60e7      	str	r7, [r4, #12]
  SEGGER_RTT_UNLOCK();
 8004f94:	f388 8811 	msr	BASEPRI, r8
}
 8004f98:	4658      	mov	r0, fp
 8004f9a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    SEGGER_RTT_MEMCPY((void*)pDst, pData, NumBytes);
 8004f9e:	4631      	mov	r1, r6
 8004fa0:	465a      	mov	r2, fp
 8004fa2:	f001 fecf 	bl	8006d44 <memcpy>
    pRing->WrOff = WrOff + NumBytes;
 8004fa6:	445f      	add	r7, fp
 8004fa8:	e7f3      	b.n	8004f92 <SEGGER_RTT_WriteDownBuffer+0x1c6>
    SEGGER_RTT_MEMCPY((void*)pDst, pData, NumBytes);
 8004faa:	4631      	mov	r1, r6
 8004fac:	462a      	mov	r2, r5
 8004fae:	f001 fec9 	bl	8006d44 <memcpy>
    pRing->WrOff = WrOff + NumBytes;
 8004fb2:	e795      	b.n	8004ee0 <SEGGER_RTT_WriteDownBuffer+0x114>
 8004fb4:	2000188c 	.word	0x2000188c
 8004fb8:	08006f00 	.word	0x08006f00
 8004fbc:	20001888 	.word	0x20001888
 8004fc0:	20001878 	.word	0x20001878

08004fc4 <SEGGER_RTT_AllocUpBuffer>:
*
*  Return value
*    >= 0 - O.K. Buffer Index
*     < 0 - Error
*/
int SEGGER_RTT_AllocUpBuffer(const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
 8004fc4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  int BufferIndex;
  volatile SEGGER_RTT_CB* pRTTCB;

  INIT();
 8004fc8:	4c3f      	ldr	r4, [pc, #252]	@ (80050c8 <SEGGER_RTT_AllocUpBuffer+0x104>)
int SEGGER_RTT_AllocUpBuffer(const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
 8004fca:	4681      	mov	r9, r0
  INIT();
 8004fcc:	7825      	ldrb	r5, [r4, #0]
int SEGGER_RTT_AllocUpBuffer(const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
 8004fce:	4688      	mov	r8, r1
  INIT();
 8004fd0:	2d53      	cmp	r5, #83	@ 0x53
int SEGGER_RTT_AllocUpBuffer(const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
 8004fd2:	4617      	mov	r7, r2
 8004fd4:	461e      	mov	r6, r3
  INIT();
 8004fd6:	d042      	beq.n	800505e <SEGGER_RTT_AllocUpBuffer+0x9a>
  memset((SEGGER_RTT_CB*)p, 0, sizeof(_SEGGER_RTT));         // Make sure that the RTT CB is always zero initialized.
 8004fd8:	2278      	movs	r2, #120	@ 0x78
 8004fda:	2100      	movs	r1, #0
 8004fdc:	f104 0030 	add.w	r0, r4, #48	@ 0x30
 8004fe0:	f001 fe24 	bl	8006c2c <memset>
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
 8004fe4:	f04f 0e03 	mov.w	lr, #3
  p->aUp[0].sName         = "Terminal";
 8004fe8:	f8df c0e0 	ldr.w	ip, [pc, #224]	@ 80050cc <SEGGER_RTT_AllocUpBuffer+0x108>
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
 8004fec:	f8c4 e010 	str.w	lr, [r4, #16]
  p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
 8004ff0:	f8c4 e014 	str.w	lr, [r4, #20]
  p->aUp[0].pBuffer       = _acUpBuffer;
 8004ff4:	f8df e0d8 	ldr.w	lr, [pc, #216]	@ 80050d0 <SEGGER_RTT_AllocUpBuffer+0x10c>
  p->aUp[0].sName         = "Terminal";
 8004ff8:	f8c4 c018 	str.w	ip, [r4, #24]
  p->aUp[0].RdOff         = 0u;
 8004ffc:	2500      	movs	r5, #0
  p->aUp[0].pBuffer       = _acUpBuffer;
 8004ffe:	f8c4 e01c 	str.w	lr, [r4, #28]
  p->aUp[0].SizeOfBuffer  = BUFFER_SIZE_UP;
 8005002:	f04f 0e02 	mov.w	lr, #2
 8005006:	f8c4 e020 	str.w	lr, [r4, #32]
  p->aUp[0].RdOff         = 0u;
 800500a:	62a5      	str	r5, [r4, #40]	@ 0x28
  p->aUp[0].WrOff         = 0u;
 800500c:	6265      	str	r5, [r4, #36]	@ 0x24
  p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
 800500e:	62e5      	str	r5, [r4, #44]	@ 0x2c
  p->aDown[0].sName         = "Terminal";
 8005010:	f8c4 c060 	str.w	ip, [r4, #96]	@ 0x60
  p->aDown[0].pBuffer       = _acDownBuffer;
 8005014:	f8df c0bc 	ldr.w	ip, [pc, #188]	@ 80050d4 <SEGGER_RTT_AllocUpBuffer+0x110>
    p->acID[i] = _aInitStr[sizeof(_aInitStr) - 2 - i];  // Skip terminating \0 at the end of the array
 8005018:	2145      	movs	r1, #69	@ 0x45
  p->aDown[0].pBuffer       = _acDownBuffer;
 800501a:	f8c4 c064 	str.w	ip, [r4, #100]	@ 0x64
    p->acID[i] = _aInitStr[sizeof(_aInitStr) - 2 - i];  // Skip terminating \0 at the end of the array
 800501e:	2047      	movs	r0, #71	@ 0x47
 8005020:	2252      	movs	r2, #82	@ 0x52
 8005022:	2354      	movs	r3, #84	@ 0x54
 8005024:	f04f 0a53 	mov.w	sl, #83	@ 0x53
 8005028:	f04f 0b20 	mov.w	fp, #32
  p->aDown[0].SizeOfBuffer  = BUFFER_SIZE_DOWN;
 800502c:	f04f 0c10 	mov.w	ip, #16
 8005030:	f8c4 c068 	str.w	ip, [r4, #104]	@ 0x68
  p->aDown[0].RdOff         = 0u;
 8005034:	6725      	str	r5, [r4, #112]	@ 0x70
  p->aDown[0].WrOff         = 0u;
 8005036:	66e5      	str	r5, [r4, #108]	@ 0x6c
  p->aDown[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
 8005038:	6765      	str	r5, [r4, #116]	@ 0x74
    p->acID[i] = _aInitStr[sizeof(_aInitStr) - 2 - i];  // Skip terminating \0 at the end of the array
 800503a:	f884 a000 	strb.w	sl, [r4]
 800503e:	7061      	strb	r1, [r4, #1]
 8005040:	70a0      	strb	r0, [r4, #2]
 8005042:	70e0      	strb	r0, [r4, #3]
 8005044:	7121      	strb	r1, [r4, #4]
 8005046:	7162      	strb	r2, [r4, #5]
 8005048:	f884 b006 	strb.w	fp, [r4, #6]
 800504c:	71e2      	strb	r2, [r4, #7]
 800504e:	7223      	strb	r3, [r4, #8]
 8005050:	7263      	strb	r3, [r4, #9]
 8005052:	72a5      	strb	r5, [r4, #10]
 8005054:	72e5      	strb	r5, [r4, #11]
 8005056:	7325      	strb	r5, [r4, #12]
 8005058:	7365      	strb	r5, [r4, #13]
 800505a:	73a5      	strb	r5, [r4, #14]
 800505c:	73e5      	strb	r5, [r4, #15]
  SEGGER_RTT_LOCK();
 800505e:	f3ef 8511 	mrs	r5, BASEPRI
 8005062:	f04f 0120 	mov.w	r1, #32
 8005066:	f381 8811 	msr	BASEPRI, r1
  pRTTCB = (volatile SEGGER_RTT_CB*)((uintptr_t)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access RTTCB uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
  BufferIndex = 0;
  do {
    if (pRTTCB->aUp[BufferIndex].pBuffer == NULL) {
 800506a:	69e0      	ldr	r0, [r4, #28]
 800506c:	b158      	cbz	r0, 8005086 <SEGGER_RTT_AllocUpBuffer+0xc2>
      break;
    }
    BufferIndex++;
  } while (BufferIndex < pRTTCB->MaxNumUpBuffers);
 800506e:	6923      	ldr	r3, [r4, #16]
 8005070:	2b01      	cmp	r3, #1
 8005072:	dd21      	ble.n	80050b8 <SEGGER_RTT_AllocUpBuffer+0xf4>
    if (pRTTCB->aUp[BufferIndex].pBuffer == NULL) {
 8005074:	6b63      	ldr	r3, [r4, #52]	@ 0x34
 8005076:	b1fb      	cbz	r3, 80050b8 <SEGGER_RTT_AllocUpBuffer+0xf4>
  } while (BufferIndex < pRTTCB->MaxNumUpBuffers);
 8005078:	6923      	ldr	r3, [r4, #16]
 800507a:	2b02      	cmp	r3, #2
 800507c:	dd1e      	ble.n	80050bc <SEGGER_RTT_AllocUpBuffer+0xf8>
    if (pRTTCB->aUp[BufferIndex].pBuffer == NULL) {
 800507e:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
 8005080:	b1e3      	cbz	r3, 80050bc <SEGGER_RTT_AllocUpBuffer+0xf8>
    BufferIndex++;
 8005082:	2003      	movs	r0, #3
  } while (BufferIndex < pRTTCB->MaxNumUpBuffers);
 8005084:	6923      	ldr	r3, [r4, #16]
  if (BufferIndex < pRTTCB->MaxNumUpBuffers) {
 8005086:	6923      	ldr	r3, [r4, #16]
 8005088:	4283      	cmp	r3, r0
 800508a:	dd19      	ble.n	80050c0 <SEGGER_RTT_AllocUpBuffer+0xfc>
    pRTTCB->aUp[BufferIndex].sName        = sName;
    pRTTCB->aUp[BufferIndex].pBuffer      = (char*)pBuffer;
    pRTTCB->aUp[BufferIndex].SizeOfBuffer = BufferSize;
    pRTTCB->aUp[BufferIndex].RdOff        = 0u;
 800508c:	2200      	movs	r2, #0
    pRTTCB->aUp[BufferIndex].sName        = sName;
 800508e:	1c43      	adds	r3, r0, #1
 8005090:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8005094:	00db      	lsls	r3, r3, #3
 8005096:	f844 9003 	str.w	r9, [r4, r3]
    pRTTCB->aUp[BufferIndex].pBuffer      = (char*)pBuffer;
 800509a:	4423      	add	r3, r4
 800509c:	f8c3 8004 	str.w	r8, [r3, #4]
    pRTTCB->aUp[BufferIndex].SizeOfBuffer = BufferSize;
 80050a0:	eb00 0340 	add.w	r3, r0, r0, lsl #1
 80050a4:	eb04 04c3 	add.w	r4, r4, r3, lsl #3
 80050a8:	6227      	str	r7, [r4, #32]
    pRTTCB->aUp[BufferIndex].RdOff        = 0u;
 80050aa:	62a2      	str	r2, [r4, #40]	@ 0x28
    pRTTCB->aUp[BufferIndex].WrOff        = 0u;
 80050ac:	6262      	str	r2, [r4, #36]	@ 0x24
    pRTTCB->aUp[BufferIndex].Flags        = Flags;
 80050ae:	62e6      	str	r6, [r4, #44]	@ 0x2c
    RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
  } else {
    BufferIndex = -1;
  }
  SEGGER_RTT_UNLOCK();
 80050b0:	f385 8811 	msr	BASEPRI, r5
  return BufferIndex;
}
 80050b4:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    BufferIndex++;
 80050b8:	2001      	movs	r0, #1
 80050ba:	e7e4      	b.n	8005086 <SEGGER_RTT_AllocUpBuffer+0xc2>
 80050bc:	2002      	movs	r0, #2
 80050be:	e7e2      	b.n	8005086 <SEGGER_RTT_AllocUpBuffer+0xc2>
    BufferIndex = -1;
 80050c0:	f04f 30ff 	mov.w	r0, #4294967295
 80050c4:	e7f4      	b.n	80050b0 <SEGGER_RTT_AllocUpBuffer+0xec>
 80050c6:	bf00      	nop
 80050c8:	2000188c 	.word	0x2000188c
 80050cc:	08006f00 	.word	0x08006f00
 80050d0:	20001888 	.word	0x20001888
 80050d4:	20001878 	.word	0x20001878

080050d8 <SEGGER_RTT_ConfigDownBuffer>:
*  Additional information
*    Buffer 0 is configured on compile-time.
*    May only be called once per buffer.
*    Buffer name and flags can be reconfigured using the appropriate functions.
*/
int SEGGER_RTT_ConfigDownBuffer(unsigned BufferIndex, const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
 80050d8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  int r;
  volatile SEGGER_RTT_CB* pRTTCB;
  volatile SEGGER_RTT_BUFFER_DOWN* pDown;

  INIT();
 80050dc:	4c39      	ldr	r4, [pc, #228]	@ (80051c4 <SEGGER_RTT_ConfigDownBuffer+0xec>)
int SEGGER_RTT_ConfigDownBuffer(unsigned BufferIndex, const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
 80050de:	4605      	mov	r5, r0
  INIT();
 80050e0:	f894 c000 	ldrb.w	ip, [r4]
int SEGGER_RTT_ConfigDownBuffer(unsigned BufferIndex, const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
 80050e4:	4688      	mov	r8, r1
  INIT();
 80050e6:	f1bc 0f53 	cmp.w	ip, #83	@ 0x53
int SEGGER_RTT_ConfigDownBuffer(unsigned BufferIndex, const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
 80050ea:	4617      	mov	r7, r2
 80050ec:	461e      	mov	r6, r3
  INIT();
 80050ee:	d045      	beq.n	800517c <SEGGER_RTT_ConfigDownBuffer+0xa4>
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
 80050f0:	f04f 0903 	mov.w	r9, #3
  memset((SEGGER_RTT_CB*)p, 0, sizeof(_SEGGER_RTT));         // Make sure that the RTT CB is always zero initialized.
 80050f4:	2278      	movs	r2, #120	@ 0x78
 80050f6:	2100      	movs	r1, #0
 80050f8:	f104 0030 	add.w	r0, r4, #48	@ 0x30
 80050fc:	f001 fd96 	bl	8006c2c <memset>
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
 8005100:	f8c4 9010 	str.w	r9, [r4, #16]
  p->aUp[0].sName         = "Terminal";
 8005104:	f8df e0c0 	ldr.w	lr, [pc, #192]	@ 80051c8 <SEGGER_RTT_ConfigDownBuffer+0xf0>
  p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
 8005108:	f8c4 9014 	str.w	r9, [r4, #20]
  p->aUp[0].pBuffer       = _acUpBuffer;
 800510c:	f8df 90bc 	ldr.w	r9, [pc, #188]	@ 80051cc <SEGGER_RTT_ConfigDownBuffer+0xf4>
  p->aUp[0].sName         = "Terminal";
 8005110:	f8c4 e018 	str.w	lr, [r4, #24]
  p->aUp[0].RdOff         = 0u;
 8005114:	2000      	movs	r0, #0
  p->aUp[0].pBuffer       = _acUpBuffer;
 8005116:	f8c4 901c 	str.w	r9, [r4, #28]
  p->aUp[0].SizeOfBuffer  = BUFFER_SIZE_UP;
 800511a:	f04f 0902 	mov.w	r9, #2
 800511e:	f8c4 9020 	str.w	r9, [r4, #32]
  p->aUp[0].RdOff         = 0u;
 8005122:	62a0      	str	r0, [r4, #40]	@ 0x28
  p->aUp[0].WrOff         = 0u;
 8005124:	6260      	str	r0, [r4, #36]	@ 0x24
  p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
 8005126:	62e0      	str	r0, [r4, #44]	@ 0x2c
  p->aDown[0].sName         = "Terminal";
 8005128:	f8c4 e060 	str.w	lr, [r4, #96]	@ 0x60
  p->aDown[0].pBuffer       = _acDownBuffer;
 800512c:	f8df e0a0 	ldr.w	lr, [pc, #160]	@ 80051d0 <SEGGER_RTT_ConfigDownBuffer+0xf8>
    p->acID[i] = _aInitStr[sizeof(_aInitStr) - 2 - i];  // Skip terminating \0 at the end of the array
 8005130:	2145      	movs	r1, #69	@ 0x45
  p->aDown[0].pBuffer       = _acDownBuffer;
 8005132:	f8c4 e064 	str.w	lr, [r4, #100]	@ 0x64
    p->acID[i] = _aInitStr[sizeof(_aInitStr) - 2 - i];  // Skip terminating \0 at the end of the array
 8005136:	f04f 0c47 	mov.w	ip, #71	@ 0x47
 800513a:	2252      	movs	r2, #82	@ 0x52
 800513c:	2354      	movs	r3, #84	@ 0x54
 800513e:	f04f 0a53 	mov.w	sl, #83	@ 0x53
 8005142:	f04f 0b20 	mov.w	fp, #32
  p->aDown[0].SizeOfBuffer  = BUFFER_SIZE_DOWN;
 8005146:	f04f 0e10 	mov.w	lr, #16
 800514a:	f8c4 e068 	str.w	lr, [r4, #104]	@ 0x68
  p->aDown[0].RdOff         = 0u;
 800514e:	6720      	str	r0, [r4, #112]	@ 0x70
  p->aDown[0].WrOff         = 0u;
 8005150:	66e0      	str	r0, [r4, #108]	@ 0x6c
  p->aDown[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
 8005152:	6760      	str	r0, [r4, #116]	@ 0x74
    p->acID[i] = _aInitStr[sizeof(_aInitStr) - 2 - i];  // Skip terminating \0 at the end of the array
 8005154:	f884 a000 	strb.w	sl, [r4]
 8005158:	7061      	strb	r1, [r4, #1]
 800515a:	f884 c002 	strb.w	ip, [r4, #2]
 800515e:	f884 c003 	strb.w	ip, [r4, #3]
 8005162:	7121      	strb	r1, [r4, #4]
 8005164:	7162      	strb	r2, [r4, #5]
 8005166:	f884 b006 	strb.w	fp, [r4, #6]
 800516a:	71e2      	strb	r2, [r4, #7]
 800516c:	7223      	strb	r3, [r4, #8]
 800516e:	7263      	strb	r3, [r4, #9]
 8005170:	72a0      	strb	r0, [r4, #10]
 8005172:	72e0      	strb	r0, [r4, #11]
 8005174:	7320      	strb	r0, [r4, #12]
 8005176:	7360      	strb	r0, [r4, #13]
 8005178:	73a0      	strb	r0, [r4, #14]
 800517a:	73e0      	strb	r0, [r4, #15]
  pRTTCB = (volatile SEGGER_RTT_CB*)((uintptr_t)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access RTTCB uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
  if (BufferIndex < SEGGER_RTT_MAX_NUM_DOWN_BUFFERS) {
 800517c:	2d02      	cmp	r5, #2
 800517e:	d81e      	bhi.n	80051be <SEGGER_RTT_ConfigDownBuffer+0xe6>
    SEGGER_RTT_LOCK();
 8005180:	f3ef 8011 	mrs	r0, BASEPRI
 8005184:	f04f 0120 	mov.w	r1, #32
 8005188:	f381 8811 	msr	BASEPRI, r1
    pDown = &pRTTCB->aDown[BufferIndex];
    if (BufferIndex) {
 800518c:	b955      	cbnz	r5, 80051a4 <SEGGER_RTT_ConfigDownBuffer+0xcc>
 800518e:	462b      	mov	r3, r5
      pDown->pBuffer      = (char*)pBuffer;
      pDown->SizeOfBuffer = BufferSize;
      pDown->RdOff        = 0u;
      pDown->WrOff        = 0u;
    }
    pDown->Flags          = Flags;
 8005190:	442b      	add	r3, r5
 8005192:	eb04 04c3 	add.w	r4, r4, r3, lsl #3
 8005196:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8005198:	6763      	str	r3, [r4, #116]	@ 0x74
    RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
    SEGGER_RTT_UNLOCK();
 800519a:	f380 8811 	msr	BASEPRI, r0
    r =  0;
 800519e:	2000      	movs	r0, #0
  } else {
    r = -1;
  }
  return r;
}
 80051a0:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
      pDown->RdOff        = 0u;
 80051a4:	2100      	movs	r1, #0
      pDown->sName        = sName;
 80051a6:	eb05 0245 	add.w	r2, r5, r5, lsl #1
 80051aa:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
 80051ae:	f8c2 8060 	str.w	r8, [r2, #96]	@ 0x60
 80051b2:	006b      	lsls	r3, r5, #1
      pDown->pBuffer      = (char*)pBuffer;
 80051b4:	6657      	str	r7, [r2, #100]	@ 0x64
      pDown->SizeOfBuffer = BufferSize;
 80051b6:	6696      	str	r6, [r2, #104]	@ 0x68
      pDown->RdOff        = 0u;
 80051b8:	6711      	str	r1, [r2, #112]	@ 0x70
      pDown->WrOff        = 0u;
 80051ba:	66d1      	str	r1, [r2, #108]	@ 0x6c
 80051bc:	e7e8      	b.n	8005190 <SEGGER_RTT_ConfigDownBuffer+0xb8>
    r = -1;
 80051be:	f04f 30ff 	mov.w	r0, #4294967295
  return r;
 80051c2:	e7ed      	b.n	80051a0 <SEGGER_RTT_ConfigDownBuffer+0xc8>
 80051c4:	2000188c 	.word	0x2000188c
 80051c8:	08006f00 	.word	0x08006f00
 80051cc:	20001888 	.word	0x20001888
 80051d0:	20001878 	.word	0x20001878

080051d4 <SEGGER_SYSVIEW_Init>:
*    The channel is assigned the label "SysView" for client software
*    to identify the SystemView channel.
*
*    The channel is configured with the macro SEGGER_SYSVIEW_RTT_CHANNEL.
*/
void SEGGER_SYSVIEW_Init(U32 SysFreq, U32 CPUFreq, const SEGGER_SYSVIEW_OS_API *pOSAPI, SEGGER_SYSVIEW_SEND_SYS_DESC_FUNC pfSendSysDesc) {
 80051d4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
#else // (SEGGER_SYSVIEW_POST_MORTEM_MODE == 1)
#if SEGGER_SYSVIEW_RTT_CHANNEL > 0
  SEGGER_RTT_ConfigUpBuffer   (SEGGER_SYSVIEW_RTT_CHANNEL, "SysView", &_UpBuffer[0],   sizeof(_UpBuffer),   SEGGER_RTT_MODE_NO_BLOCK_SKIP);
  SEGGER_RTT_ConfigDownBuffer (SEGGER_SYSVIEW_RTT_CHANNEL, "SysView", &_DownBuffer[0], sizeof(_DownBuffer), SEGGER_RTT_MODE_NO_BLOCK_SKIP);
#else
  _SYSVIEW_Globals.UpChannel = (U8)SEGGER_RTT_AllocUpBuffer  ("SysView", &_UpBuffer[0],   sizeof(_UpBuffer),   SEGGER_RTT_MODE_NO_BLOCK_SKIP);
 80051d8:	f8df a048 	ldr.w	sl, [pc, #72]	@ 8005224 <SEGGER_SYSVIEW_Init+0x50>
void SEGGER_SYSVIEW_Init(U32 SysFreq, U32 CPUFreq, const SEGGER_SYSVIEW_OS_API *pOSAPI, SEGGER_SYSVIEW_SEND_SYS_DESC_FUNC pfSendSysDesc) {
 80051dc:	b082      	sub	sp, #8
 80051de:	4680      	mov	r8, r0
 80051e0:	460f      	mov	r7, r1
 80051e2:	4691      	mov	r9, r2
 80051e4:	461e      	mov	r6, r3
  _SYSVIEW_Globals.UpChannel = (U8)SEGGER_RTT_AllocUpBuffer  ("SysView", &_UpBuffer[0],   sizeof(_UpBuffer),   SEGGER_RTT_MODE_NO_BLOCK_SKIP);
 80051e6:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 80051ea:	2300      	movs	r3, #0
 80051ec:	4650      	mov	r0, sl
 80051ee:	490e      	ldr	r1, [pc, #56]	@ (8005228 <SEGGER_SYSVIEW_Init+0x54>)
 80051f0:	f7ff fee8 	bl	8004fc4 <SEGGER_RTT_AllocUpBuffer>
  _SYSVIEW_Globals.DownChannel = _SYSVIEW_Globals.UpChannel;
  SEGGER_RTT_ConfigDownBuffer (_SYSVIEW_Globals.DownChannel, "SysView", &_DownBuffer[0], sizeof(_DownBuffer), SEGGER_RTT_MODE_NO_BLOCK_SKIP);
 80051f4:	2500      	movs	r5, #0
  _SYSVIEW_Globals.UpChannel = (U8)SEGGER_RTT_AllocUpBuffer  ("SysView", &_UpBuffer[0],   sizeof(_UpBuffer),   SEGGER_RTT_MODE_NO_BLOCK_SKIP);
 80051f6:	4c0d      	ldr	r4, [pc, #52]	@ (800522c <SEGGER_SYSVIEW_Init+0x58>)
 80051f8:	b2c0      	uxtb	r0, r0
  SEGGER_RTT_ConfigDownBuffer (_SYSVIEW_Globals.DownChannel, "SysView", &_DownBuffer[0], sizeof(_DownBuffer), SEGGER_RTT_MODE_NO_BLOCK_SKIP);
 80051fa:	9500      	str	r5, [sp, #0]
 80051fc:	2308      	movs	r3, #8
 80051fe:	4651      	mov	r1, sl
 8005200:	4a0b      	ldr	r2, [pc, #44]	@ (8005230 <SEGGER_SYSVIEW_Init+0x5c>)
  _SYSVIEW_Globals.UpChannel = (U8)SEGGER_RTT_AllocUpBuffer  ("SysView", &_UpBuffer[0],   sizeof(_UpBuffer),   SEGGER_RTT_MODE_NO_BLOCK_SKIP);
 8005202:	7060      	strb	r0, [r4, #1]
  _SYSVIEW_Globals.DownChannel = _SYSVIEW_Globals.UpChannel;
 8005204:	7620      	strb	r0, [r4, #24]
  SEGGER_RTT_ConfigDownBuffer (_SYSVIEW_Globals.DownChannel, "SysView", &_DownBuffer[0], sizeof(_DownBuffer), SEGGER_RTT_MODE_NO_BLOCK_SKIP);
 8005206:	f7ff ff67 	bl	80050d8 <SEGGER_RTT_ConfigDownBuffer>
#endif
  _SYSVIEW_Globals.RAMBaseAddress   = SEGGER_SYSVIEW_ID_BASE;
  _SYSVIEW_Globals.LastTxTimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
  _SYSVIEW_Globals.pOSAPI           = pOSAPI;
  _SYSVIEW_Globals.SysFreq          = SysFreq;
  _SYSVIEW_Globals.CPUFreq          = CPUFreq;
 800520a:	e9c4 8701 	strd	r8, r7, [r4, #4]
  _SYSVIEW_Globals.LastTxTimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
 800520e:	4b09      	ldr	r3, [pc, #36]	@ (8005234 <SEGGER_SYSVIEW_Init+0x60>)
  _SYSVIEW_Globals.RAMBaseAddress   = SEGGER_SYSVIEW_ID_BASE;
 8005210:	6125      	str	r5, [r4, #16]
  _SYSVIEW_Globals.LastTxTimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
 8005212:	685b      	ldr	r3, [r3, #4]
  _SYSVIEW_Globals.pOSAPI           = pOSAPI;
 8005214:	f8c4 9020 	str.w	r9, [r4, #32]
  _SYSVIEW_Globals.pfSendSysDesc    = pfSendSysDesc;
 8005218:	6266      	str	r6, [r4, #36]	@ 0x24
  _SYSVIEW_Globals.EnableState      = 0;
 800521a:	7025      	strb	r5, [r4, #0]
  _SYSVIEW_Globals.LastTxTimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
 800521c:	60e3      	str	r3, [r4, #12]
#endif  // (SEGGER_SYSVIEW_POST_MORTEM_MODE == 1)
}
 800521e:	b002      	add	sp, #8
 8005220:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8005224:	08006f0c 	.word	0x08006f0c
 8005228:	20001a4c 	.word	0x20001a4c
 800522c:	20001a1c 	.word	0x20001a1c
 8005230:	20001a44 	.word	0x20001a44
 8005234:	e0001000 	.word	0xe0001000

08005238 <SEGGER_SYSVIEW_SetRAMBase>:
*
*  Parameters
*    RAMBaseAddress - Lowest RAM Address. (i.e. 0x20000000 on most Cortex-M)
*/
void SEGGER_SYSVIEW_SetRAMBase(U32 RAMBaseAddress) {
  _SYSVIEW_Globals.RAMBaseAddress = RAMBaseAddress;
 8005238:	4b01      	ldr	r3, [pc, #4]	@ (8005240 <SEGGER_SYSVIEW_SetRAMBase+0x8>)
 800523a:	6118      	str	r0, [r3, #16]
}
 800523c:	4770      	bx	lr
 800523e:	bf00      	nop
 8005240:	20001a1c 	.word	0x20001a1c

08005244 <SEGGER_SYSVIEW_ShrinkId>:
*       (i.e. 0x20000000 when all Ids are an address in this RAM)
*     SEGGER_SYSVIEW_ID_SHIFT: Number of bits to shift the Id to
*       save bandwidth. (i.e. 2 when Ids are 4 byte aligned)
*/
U32 SEGGER_SYSVIEW_ShrinkId(U32 Id) {
  return SHRINK_ID(Id);
 8005244:	4b01      	ldr	r3, [pc, #4]	@ (800524c <SEGGER_SYSVIEW_ShrinkId+0x8>)
 8005246:	691b      	ldr	r3, [r3, #16]
}
 8005248:	1ac0      	subs	r0, r0, r3
 800524a:	4770      	bx	lr
 800524c:	20001a1c 	.word	0x20001a1c

08005250 <SEGGER_SYSVIEW_SendModule>:
*/
void SEGGER_SYSVIEW_SendModule(U8 ModuleId) {
  SEGGER_SYSVIEW_MODULE* pModule;
  U32 n;

  if (_pFirstModule != 0) {
 8005250:	4b2a      	ldr	r3, [pc, #168]	@ (80052fc <SEGGER_SYSVIEW_SendModule+0xac>)
void SEGGER_SYSVIEW_SendModule(U8 ModuleId) {
 8005252:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (_pFirstModule != 0) {
 8005256:	681c      	ldr	r4, [r3, #0]
 8005258:	b144      	cbz	r4, 800526c <SEGGER_SYSVIEW_SendModule+0x1c>
    pModule = _pFirstModule;
    for (n = 0; n < ModuleId; n++) {
 800525a:	2300      	movs	r3, #0
 800525c:	b910      	cbnz	r0, 8005264 <SEGGER_SYSVIEW_SendModule+0x14>
 800525e:	e044      	b.n	80052ea <SEGGER_SYSVIEW_SendModule+0x9a>
 8005260:	4283      	cmp	r3, r0
 8005262:	d005      	beq.n	8005270 <SEGGER_SYSVIEW_SendModule+0x20>
      pModule = pModule->pNext;
 8005264:	6924      	ldr	r4, [r4, #16]
    for (n = 0; n < ModuleId; n++) {
 8005266:	3301      	adds	r3, #1
      if (pModule == 0) {
 8005268:	2c00      	cmp	r4, #0
 800526a:	d1f9      	bne.n	8005260 <SEGGER_SYSVIEW_SendModule+0x10>
    }
    if (pModule && pModule->pfSendModuleDesc) {
      pModule->pfSendModuleDesc();
    }
  }
}
 800526c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32 + 1 + SEGGER_SYSVIEW_MAX_STRING_LEN);
 8005270:	f3ef 8611 	mrs	r6, BASEPRI
 8005274:	f04f 0120 	mov.w	r1, #32
 8005278:	f381 8811 	msr	BASEPRI, r1
      ENCODE_U32(pPayload, ModuleId);
 800527c:	287f      	cmp	r0, #127	@ 0x7f
 800527e:	d930      	bls.n	80052e2 <SEGGER_SYSVIEW_SendModule+0x92>
 8005280:	4a1f      	ldr	r2, [pc, #124]	@ (8005300 <SEGGER_SYSVIEW_SendModule+0xb0>)
 8005282:	71d0      	strb	r0, [r2, #7]
 8005284:	2001      	movs	r0, #1
 8005286:	3208      	adds	r2, #8
 8005288:	f802 0b01 	strb.w	r0, [r2], #1
      ENCODE_U32(pPayload, (pModule->EventOffset));
 800528c:	68a3      	ldr	r3, [r4, #8]
 800528e:	2b7f      	cmp	r3, #127	@ 0x7f
 8005290:	d906      	bls.n	80052a0 <SEGGER_SYSVIEW_SendModule+0x50>
 8005292:	f063 017f 	orn	r1, r3, #127	@ 0x7f
 8005296:	09db      	lsrs	r3, r3, #7
 8005298:	2b7f      	cmp	r3, #127	@ 0x7f
 800529a:	f802 1b01 	strb.w	r1, [r2], #1
 800529e:	d8f8      	bhi.n	8005292 <SEGGER_SYSVIEW_SendModule+0x42>
 80052a0:	4611      	mov	r1, r2
 80052a2:	f801 3b02 	strb.w	r3, [r1], #2
      pPayload = _EncodeStr(pPayload, pModule->sModule, SEGGER_SYSVIEW_MAX_STRING_LEN);
 80052a6:	6827      	ldr	r7, [r4, #0]
  if (pText == NULL) {
 80052a8:	b177      	cbz	r7, 80052c8 <SEGGER_SYSVIEW_SendModule+0x78>
 80052aa:	4638      	mov	r0, r7
 80052ac:	f107 0c80 	add.w	ip, r7, #128	@ 0x80
 80052b0:	e003      	b.n	80052ba <SEGGER_SYSVIEW_SendModule+0x6a>
    while ((Limit-- > 0) && (*pText != '\0')) {
 80052b2:	4560      	cmp	r0, ip
      *pPayload++ = *pText++;
 80052b4:	f801 5b01 	strb.w	r5, [r1], #1
    while ((Limit-- > 0) && (*pText != '\0')) {
 80052b8:	d015      	beq.n	80052e6 <SEGGER_SYSVIEW_SendModule+0x96>
 80052ba:	7805      	ldrb	r5, [r0, #0]
 80052bc:	4603      	mov	r3, r0
 80052be:	3001      	adds	r0, #1
 80052c0:	2d00      	cmp	r5, #0
 80052c2:	d1f6      	bne.n	80052b2 <SEGGER_SYSVIEW_SendModule+0x62>
    *pLen = (U8)(pText - sStart);
 80052c4:	1bdb      	subs	r3, r3, r7
 80052c6:	b2df      	uxtb	r7, r3
    *pPayload++ = (U8)0;
 80052c8:	7057      	strb	r7, [r2, #1]
      _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_MODULEDESC);
 80052ca:	480e      	ldr	r0, [pc, #56]	@ (8005304 <SEGGER_SYSVIEW_SendModule+0xb4>)
 80052cc:	2216      	movs	r2, #22
 80052ce:	f000 f8a5 	bl	800541c <_SendPacket>
      RECORD_END();
 80052d2:	f386 8811 	msr	BASEPRI, r6
    if (pModule && pModule->pfSendModuleDesc) {
 80052d6:	68e3      	ldr	r3, [r4, #12]
 80052d8:	2b00      	cmp	r3, #0
 80052da:	d0c7      	beq.n	800526c <SEGGER_SYSVIEW_SendModule+0x1c>
}
 80052dc:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
      pModule->pfSendModuleDesc();
 80052e0:	4718      	bx	r3
 80052e2:	4a08      	ldr	r2, [pc, #32]	@ (8005304 <SEGGER_SYSVIEW_SendModule+0xb4>)
 80052e4:	e7d0      	b.n	8005288 <SEGGER_SYSVIEW_SendModule+0x38>
      *pPayload++ = *pText++;
 80052e6:	4603      	mov	r3, r0
 80052e8:	e7ec      	b.n	80052c4 <SEGGER_SYSVIEW_SendModule+0x74>
      RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32 + 1 + SEGGER_SYSVIEW_MAX_STRING_LEN);
 80052ea:	f3ef 8611 	mrs	r6, BASEPRI
 80052ee:	f04f 0120 	mov.w	r1, #32
 80052f2:	f381 8811 	msr	BASEPRI, r1
 80052f6:	4a03      	ldr	r2, [pc, #12]	@ (8005304 <SEGGER_SYSVIEW_SendModule+0xb4>)
      ENCODE_U32(pPayload, ModuleId);
 80052f8:	e7c6      	b.n	8005288 <SEGGER_SYSVIEW_SendModule+0x38>
 80052fa:	bf00      	nop
 80052fc:	20001a18 	.word	0x20001a18
 8005300:	20001934 	.word	0x20001934
 8005304:	2000193b 	.word	0x2000193b

08005308 <_HandleIncomingPacket>:
static void _HandleIncomingPacket(void) {
 8005308:	b530      	push	{r4, r5, lr}
  Status = SEGGER_RTT_ReadNoLock(CHANNEL_ID_DOWN, &Cmd, 1);
 800530a:	4c3f      	ldr	r4, [pc, #252]	@ (8005408 <_HandleIncomingPacket+0x100>)
static void _HandleIncomingPacket(void) {
 800530c:	b083      	sub	sp, #12
  Status = SEGGER_RTT_ReadNoLock(CHANNEL_ID_DOWN, &Cmd, 1);
 800530e:	2201      	movs	r2, #1
 8005310:	7e20      	ldrb	r0, [r4, #24]
 8005312:	f10d 0107 	add.w	r1, sp, #7
 8005316:	f7ff fc9f 	bl	8004c58 <SEGGER_RTT_ReadNoLock>
  if (Status > 0) {
 800531a:	b308      	cbz	r0, 8005360 <_HandleIncomingPacket+0x58>
    switch (Cmd) {
 800531c:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8005320:	2b07      	cmp	r3, #7
 8005322:	d81f      	bhi.n	8005364 <_HandleIncomingPacket+0x5c>
 8005324:	b1e3      	cbz	r3, 8005360 <_HandleIncomingPacket+0x58>
 8005326:	3b02      	subs	r3, #2
 8005328:	2b05      	cmp	r3, #5
 800532a:	d86a      	bhi.n	8005402 <_HandleIncomingPacket+0xfa>
 800532c:	e8df f003 	tbb	[pc, r3]
 8005330:	2b2e3639 	.word	0x2b2e3639
 8005334:	4403      	.short	0x4403
*    Send the number of registered modules to the host.
*/
void SEGGER_SYSVIEW_SendNumModules(void) {
  U8* pPayload;
  U8* pPayloadStart;
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2*SEGGER_SYSVIEW_QUANTA_U32);
 8005336:	f3ef 8411 	mrs	r4, BASEPRI
 800533a:	f04f 0120 	mov.w	r1, #32
 800533e:	f381 8811 	msr	BASEPRI, r1
  pPayload = pPayloadStart;
  ENCODE_U32(pPayload, _NumModules);
 8005342:	4b32      	ldr	r3, [pc, #200]	@ (800540c <_HandleIncomingPacket+0x104>)
 8005344:	f993 2000 	ldrsb.w	r2, [r3]
 8005348:	781b      	ldrb	r3, [r3, #0]
 800534a:	2a00      	cmp	r2, #0
 800534c:	db43      	blt.n	80053d6 <_HandleIncomingPacket+0xce>
 800534e:	4930      	ldr	r1, [pc, #192]	@ (8005410 <_HandleIncomingPacket+0x108>)
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_NUMMODULES);
 8005350:	221b      	movs	r2, #27
 8005352:	482f      	ldr	r0, [pc, #188]	@ (8005410 <_HandleIncomingPacket+0x108>)
  ENCODE_U32(pPayload, _NumModules);
 8005354:	f801 3b01 	strb.w	r3, [r1], #1
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_NUMMODULES);
 8005358:	f000 f860 	bl	800541c <_SendPacket>
  RECORD_END();
 800535c:	f384 8811 	msr	BASEPRI, r4
}
 8005360:	b003      	add	sp, #12
 8005362:	bd30      	pop	{r4, r5, pc}
    switch (Cmd) {
 8005364:	2b7f      	cmp	r3, #127	@ 0x7f
 8005366:	d0fb      	beq.n	8005360 <_HandleIncomingPacket+0x58>
 8005368:	2b80      	cmp	r3, #128	@ 0x80
 800536a:	d141      	bne.n	80053f0 <_HandleIncomingPacket+0xe8>
      Status = SEGGER_RTT_ReadNoLock(CHANNEL_ID_DOWN, &Cmd, 1);
 800536c:	2201      	movs	r2, #1
 800536e:	7e20      	ldrb	r0, [r4, #24]
 8005370:	f10d 0107 	add.w	r1, sp, #7
 8005374:	f7ff fc70 	bl	8004c58 <SEGGER_RTT_ReadNoLock>
      if (Status > 0) {
 8005378:	2800      	cmp	r0, #0
 800537a:	d0f1      	beq.n	8005360 <_HandleIncomingPacket+0x58>
        SEGGER_SYSVIEW_SendModule(Cmd);
 800537c:	f89d 0007 	ldrb.w	r0, [sp, #7]
 8005380:	f7ff ff66 	bl	8005250 <SEGGER_SYSVIEW_SendModule>
 8005384:	e7ec      	b.n	8005360 <_HandleIncomingPacket+0x58>
      SEGGER_SYSVIEW_GetSysDesc();
 8005386:	f000 fa07 	bl	8005798 <SEGGER_SYSVIEW_GetSysDesc>
      break;
 800538a:	e7e9      	b.n	8005360 <_HandleIncomingPacket+0x58>
  if (_SYSVIEW_Globals.pOSAPI && _SYSVIEW_Globals.pOSAPI->pfSendTaskList) {
 800538c:	6a23      	ldr	r3, [r4, #32]
 800538e:	2b00      	cmp	r3, #0
 8005390:	d0e6      	beq.n	8005360 <_HandleIncomingPacket+0x58>
 8005392:	685b      	ldr	r3, [r3, #4]
 8005394:	2b00      	cmp	r3, #0
 8005396:	d0e3      	beq.n	8005360 <_HandleIncomingPacket+0x58>
    _SYSVIEW_Globals.pOSAPI->pfSendTaskList();
 8005398:	4798      	blx	r3
 800539a:	e7e1      	b.n	8005360 <_HandleIncomingPacket+0x58>
      SEGGER_SYSVIEW_RecordSystime();
 800539c:	f000 fbaa 	bl	8005af4 <SEGGER_SYSVIEW_RecordSystime>
      break;
 80053a0:	e7de      	b.n	8005360 <_HandleIncomingPacket+0x58>
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE);
 80053a2:	f3ef 8511 	mrs	r5, BASEPRI
 80053a6:	f04f 0120 	mov.w	r1, #32
 80053aa:	f381 8811 	msr	BASEPRI, r1
  if (_SYSVIEW_Globals.EnableState) {
 80053ae:	7823      	ldrb	r3, [r4, #0]
 80053b0:	b9b3      	cbnz	r3, 80053e0 <_HandleIncomingPacket+0xd8>
  RECORD_END();
 80053b2:	f385 8811 	msr	BASEPRI, r5
}
 80053b6:	e7d3      	b.n	8005360 <_HandleIncomingPacket+0x58>
  if (_pFirstModule != 0) {
 80053b8:	4b16      	ldr	r3, [pc, #88]	@ (8005414 <_HandleIncomingPacket+0x10c>)
 80053ba:	681c      	ldr	r4, [r3, #0]
 80053bc:	2c00      	cmp	r4, #0
 80053be:	d0cf      	beq.n	8005360 <_HandleIncomingPacket+0x58>
      if (pModule->pfSendModuleDesc) {
 80053c0:	68e3      	ldr	r3, [r4, #12]
 80053c2:	b123      	cbz	r3, 80053ce <_HandleIncomingPacket+0xc6>
        pModule->pfSendModuleDesc();
 80053c4:	4798      	blx	r3
      pModule = pModule->pNext;
 80053c6:	6924      	ldr	r4, [r4, #16]
    } while (pModule);
 80053c8:	2c00      	cmp	r4, #0
 80053ca:	d1f9      	bne.n	80053c0 <_HandleIncomingPacket+0xb8>
 80053cc:	e7c8      	b.n	8005360 <_HandleIncomingPacket+0x58>
      pModule = pModule->pNext;
 80053ce:	6924      	ldr	r4, [r4, #16]
    } while (pModule);
 80053d0:	2c00      	cmp	r4, #0
 80053d2:	d1f5      	bne.n	80053c0 <_HandleIncomingPacket+0xb8>
 80053d4:	e7c4      	b.n	8005360 <_HandleIncomingPacket+0x58>
  ENCODE_U32(pPayload, _NumModules);
 80053d6:	4910      	ldr	r1, [pc, #64]	@ (8005418 <_HandleIncomingPacket+0x110>)
 80053d8:	71cb      	strb	r3, [r1, #7]
 80053da:	2301      	movs	r3, #1
 80053dc:	3108      	adds	r1, #8
 80053de:	e7b7      	b.n	8005350 <_HandleIncomingPacket+0x48>
    _SendPacket(pPayloadStart, pPayloadStart, SYSVIEW_EVTID_TRACE_STOP);
 80053e0:	490b      	ldr	r1, [pc, #44]	@ (8005410 <_HandleIncomingPacket+0x108>)
 80053e2:	220b      	movs	r2, #11
 80053e4:	4608      	mov	r0, r1
 80053e6:	f000 f819 	bl	800541c <_SendPacket>
    _SYSVIEW_Globals.EnableState = 0;
 80053ea:	2300      	movs	r3, #0
 80053ec:	7023      	strb	r3, [r4, #0]
 80053ee:	e7e0      	b.n	80053b2 <_HandleIncomingPacket+0xaa>
      if (Cmd >= 128) { // Unknown extended command. Dummy read its parameter.
 80053f0:	061b      	lsls	r3, r3, #24
 80053f2:	d5b5      	bpl.n	8005360 <_HandleIncomingPacket+0x58>
        SEGGER_RTT_ReadNoLock(CHANNEL_ID_DOWN, &Cmd, 1);
 80053f4:	2201      	movs	r2, #1
 80053f6:	7e20      	ldrb	r0, [r4, #24]
 80053f8:	f10d 0107 	add.w	r1, sp, #7
 80053fc:	f7ff fc2c 	bl	8004c58 <SEGGER_RTT_ReadNoLock>
}
 8005400:	e7ae      	b.n	8005360 <_HandleIncomingPacket+0x58>
      SEGGER_SYSVIEW_Start();
 8005402:	f000 fcfd 	bl	8005e00 <SEGGER_SYSVIEW_Start>
      break;
 8005406:	e7ab      	b.n	8005360 <_HandleIncomingPacket+0x58>
 8005408:	20001a1c 	.word	0x20001a1c
 800540c:	20001a17 	.word	0x20001a17
 8005410:	2000193b 	.word	0x2000193b
 8005414:	20001a18 	.word	0x20001a18
 8005418:	20001934 	.word	0x20001934

0800541c <_SendPacket>:
static void _SendPacket(U8* pStartPacket, U8* pEndPacket, unsigned int EventId) {
 800541c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
 8005420:	4d75      	ldr	r5, [pc, #468]	@ (80055f8 <_SendPacket+0x1dc>)
static void _SendPacket(U8* pStartPacket, U8* pEndPacket, unsigned int EventId) {
 8005422:	4607      	mov	r7, r0
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
 8005424:	782b      	ldrb	r3, [r5, #0]
static void _SendPacket(U8* pStartPacket, U8* pEndPacket, unsigned int EventId) {
 8005426:	460c      	mov	r4, r1
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
 8005428:	2b01      	cmp	r3, #1
static void _SendPacket(U8* pStartPacket, U8* pEndPacket, unsigned int EventId) {
 800542a:	4616      	mov	r6, r2
 800542c:	b085      	sub	sp, #20
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
 800542e:	d003      	beq.n	8005438 <_SendPacket+0x1c>
  if (_SYSVIEW_Globals.EnableState == 0) {
 8005430:	2b00      	cmp	r3, #0
 8005432:	d048      	beq.n	80054c6 <_SendPacket+0xaa>
  if (_SYSVIEW_Globals.EnableState == 2) {
 8005434:	2b02      	cmp	r3, #2
 8005436:	d069      	beq.n	800550c <_SendPacket+0xf0>
  if (EventId < 32) {
 8005438:	2e1f      	cmp	r6, #31
 800543a:	d815      	bhi.n	8005468 <_SendPacket+0x4c>
    if (_SYSVIEW_Globals.DisabledEvents & ((U32)1u << EventId)) {
 800543c:	69eb      	ldr	r3, [r5, #28]
 800543e:	40f3      	lsrs	r3, r6
 8005440:	07db      	lsls	r3, r3, #31
 8005442:	d440      	bmi.n	80054c6 <_SendPacket+0xaa>
  if (EventId < 24) {
 8005444:	2e17      	cmp	r6, #23
 8005446:	d95d      	bls.n	8005504 <_SendPacket+0xe8>
    NumBytes = (unsigned int)(pEndPacket - pStartPacket);
 8005448:	1be3      	subs	r3, r4, r7
    if (NumBytes > 127) {
 800544a:	2b7f      	cmp	r3, #127	@ 0x7f
 800544c:	f240 80bb 	bls.w	80055c6 <_SendPacket+0x1aa>
      *--pStartPacket = (U8)(NumBytes | 0x80);
 8005450:	f063 027f 	orn	r2, r3, #127	@ 0x7f
      *--pStartPacket = (U8)(NumBytes >> 7);
 8005454:	09db      	lsrs	r3, r3, #7
      *--pStartPacket = (U8)(NumBytes | 0x80);
 8005456:	f807 2c02 	strb.w	r2, [r7, #-2]
      *--pStartPacket = (U8)(NumBytes >> 7);
 800545a:	f807 3c01 	strb.w	r3, [r7, #-1]
      *--pStartPacket = (U8)(NumBytes | 0x80);
 800545e:	1eba      	subs	r2, r7, #2
      *--pStartPacket = (U8)EventId;
 8005460:	1e51      	subs	r1, r2, #1
 8005462:	f802 6c01 	strb.w	r6, [r2, #-1]
 8005466:	e015      	b.n	8005494 <_SendPacket+0x78>
    NumBytes = (unsigned int)(pEndPacket - pStartPacket);
 8005468:	1be3      	subs	r3, r4, r7
    if (NumBytes > 127) {
 800546a:	2b7f      	cmp	r3, #127	@ 0x7f
 800546c:	d842      	bhi.n	80054f4 <_SendPacket+0xd8>
      *--pStartPacket = (U8)NumBytes;
 800546e:	b2db      	uxtb	r3, r3
 8005470:	1e7a      	subs	r2, r7, #1
    if (EventId < 127) {
 8005472:	2e7e      	cmp	r6, #126	@ 0x7e
 8005474:	f807 3c01 	strb.w	r3, [r7, #-1]
 8005478:	d9f2      	bls.n	8005460 <_SendPacket+0x44>
        *--pStartPacket = (U8)(EventId | 0x80);
 800547a:	f066 037f 	orn	r3, r6, #127	@ 0x7f
      if (EventId < (1u << 14)) { // Encodes in 2 bytes
 800547e:	f5b6 4f80 	cmp.w	r6, #16384	@ 0x4000
        *--pStartPacket = (U8)(EventId >>  7);
 8005482:	f3c6 11c7 	ubfx	r1, r6, #7, #8
        *--pStartPacket = (U8)(EventId | 0x80);
 8005486:	b2db      	uxtb	r3, r3
      if (EventId < (1u << 14)) { // Encodes in 2 bytes
 8005488:	d27a      	bcs.n	8005580 <_SendPacket+0x164>
        *--pStartPacket = (U8)(EventId >>  7);
 800548a:	f802 1c01 	strb.w	r1, [r2, #-1]
        *--pStartPacket = (U8)(EventId | 0x80);
 800548e:	f802 3c02 	strb.w	r3, [r2, #-2]
 8005492:	1e91      	subs	r1, r2, #2
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
 8005494:	4a59      	ldr	r2, [pc, #356]	@ (80055fc <_SendPacket+0x1e0>)
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
 8005496:	68eb      	ldr	r3, [r5, #12]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
 8005498:	6856      	ldr	r6, [r2, #4]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
 800549a:	1af3      	subs	r3, r6, r3
  ENCODE_U32(pEndPacket, Delta);
 800549c:	2b7f      	cmp	r3, #127	@ 0x7f
 800549e:	d906      	bls.n	80054ae <_SendPacket+0x92>
 80054a0:	f063 007f 	orn	r0, r3, #127	@ 0x7f
 80054a4:	09db      	lsrs	r3, r3, #7
 80054a6:	2b7f      	cmp	r3, #127	@ 0x7f
 80054a8:	f804 0b01 	strb.w	r0, [r4], #1
 80054ac:	d8f8      	bhi.n	80054a0 <_SendPacket+0x84>
 80054ae:	f804 3b01 	strb.w	r3, [r4], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, (unsigned int)(pEndPacket - pStartPacket));
 80054b2:	1a62      	subs	r2, r4, r1
 80054b4:	7868      	ldrb	r0, [r5, #1]
 80054b6:	f7fa fe4b 	bl	8000150 <SEGGER_RTT_ASM_WriteSkipNoLock>
 80054ba:	4604      	mov	r4, r0
  SEGGER_SYSVIEW_ON_EVENT_RECORDED(pEndPacket - pStartPacket);
 80054bc:	f7ff fb0e 	bl	8004adc <HIF_UART_EnableTXEInterrupt>
  if (Status) {
 80054c0:	2c00      	cmp	r4, #0
 80054c2:	d059      	beq.n	8005578 <_SendPacket+0x15c>
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
 80054c4:	60ee      	str	r6, [r5, #12]
  if (SEGGER_RTT_HASDATA(CHANNEL_ID_DOWN)) {
 80054c6:	7e2a      	ldrb	r2, [r5, #24]
 80054c8:	4b4d      	ldr	r3, [pc, #308]	@ (8005600 <_SendPacket+0x1e4>)
 80054ca:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 80054ce:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 80054d2:	6eda      	ldr	r2, [r3, #108]	@ 0x6c
 80054d4:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 80054d6:	429a      	cmp	r2, r3
 80054d8:	d001      	beq.n	80054de <_SendPacket+0xc2>
    if (_SYSVIEW_Globals.RecursionCnt == 0) {   // Avoid uncontrolled nesting. This way, this routine can call itself once, but no more often than that.
 80054da:	78ac      	ldrb	r4, [r5, #2]
 80054dc:	b114      	cbz	r4, 80054e4 <_SendPacket+0xc8>
}
 80054de:	b005      	add	sp, #20
 80054e0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      _SYSVIEW_Globals.RecursionCnt = 1;
 80054e4:	2301      	movs	r3, #1
 80054e6:	70ab      	strb	r3, [r5, #2]
      _HandleIncomingPacket();
 80054e8:	f7ff ff0e 	bl	8005308 <_HandleIncomingPacket>
      _SYSVIEW_Globals.RecursionCnt = 0;
 80054ec:	70ac      	strb	r4, [r5, #2]
}
 80054ee:	b005      	add	sp, #20
 80054f0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      *--pStartPacket = (U8)(NumBytes | 0x80);
 80054f4:	f063 027f 	orn	r2, r3, #127	@ 0x7f
 80054f8:	f807 2c02 	strb.w	r2, [r7, #-2]
      *--pStartPacket = (U8)(NumBytes >> 7);
 80054fc:	f3c3 13c7 	ubfx	r3, r3, #7, #8
      *--pStartPacket = (U8)(NumBytes | 0x80);
 8005500:	1eba      	subs	r2, r7, #2
 8005502:	e7b6      	b.n	8005472 <_SendPacket+0x56>
    *--pStartPacket = (U8)EventId;
 8005504:	1e79      	subs	r1, r7, #1
 8005506:	f807 6c01 	strb.w	r6, [r7, #-1]
 800550a:	e7c3      	b.n	8005494 <_SendPacket+0x78>
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
 800550c:	2201      	movs	r2, #1
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
 800550e:	696b      	ldr	r3, [r5, #20]
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
 8005510:	f88d 2004 	strb.w	r2, [sp, #4]
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
 8005514:	2b7f      	cmp	r3, #127	@ 0x7f
 8005516:	f10d 0205 	add.w	r2, sp, #5
 800551a:	d906      	bls.n	800552a <_SendPacket+0x10e>
 800551c:	f063 017f 	orn	r1, r3, #127	@ 0x7f
 8005520:	09db      	lsrs	r3, r3, #7
 8005522:	2b7f      	cmp	r3, #127	@ 0x7f
 8005524:	f802 1b01 	strb.w	r1, [r2], #1
 8005528:	d8f8      	bhi.n	800551c <_SendPacket+0x100>
 800552a:	f802 3b01 	strb.w	r3, [r2], #1
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
 800552e:	4b33      	ldr	r3, [pc, #204]	@ (80055fc <_SendPacket+0x1e0>)
 8005530:	f8d3 8004 	ldr.w	r8, [r3, #4]
  Delta = (I32)(TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp);
 8005534:	68eb      	ldr	r3, [r5, #12]
 8005536:	eba8 0303 	sub.w	r3, r8, r3
  ENCODE_U32(pPayload, Delta);
 800553a:	2b7f      	cmp	r3, #127	@ 0x7f
 800553c:	d906      	bls.n	800554c <_SendPacket+0x130>
 800553e:	f063 017f 	orn	r1, r3, #127	@ 0x7f
 8005542:	09db      	lsrs	r3, r3, #7
 8005544:	2b7f      	cmp	r3, #127	@ 0x7f
 8005546:	f802 1b01 	strb.w	r1, [r2], #1
 800554a:	d8f8      	bhi.n	800553e <_SendPacket+0x122>
 800554c:	f802 3b01 	strb.w	r3, [r2], #1
  Status = (int)SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, (unsigned int)(pPayload - aPacket));
 8005550:	a901      	add	r1, sp, #4
 8005552:	7868      	ldrb	r0, [r5, #1]
 8005554:	1a52      	subs	r2, r2, r1
 8005556:	f7fa fdfb 	bl	8000150 <SEGGER_RTT_ASM_WriteSkipNoLock>
 800555a:	4681      	mov	r9, r0
  SEGGER_SYSVIEW_ON_EVENT_RECORDED(pPayload - aPacket);
 800555c:	f7ff fabe 	bl	8004adc <HIF_UART_EnableTXEInterrupt>
  if (Status) {
 8005560:	f1b9 0f00 	cmp.w	r9, #0
 8005564:	d033      	beq.n	80055ce <_SendPacket+0x1b2>
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
 8005566:	782b      	ldrb	r3, [r5, #0]
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
 8005568:	f8c5 800c 	str.w	r8, [r5, #12]
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
 800556c:	3b01      	subs	r3, #1
 800556e:	b2db      	uxtb	r3, r3
 8005570:	702b      	strb	r3, [r5, #0]
    if (_SYSVIEW_Globals.EnableState != 1) {
 8005572:	2b01      	cmp	r3, #1
 8005574:	d1a7      	bne.n	80054c6 <_SendPacket+0xaa>
 8005576:	e75f      	b.n	8005438 <_SendPacket+0x1c>
    _SYSVIEW_Globals.EnableState++; // EnableState has been 1, will be 2. Always.
 8005578:	782b      	ldrb	r3, [r5, #0]
 800557a:	3301      	adds	r3, #1
 800557c:	702b      	strb	r3, [r5, #0]
 800557e:	e7a2      	b.n	80054c6 <_SendPacket+0xaa>
      } else if (EventId < (1ul << 21)) {    // Encodes in 3 bytes
 8005580:	f5b6 1f00 	cmp.w	r6, #2097152	@ 0x200000
        *--pStartPacket = (U8)((EventId >>  7) | 0x80);
 8005584:	f041 0180 	orr.w	r1, r1, #128	@ 0x80
        *--pStartPacket = (U8)(EventId >> 14);
 8005588:	f3c6 3087 	ubfx	r0, r6, #14, #8
      } else if (EventId < (1ul << 21)) {    // Encodes in 3 bytes
 800558c:	d207      	bcs.n	800559e <_SendPacket+0x182>
        *--pStartPacket = (U8)((EventId >>  7) | 0x80);
 800558e:	f802 1c02 	strb.w	r1, [r2, #-2]
        *--pStartPacket = (U8)(EventId >> 14);
 8005592:	f802 0c01 	strb.w	r0, [r2, #-1]
        *--pStartPacket = (U8)(EventId | 0x80);
 8005596:	1ed1      	subs	r1, r2, #3
 8005598:	f802 3c03 	strb.w	r3, [r2, #-3]
 800559c:	e77a      	b.n	8005494 <_SendPacket+0x78>
      } else if (EventId < (1ul << 28)) {    // Encodes in 4 bytes
 800559e:	f1b6 5f80 	cmp.w	r6, #268435456	@ 0x10000000
        *--pStartPacket = (U8)((EventId >> 14) | 0x80);
 80055a2:	f040 0080 	orr.w	r0, r0, #128	@ 0x80
        *--pStartPacket = (U8)(EventId >> 21);
 80055a6:	f3c6 5747 	ubfx	r7, r6, #21, #8
      } else if (EventId < (1ul << 28)) {    // Encodes in 4 bytes
 80055aa:	d215      	bcs.n	80055d8 <_SendPacket+0x1bc>
        *--pStartPacket = (U8)(EventId | 0x80);
 80055ac:	2600      	movs	r6, #0
 80055ae:	f363 0607 	bfi	r6, r3, #0, #8
 80055b2:	f361 260f 	bfi	r6, r1, #8, #8
 80055b6:	f360 4617 	bfi	r6, r0, #16, #8
 80055ba:	f367 661f 	bfi	r6, r7, #24, #8
 80055be:	f842 6c04 	str.w	r6, [r2, #-4]
 80055c2:	1f11      	subs	r1, r2, #4
 80055c4:	e766      	b.n	8005494 <_SendPacket+0x78>
      *--pStartPacket = (U8)NumBytes;
 80055c6:	f807 3c01 	strb.w	r3, [r7, #-1]
 80055ca:	1e7a      	subs	r2, r7, #1
    if (EventId < 127) {
 80055cc:	e748      	b.n	8005460 <_SendPacket+0x44>
    _SYSVIEW_Globals.DropCount++;
 80055ce:	696b      	ldr	r3, [r5, #20]
 80055d0:	3301      	adds	r3, #1
 80055d2:	616b      	str	r3, [r5, #20]
    if (_SYSVIEW_Globals.EnableState != 1) {
 80055d4:	782b      	ldrb	r3, [r5, #0]
 80055d6:	e7cc      	b.n	8005572 <_SendPacket+0x156>
        *--pStartPacket = (U8)(EventId >> 28);
 80055d8:	0f36      	lsrs	r6, r6, #28
        *--pStartPacket = (U8)((EventId >> 21) | 0x80);
 80055da:	f067 077f 	orn	r7, r7, #127	@ 0x7f
        *--pStartPacket = (U8)((EventId >>  7) | 0x80);
 80055de:	f802 1c04 	strb.w	r1, [r2, #-4]
        *--pStartPacket = (U8)((EventId >> 14) | 0x80);
 80055e2:	f802 0c03 	strb.w	r0, [r2, #-3]
        *--pStartPacket = (U8)(EventId | 0x80);
 80055e6:	f802 3c05 	strb.w	r3, [r2, #-5]
        *--pStartPacket = (U8)(EventId >> 28);
 80055ea:	f802 6c01 	strb.w	r6, [r2, #-1]
        *--pStartPacket = (U8)((EventId >> 21) | 0x80);
 80055ee:	f802 7c02 	strb.w	r7, [r2, #-2]
        *--pStartPacket = (U8)(EventId | 0x80);
 80055f2:	1f51      	subs	r1, r2, #5
 80055f4:	e74e      	b.n	8005494 <_SendPacket+0x78>
 80055f6:	bf00      	nop
 80055f8:	20001a1c 	.word	0x20001a1c
 80055fc:	e0001000 	.word	0xe0001000
 8005600:	2000188c 	.word	0x2000188c

08005604 <SEGGER_SYSVIEW_RecordU32>:
void SEGGER_SYSVIEW_RecordU32(unsigned int EventID, U32 Value) {
 8005604:	4602      	mov	r2, r0
 8005606:	460b      	mov	r3, r1
 8005608:	b510      	push	{r4, lr}
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
 800560a:	f3ef 8411 	mrs	r4, BASEPRI
 800560e:	f04f 0120 	mov.w	r1, #32
 8005612:	f381 8811 	msr	BASEPRI, r1
  ENCODE_U32(pPayload, Value);
 8005616:	2b7f      	cmp	r3, #127	@ 0x7f
 8005618:	4908      	ldr	r1, [pc, #32]	@ (800563c <SEGGER_SYSVIEW_RecordU32+0x38>)
 800561a:	d906      	bls.n	800562a <SEGGER_SYSVIEW_RecordU32+0x26>
 800561c:	f063 0c7f 	orn	ip, r3, #127	@ 0x7f
 8005620:	09db      	lsrs	r3, r3, #7
 8005622:	2b7f      	cmp	r3, #127	@ 0x7f
 8005624:	f801 cb01 	strb.w	ip, [r1], #1
 8005628:	d8f8      	bhi.n	800561c <SEGGER_SYSVIEW_RecordU32+0x18>
  _SendPacket(pPayloadStart, pPayload, EventID);
 800562a:	4804      	ldr	r0, [pc, #16]	@ (800563c <SEGGER_SYSVIEW_RecordU32+0x38>)
  ENCODE_U32(pPayload, Value);
 800562c:	f801 3b01 	strb.w	r3, [r1], #1
  _SendPacket(pPayloadStart, pPayload, EventID);
 8005630:	f7ff fef4 	bl	800541c <_SendPacket>
  RECORD_END();
 8005634:	f384 8811 	msr	BASEPRI, r4
}
 8005638:	bd10      	pop	{r4, pc}
 800563a:	bf00      	nop
 800563c:	2000193b 	.word	0x2000193b

08005640 <SEGGER_SYSVIEW_RecordU32x2>:
void SEGGER_SYSVIEW_RecordU32x2(unsigned int EventID, U32 Para0, U32 Para1) {
 8005640:	4613      	mov	r3, r2
 8005642:	468c      	mov	ip, r1
 8005644:	4602      	mov	r2, r0
 8005646:	b510      	push	{r4, lr}
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32);
 8005648:	f3ef 8411 	mrs	r4, BASEPRI
 800564c:	f04f 0120 	mov.w	r1, #32
 8005650:	f381 8811 	msr	BASEPRI, r1
  ENCODE_U32(pPayload, Para0);
 8005654:	f1bc 0f7f 	cmp.w	ip, #127	@ 0x7f
 8005658:	490e      	ldr	r1, [pc, #56]	@ (8005694 <SEGGER_SYSVIEW_RecordU32x2+0x54>)
 800565a:	d90f      	bls.n	800567c <SEGGER_SYSVIEW_RecordU32x2+0x3c>
 800565c:	f06c 0e7f 	orn	lr, ip, #127	@ 0x7f
 8005660:	ea4f 1cdc 	mov.w	ip, ip, lsr #7
 8005664:	f1bc 0f7f 	cmp.w	ip, #127	@ 0x7f
 8005668:	f801 eb01 	strb.w	lr, [r1], #1
 800566c:	d8f6      	bhi.n	800565c <SEGGER_SYSVIEW_RecordU32x2+0x1c>
  ENCODE_U32(pPayload, Para1);
 800566e:	2b7f      	cmp	r3, #127	@ 0x7f
 8005670:	f801 cb01 	strb.w	ip, [r1], #1
 8005674:	d906      	bls.n	8005684 <SEGGER_SYSVIEW_RecordU32x2+0x44>
 8005676:	f063 0c7f 	orn	ip, r3, #127	@ 0x7f
 800567a:	09db      	lsrs	r3, r3, #7
 800567c:	2b7f      	cmp	r3, #127	@ 0x7f
 800567e:	f801 cb01 	strb.w	ip, [r1], #1
 8005682:	d8f8      	bhi.n	8005676 <SEGGER_SYSVIEW_RecordU32x2+0x36>
  _SendPacket(pPayloadStart, pPayload, EventID);
 8005684:	4803      	ldr	r0, [pc, #12]	@ (8005694 <SEGGER_SYSVIEW_RecordU32x2+0x54>)
  ENCODE_U32(pPayload, Para1);
 8005686:	f801 3b01 	strb.w	r3, [r1], #1
  _SendPacket(pPayloadStart, pPayload, EventID);
 800568a:	f7ff fec7 	bl	800541c <_SendPacket>
  RECORD_END();
 800568e:	f384 8811 	msr	BASEPRI, r4
}
 8005692:	bd10      	pop	{r4, pc}
 8005694:	2000193b 	.word	0x2000193b

08005698 <SEGGER_SYSVIEW_RecordU32x3>:
void SEGGER_SYSVIEW_RecordU32x3(unsigned int EventID, U32 Para0, U32 Para1, U32 Para2) {
 8005698:	4694      	mov	ip, r2
 800569a:	b510      	push	{r4, lr}
 800569c:	4602      	mov	r2, r0
 800569e:	468e      	mov	lr, r1
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 3 * SEGGER_SYSVIEW_QUANTA_U32);
 80056a0:	f3ef 8411 	mrs	r4, BASEPRI
 80056a4:	f04f 0120 	mov.w	r1, #32
 80056a8:	f381 8811 	msr	BASEPRI, r1
  ENCODE_U32(pPayload, Para0);
 80056ac:	f1be 0f7f 	cmp.w	lr, #127	@ 0x7f
 80056b0:	4915      	ldr	r1, [pc, #84]	@ (8005708 <SEGGER_SYSVIEW_RecordU32x3+0x70>)
 80056b2:	d911      	bls.n	80056d8 <SEGGER_SYSVIEW_RecordU32x3+0x40>
 80056b4:	f06e 007f 	orn	r0, lr, #127	@ 0x7f
 80056b8:	ea4f 1ede 	mov.w	lr, lr, lsr #7
 80056bc:	f1be 0f7f 	cmp.w	lr, #127	@ 0x7f
 80056c0:	f801 0b01 	strb.w	r0, [r1], #1
 80056c4:	d8f6      	bhi.n	80056b4 <SEGGER_SYSVIEW_RecordU32x3+0x1c>
  ENCODE_U32(pPayload, Para1);
 80056c6:	f1bc 0f7f 	cmp.w	ip, #127	@ 0x7f
 80056ca:	f801 eb01 	strb.w	lr, [r1], #1
 80056ce:	d90f      	bls.n	80056f0 <SEGGER_SYSVIEW_RecordU32x3+0x58>
 80056d0:	f06c 0e7f 	orn	lr, ip, #127	@ 0x7f
 80056d4:	ea4f 1cdc 	mov.w	ip, ip, lsr #7
 80056d8:	f1bc 0f7f 	cmp.w	ip, #127	@ 0x7f
 80056dc:	f801 eb01 	strb.w	lr, [r1], #1
 80056e0:	d8f6      	bhi.n	80056d0 <SEGGER_SYSVIEW_RecordU32x3+0x38>
  ENCODE_U32(pPayload, Para2);
 80056e2:	2b7f      	cmp	r3, #127	@ 0x7f
 80056e4:	f801 cb01 	strb.w	ip, [r1], #1
 80056e8:	d906      	bls.n	80056f8 <SEGGER_SYSVIEW_RecordU32x3+0x60>
 80056ea:	f063 0c7f 	orn	ip, r3, #127	@ 0x7f
 80056ee:	09db      	lsrs	r3, r3, #7
 80056f0:	2b7f      	cmp	r3, #127	@ 0x7f
 80056f2:	f801 cb01 	strb.w	ip, [r1], #1
 80056f6:	d8f8      	bhi.n	80056ea <SEGGER_SYSVIEW_RecordU32x3+0x52>
  _SendPacket(pPayloadStart, pPayload, EventID);
 80056f8:	4803      	ldr	r0, [pc, #12]	@ (8005708 <SEGGER_SYSVIEW_RecordU32x3+0x70>)
  ENCODE_U32(pPayload, Para2);
 80056fa:	f801 3b01 	strb.w	r3, [r1], #1
  _SendPacket(pPayloadStart, pPayload, EventID);
 80056fe:	f7ff fe8d 	bl	800541c <_SendPacket>
  RECORD_END();
 8005702:	f384 8811 	msr	BASEPRI, r4
}
 8005706:	bd10      	pop	{r4, pc}
 8005708:	2000193b 	.word	0x2000193b

0800570c <SEGGER_SYSVIEW_RecordU32x4>:
void SEGGER_SYSVIEW_RecordU32x4(unsigned int EventID, U32 Para0, U32 Para1, U32 Para2, U32 Para3) {
 800570c:	b538      	push	{r3, r4, r5, lr}
 800570e:	4694      	mov	ip, r2
 8005710:	468e      	mov	lr, r1
 8005712:	4602      	mov	r2, r0
 8005714:	9c04      	ldr	r4, [sp, #16]
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 4 * SEGGER_SYSVIEW_QUANTA_U32);
 8005716:	f3ef 8511 	mrs	r5, BASEPRI
 800571a:	f04f 0120 	mov.w	r1, #32
 800571e:	f381 8811 	msr	BASEPRI, r1
  ENCODE_U32(pPayload, Para0);
 8005722:	f1be 0f7f 	cmp.w	lr, #127	@ 0x7f
 8005726:	491b      	ldr	r1, [pc, #108]	@ (8005794 <SEGGER_SYSVIEW_RecordU32x4+0x88>)
 8005728:	d908      	bls.n	800573c <SEGGER_SYSVIEW_RecordU32x4+0x30>
 800572a:	f06e 007f 	orn	r0, lr, #127	@ 0x7f
 800572e:	ea4f 1ede 	mov.w	lr, lr, lsr #7
 8005732:	f1be 0f7f 	cmp.w	lr, #127	@ 0x7f
 8005736:	f801 0b01 	strb.w	r0, [r1], #1
 800573a:	d8f6      	bhi.n	800572a <SEGGER_SYSVIEW_RecordU32x4+0x1e>
  ENCODE_U32(pPayload, Para1);
 800573c:	f1bc 0f7f 	cmp.w	ip, #127	@ 0x7f
  ENCODE_U32(pPayload, Para0);
 8005740:	f801 eb01 	strb.w	lr, [r1], #1
  ENCODE_U32(pPayload, Para1);
 8005744:	d908      	bls.n	8005758 <SEGGER_SYSVIEW_RecordU32x4+0x4c>
 8005746:	f06c 007f 	orn	r0, ip, #127	@ 0x7f
 800574a:	ea4f 1cdc 	mov.w	ip, ip, lsr #7
 800574e:	f1bc 0f7f 	cmp.w	ip, #127	@ 0x7f
 8005752:	f801 0b01 	strb.w	r0, [r1], #1
 8005756:	d8f6      	bhi.n	8005746 <SEGGER_SYSVIEW_RecordU32x4+0x3a>
  ENCODE_U32(pPayload, Para2);
 8005758:	2b7f      	cmp	r3, #127	@ 0x7f
  ENCODE_U32(pPayload, Para1);
 800575a:	f801 cb01 	strb.w	ip, [r1], #1
  ENCODE_U32(pPayload, Para2);
 800575e:	d90d      	bls.n	800577c <SEGGER_SYSVIEW_RecordU32x4+0x70>
 8005760:	f063 007f 	orn	r0, r3, #127	@ 0x7f
 8005764:	09db      	lsrs	r3, r3, #7
 8005766:	2b7f      	cmp	r3, #127	@ 0x7f
 8005768:	f801 0b01 	strb.w	r0, [r1], #1
 800576c:	d8f8      	bhi.n	8005760 <SEGGER_SYSVIEW_RecordU32x4+0x54>
  ENCODE_U32(pPayload, Para3);
 800576e:	2c7f      	cmp	r4, #127	@ 0x7f
 8005770:	f801 3b01 	strb.w	r3, [r1], #1
 8005774:	d906      	bls.n	8005784 <SEGGER_SYSVIEW_RecordU32x4+0x78>
 8005776:	f064 037f 	orn	r3, r4, #127	@ 0x7f
 800577a:	09e4      	lsrs	r4, r4, #7
 800577c:	2c7f      	cmp	r4, #127	@ 0x7f
 800577e:	f801 3b01 	strb.w	r3, [r1], #1
 8005782:	d8f8      	bhi.n	8005776 <SEGGER_SYSVIEW_RecordU32x4+0x6a>
  _SendPacket(pPayloadStart, pPayload, EventID);
 8005784:	4803      	ldr	r0, [pc, #12]	@ (8005794 <SEGGER_SYSVIEW_RecordU32x4+0x88>)
  ENCODE_U32(pPayload, Para3);
 8005786:	f801 4b01 	strb.w	r4, [r1], #1
  _SendPacket(pPayloadStart, pPayload, EventID);
 800578a:	f7ff fe47 	bl	800541c <_SendPacket>
  RECORD_END();
 800578e:	f385 8811 	msr	BASEPRI, r5
}
 8005792:	bd38      	pop	{r3, r4, r5, pc}
 8005794:	2000193b 	.word	0x2000193b

08005798 <SEGGER_SYSVIEW_GetSysDesc>:
void SEGGER_SYSVIEW_GetSysDesc(void) {
 8005798:	b570      	push	{r4, r5, r6, lr}
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 4 * SEGGER_SYSVIEW_QUANTA_U32);
 800579a:	f3ef 8511 	mrs	r5, BASEPRI
 800579e:	f04f 0120 	mov.w	r1, #32
 80057a2:	f381 8811 	msr	BASEPRI, r1
  ENCODE_U32(pPayload, _SYSVIEW_Globals.SysFreq);
 80057a6:	4c1b      	ldr	r4, [pc, #108]	@ (8005814 <SEGGER_SYSVIEW_GetSysDesc+0x7c>)
 80057a8:	4b1b      	ldr	r3, [pc, #108]	@ (8005818 <SEGGER_SYSVIEW_GetSysDesc+0x80>)
 80057aa:	6862      	ldr	r2, [r4, #4]
 80057ac:	2a7f      	cmp	r2, #127	@ 0x7f
 80057ae:	d906      	bls.n	80057be <SEGGER_SYSVIEW_GetSysDesc+0x26>
 80057b0:	f062 017f 	orn	r1, r2, #127	@ 0x7f
 80057b4:	09d2      	lsrs	r2, r2, #7
 80057b6:	2a7f      	cmp	r2, #127	@ 0x7f
 80057b8:	f803 1b01 	strb.w	r1, [r3], #1
 80057bc:	d8f8      	bhi.n	80057b0 <SEGGER_SYSVIEW_GetSysDesc+0x18>
  ENCODE_U32(pPayload, _SYSVIEW_Globals.CPUFreq);
 80057be:	68a1      	ldr	r1, [r4, #8]
  ENCODE_U32(pPayload, _SYSVIEW_Globals.SysFreq);
 80057c0:	f803 2b01 	strb.w	r2, [r3], #1
  ENCODE_U32(pPayload, _SYSVIEW_Globals.CPUFreq);
 80057c4:	297f      	cmp	r1, #127	@ 0x7f
 80057c6:	d906      	bls.n	80057d6 <SEGGER_SYSVIEW_GetSysDesc+0x3e>
 80057c8:	f061 027f 	orn	r2, r1, #127	@ 0x7f
 80057cc:	09c9      	lsrs	r1, r1, #7
 80057ce:	297f      	cmp	r1, #127	@ 0x7f
 80057d0:	f803 2b01 	strb.w	r2, [r3], #1
 80057d4:	d8f8      	bhi.n	80057c8 <SEGGER_SYSVIEW_GetSysDesc+0x30>
  ENCODE_U32(pPayload, _SYSVIEW_Globals.RAMBaseAddress);
 80057d6:	6922      	ldr	r2, [r4, #16]
  ENCODE_U32(pPayload, _SYSVIEW_Globals.CPUFreq);
 80057d8:	f803 1b01 	strb.w	r1, [r3], #1
  ENCODE_U32(pPayload, _SYSVIEW_Globals.RAMBaseAddress);
 80057dc:	2a7f      	cmp	r2, #127	@ 0x7f
 80057de:	d906      	bls.n	80057ee <SEGGER_SYSVIEW_GetSysDesc+0x56>
 80057e0:	f062 017f 	orn	r1, r2, #127	@ 0x7f
 80057e4:	09d2      	lsrs	r2, r2, #7
 80057e6:	2a7f      	cmp	r2, #127	@ 0x7f
 80057e8:	f803 1b01 	strb.w	r1, [r3], #1
 80057ec:	d8f8      	bhi.n	80057e0 <SEGGER_SYSVIEW_GetSysDesc+0x48>
  ENCODE_U32(pPayload, SEGGER_SYSVIEW_ID_SHIFT);
 80057ee:	f04f 0c00 	mov.w	ip, #0
  ENCODE_U32(pPayload, _SYSVIEW_Globals.RAMBaseAddress);
 80057f2:	701a      	strb	r2, [r3, #0]
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_INIT);
 80057f4:	4808      	ldr	r0, [pc, #32]	@ (8005818 <SEGGER_SYSVIEW_GetSysDesc+0x80>)
 80057f6:	2218      	movs	r2, #24
 80057f8:	1c99      	adds	r1, r3, #2
  ENCODE_U32(pPayload, SEGGER_SYSVIEW_ID_SHIFT);
 80057fa:	f883 c001 	strb.w	ip, [r3, #1]
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_INIT);
 80057fe:	f7ff fe0d 	bl	800541c <_SendPacket>
  RECORD_END();
 8005802:	f385 8811 	msr	BASEPRI, r5
  if (_SYSVIEW_Globals.pfSendSysDesc) {
 8005806:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 8005808:	b113      	cbz	r3, 8005810 <SEGGER_SYSVIEW_GetSysDesc+0x78>
}
 800580a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    _SYSVIEW_Globals.pfSendSysDesc();
 800580e:	4718      	bx	r3
}
 8005810:	bd70      	pop	{r4, r5, r6, pc}
 8005812:	bf00      	nop
 8005814:	20001a1c 	.word	0x20001a1c
 8005818:	2000193b 	.word	0x2000193b

0800581c <SEGGER_SYSVIEW_SendTaskInfo>:
void SEGGER_SYSVIEW_SendTaskInfo(const SEGGER_SYSVIEW_TASKINFO *pInfo) {
 800581c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8005820:	4606      	mov	r6, r0
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32 + 1 + 32);
 8005822:	f3ef 8511 	mrs	r5, BASEPRI
 8005826:	f04f 0120 	mov.w	r1, #32
 800582a:	f381 8811 	msr	BASEPRI, r1
  ENCODE_U32(pPayload, SHRINK_ID(pInfo->TaskID));
 800582e:	4f3c      	ldr	r7, [pc, #240]	@ (8005920 <SEGGER_SYSVIEW_SendTaskInfo+0x104>)
 8005830:	6802      	ldr	r2, [r0, #0]
 8005832:	693b      	ldr	r3, [r7, #16]
 8005834:	4c3b      	ldr	r4, [pc, #236]	@ (8005924 <SEGGER_SYSVIEW_SendTaskInfo+0x108>)
 8005836:	1ad2      	subs	r2, r2, r3
 8005838:	2a7f      	cmp	r2, #127	@ 0x7f
 800583a:	4623      	mov	r3, r4
 800583c:	d906      	bls.n	800584c <SEGGER_SYSVIEW_SendTaskInfo+0x30>
 800583e:	f062 017f 	orn	r1, r2, #127	@ 0x7f
 8005842:	09d2      	lsrs	r2, r2, #7
 8005844:	2a7f      	cmp	r2, #127	@ 0x7f
 8005846:	f803 1b01 	strb.w	r1, [r3], #1
 800584a:	d8f8      	bhi.n	800583e <SEGGER_SYSVIEW_SendTaskInfo+0x22>
 800584c:	f803 2b01 	strb.w	r2, [r3], #1
  ENCODE_U32(pPayload, pInfo->Prio);
 8005850:	68b2      	ldr	r2, [r6, #8]
 8005852:	2a7f      	cmp	r2, #127	@ 0x7f
 8005854:	d906      	bls.n	8005864 <SEGGER_SYSVIEW_SendTaskInfo+0x48>
 8005856:	f062 017f 	orn	r1, r2, #127	@ 0x7f
 800585a:	09d2      	lsrs	r2, r2, #7
 800585c:	2a7f      	cmp	r2, #127	@ 0x7f
 800585e:	f803 1b01 	strb.w	r1, [r3], #1
 8005862:	d8f8      	bhi.n	8005856 <SEGGER_SYSVIEW_SendTaskInfo+0x3a>
 8005864:	469c      	mov	ip, r3
 8005866:	f80c 2b02 	strb.w	r2, [ip], #2
  pPayload = _EncodeStr(pPayload, pInfo->sName, 32);
 800586a:	f8d6 8004 	ldr.w	r8, [r6, #4]
  if (pText == NULL) {
 800586e:	f1b8 0f00 	cmp.w	r8, #0
 8005872:	d010      	beq.n	8005896 <SEGGER_SYSVIEW_SendTaskInfo+0x7a>
 8005874:	4640      	mov	r0, r8
 8005876:	f108 0e20 	add.w	lr, r8, #32
 800587a:	e003      	b.n	8005884 <SEGGER_SYSVIEW_SendTaskInfo+0x68>
    while ((Limit-- > 0) && (*pText != '\0')) {
 800587c:	4570      	cmp	r0, lr
      *pPayload++ = *pText++;
 800587e:	f80c 1b01 	strb.w	r1, [ip], #1
    while ((Limit-- > 0) && (*pText != '\0')) {
 8005882:	d04a      	beq.n	800591a <SEGGER_SYSVIEW_SendTaskInfo+0xfe>
 8005884:	7801      	ldrb	r1, [r0, #0]
 8005886:	4602      	mov	r2, r0
 8005888:	3001      	adds	r0, #1
 800588a:	2900      	cmp	r1, #0
 800588c:	d1f6      	bne.n	800587c <SEGGER_SYSVIEW_SendTaskInfo+0x60>
    *pLen = (U8)(pText - sStart);
 800588e:	eba2 0208 	sub.w	r2, r2, r8
 8005892:	fa5f f882 	uxtb.w	r8, r2
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_TASK_INFO);
 8005896:	4661      	mov	r1, ip
 8005898:	2209      	movs	r2, #9
    *pPayload++ = (U8)0;
 800589a:	f883 8001 	strb.w	r8, [r3, #1]
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_TASK_INFO);
 800589e:	4821      	ldr	r0, [pc, #132]	@ (8005924 <SEGGER_SYSVIEW_SendTaskInfo+0x108>)
 80058a0:	f7ff fdbc 	bl	800541c <_SendPacket>
  ENCODE_U32(pPayload, SHRINK_ID(pInfo->TaskID));
 80058a4:	6833      	ldr	r3, [r6, #0]
 80058a6:	693a      	ldr	r2, [r7, #16]
 80058a8:	4621      	mov	r1, r4
 80058aa:	1a9b      	subs	r3, r3, r2
 80058ac:	2b7f      	cmp	r3, #127	@ 0x7f
 80058ae:	d906      	bls.n	80058be <SEGGER_SYSVIEW_SendTaskInfo+0xa2>
 80058b0:	f063 027f 	orn	r2, r3, #127	@ 0x7f
 80058b4:	09db      	lsrs	r3, r3, #7
 80058b6:	2b7f      	cmp	r3, #127	@ 0x7f
 80058b8:	f801 2b01 	strb.w	r2, [r1], #1
 80058bc:	d8f8      	bhi.n	80058b0 <SEGGER_SYSVIEW_SendTaskInfo+0x94>
 80058be:	f801 3b01 	strb.w	r3, [r1], #1
  ENCODE_U32(pPayload, pInfo->StackBase);
 80058c2:	68f3      	ldr	r3, [r6, #12]
 80058c4:	2b7f      	cmp	r3, #127	@ 0x7f
 80058c6:	d906      	bls.n	80058d6 <SEGGER_SYSVIEW_SendTaskInfo+0xba>
 80058c8:	f063 027f 	orn	r2, r3, #127	@ 0x7f
 80058cc:	09db      	lsrs	r3, r3, #7
 80058ce:	2b7f      	cmp	r3, #127	@ 0x7f
 80058d0:	f801 2b01 	strb.w	r2, [r1], #1
 80058d4:	d8f8      	bhi.n	80058c8 <SEGGER_SYSVIEW_SendTaskInfo+0xac>
 80058d6:	f801 3b01 	strb.w	r3, [r1], #1
  ENCODE_U32(pPayload, pInfo->StackSize);
 80058da:	6933      	ldr	r3, [r6, #16]
 80058dc:	2b7f      	cmp	r3, #127	@ 0x7f
 80058de:	d906      	bls.n	80058ee <SEGGER_SYSVIEW_SendTaskInfo+0xd2>
 80058e0:	f063 027f 	orn	r2, r3, #127	@ 0x7f
 80058e4:	09db      	lsrs	r3, r3, #7
 80058e6:	2b7f      	cmp	r3, #127	@ 0x7f
 80058e8:	f801 2b01 	strb.w	r2, [r1], #1
 80058ec:	d8f8      	bhi.n	80058e0 <SEGGER_SYSVIEW_SendTaskInfo+0xc4>
 80058ee:	f801 3b01 	strb.w	r3, [r1], #1
  ENCODE_U32(pPayload, pInfo->StackUsage);
 80058f2:	6973      	ldr	r3, [r6, #20]
 80058f4:	2b7f      	cmp	r3, #127	@ 0x7f
 80058f6:	d906      	bls.n	8005906 <SEGGER_SYSVIEW_SendTaskInfo+0xea>
 80058f8:	f063 027f 	orn	r2, r3, #127	@ 0x7f
 80058fc:	09db      	lsrs	r3, r3, #7
 80058fe:	2b7f      	cmp	r3, #127	@ 0x7f
 8005900:	f801 2b01 	strb.w	r2, [r1], #1
 8005904:	d8f8      	bhi.n	80058f8 <SEGGER_SYSVIEW_SendTaskInfo+0xdc>
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_STACK_INFO);
 8005906:	2215      	movs	r2, #21
 8005908:	4806      	ldr	r0, [pc, #24]	@ (8005924 <SEGGER_SYSVIEW_SendTaskInfo+0x108>)
  ENCODE_U32(pPayload, pInfo->StackUsage);
 800590a:	f801 3b01 	strb.w	r3, [r1], #1
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_STACK_INFO);
 800590e:	f7ff fd85 	bl	800541c <_SendPacket>
  RECORD_END();
 8005912:	f385 8811 	msr	BASEPRI, r5
}
 8005916:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      *pPayload++ = *pText++;
 800591a:	4602      	mov	r2, r0
 800591c:	e7b7      	b.n	800588e <SEGGER_SYSVIEW_SendTaskInfo+0x72>
 800591e:	bf00      	nop
 8005920:	20001a1c 	.word	0x20001a1c
 8005924:	2000193b 	.word	0x2000193b

08005928 <SEGGER_SYSVIEW_SendSysDesc>:
void SEGGER_SYSVIEW_SendSysDesc(const char *sSysDesc) {
 8005928:	b538      	push	{r3, r4, r5, lr}
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 1 + SEGGER_SYSVIEW_MAX_STRING_LEN);
 800592a:	f3ef 8511 	mrs	r5, BASEPRI
 800592e:	f04f 0120 	mov.w	r1, #32
 8005932:	f381 8811 	msr	BASEPRI, r1
  if (pText == NULL) {
 8005936:	b1d0      	cbz	r0, 800596e <SEGGER_SYSVIEW_SendSysDesc+0x46>
 8005938:	4602      	mov	r2, r0
 800593a:	490e      	ldr	r1, [pc, #56]	@ (8005974 <SEGGER_SYSVIEW_SendSysDesc+0x4c>)
 800593c:	f100 0c80 	add.w	ip, r0, #128	@ 0x80
 8005940:	e003      	b.n	800594a <SEGGER_SYSVIEW_SendSysDesc+0x22>
    while ((Limit-- > 0) && (*pText != '\0')) {
 8005942:	4562      	cmp	r2, ip
      *pPayload++ = *pText++;
 8005944:	f801 4b01 	strb.w	r4, [r1], #1
    while ((Limit-- > 0) && (*pText != '\0')) {
 8005948:	d00f      	beq.n	800596a <SEGGER_SYSVIEW_SendSysDesc+0x42>
 800594a:	7814      	ldrb	r4, [r2, #0]
 800594c:	4613      	mov	r3, r2
 800594e:	3201      	adds	r2, #1
 8005950:	2c00      	cmp	r4, #0
 8005952:	d1f6      	bne.n	8005942 <SEGGER_SYSVIEW_SendSysDesc+0x1a>
    *pLen = (U8)(pText - sStart);
 8005954:	1a1b      	subs	r3, r3, r0
 8005956:	b2db      	uxtb	r3, r3
    *pPayload++ = (U8)0;
 8005958:	4807      	ldr	r0, [pc, #28]	@ (8005978 <SEGGER_SYSVIEW_SendSysDesc+0x50>)
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_SYSDESC);
 800595a:	220e      	movs	r2, #14
    *pPayload++ = (U8)0;
 800595c:	f800 3f07 	strb.w	r3, [r0, #7]!
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_SYSDESC);
 8005960:	f7ff fd5c 	bl	800541c <_SendPacket>
  RECORD_END();
 8005964:	f385 8811 	msr	BASEPRI, r5
}
 8005968:	bd38      	pop	{r3, r4, r5, pc}
      *pPayload++ = *pText++;
 800596a:	4613      	mov	r3, r2
 800596c:	e7f2      	b.n	8005954 <SEGGER_SYSVIEW_SendSysDesc+0x2c>
 800596e:	4603      	mov	r3, r0
    *pPayload++ = (U8)0;
 8005970:	4900      	ldr	r1, [pc, #0]	@ (8005974 <SEGGER_SYSVIEW_SendSysDesc+0x4c>)
 8005972:	e7f1      	b.n	8005958 <SEGGER_SYSVIEW_SendSysDesc+0x30>
 8005974:	2000193c 	.word	0x2000193c
 8005978:	20001934 	.word	0x20001934

0800597c <SEGGER_SYSVIEW_RecordEnterISR>:
void SEGGER_SYSVIEW_RecordEnterISR(void) {
 800597c:	b510      	push	{r4, lr}
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
 800597e:	f3ef 8411 	mrs	r4, BASEPRI
 8005982:	f04f 0120 	mov.w	r1, #32
 8005986:	f381 8811 	msr	BASEPRI, r1
  v = SEGGER_SYSVIEW_GET_INTERRUPT_ID();
 800598a:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 800598e:	f8d3 2d04 	ldr.w	r2, [r3, #3332]	@ 0xd04
  ENCODE_U32(pPayload, v);
 8005992:	f412 7fc0 	tst.w	r2, #384	@ 0x180
  v = SEGGER_SYSVIEW_GET_INTERRUPT_ID();
 8005996:	f3c2 0c08 	ubfx	ip, r2, #0, #9
  ENCODE_U32(pPayload, v);
 800599a:	d010      	beq.n	80059be <SEGGER_SYSVIEW_RecordEnterISR+0x42>
 800599c:	4909      	ldr	r1, [pc, #36]	@ (80059c4 <SEGGER_SYSVIEW_RecordEnterISR+0x48>)
 800599e:	b2d3      	uxtb	r3, r2
 80059a0:	f063 037f 	orn	r3, r3, #127	@ 0x7f
 80059a4:	71cb      	strb	r3, [r1, #7]
 80059a6:	ea4f 1cdc 	mov.w	ip, ip, lsr #7
 80059aa:	3108      	adds	r1, #8
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_ISR_ENTER);
 80059ac:	2202      	movs	r2, #2
 80059ae:	4806      	ldr	r0, [pc, #24]	@ (80059c8 <SEGGER_SYSVIEW_RecordEnterISR+0x4c>)
  ENCODE_U32(pPayload, v);
 80059b0:	f801 cb01 	strb.w	ip, [r1], #1
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_ISR_ENTER);
 80059b4:	f7ff fd32 	bl	800541c <_SendPacket>
  RECORD_END();
 80059b8:	f384 8811 	msr	BASEPRI, r4
}
 80059bc:	bd10      	pop	{r4, pc}
  ENCODE_U32(pPayload, v);
 80059be:	4902      	ldr	r1, [pc, #8]	@ (80059c8 <SEGGER_SYSVIEW_RecordEnterISR+0x4c>)
 80059c0:	e7f4      	b.n	80059ac <SEGGER_SYSVIEW_RecordEnterISR+0x30>
 80059c2:	bf00      	nop
 80059c4:	20001934 	.word	0x20001934
 80059c8:	2000193b 	.word	0x2000193b

080059cc <SEGGER_SYSVIEW_OnTaskCreate>:
void SEGGER_SYSVIEW_OnTaskCreate(U32 TaskId) {
 80059cc:	b510      	push	{r4, lr}
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
 80059ce:	f3ef 8411 	mrs	r4, BASEPRI
 80059d2:	f04f 0120 	mov.w	r1, #32
 80059d6:	f381 8811 	msr	BASEPRI, r1
  TaskId = SHRINK_ID(TaskId);
 80059da:	4b0b      	ldr	r3, [pc, #44]	@ (8005a08 <SEGGER_SYSVIEW_OnTaskCreate+0x3c>)
  ENCODE_U32(pPayload, TaskId);
 80059dc:	490b      	ldr	r1, [pc, #44]	@ (8005a0c <SEGGER_SYSVIEW_OnTaskCreate+0x40>)
  TaskId = SHRINK_ID(TaskId);
 80059de:	691b      	ldr	r3, [r3, #16]
 80059e0:	1ac3      	subs	r3, r0, r3
  ENCODE_U32(pPayload, TaskId);
 80059e2:	2b7f      	cmp	r3, #127	@ 0x7f
 80059e4:	d906      	bls.n	80059f4 <SEGGER_SYSVIEW_OnTaskCreate+0x28>
 80059e6:	f063 027f 	orn	r2, r3, #127	@ 0x7f
 80059ea:	09db      	lsrs	r3, r3, #7
 80059ec:	2b7f      	cmp	r3, #127	@ 0x7f
 80059ee:	f801 2b01 	strb.w	r2, [r1], #1
 80059f2:	d8f8      	bhi.n	80059e6 <SEGGER_SYSVIEW_OnTaskCreate+0x1a>
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_TASK_CREATE);
 80059f4:	2208      	movs	r2, #8
 80059f6:	4805      	ldr	r0, [pc, #20]	@ (8005a0c <SEGGER_SYSVIEW_OnTaskCreate+0x40>)
  ENCODE_U32(pPayload, TaskId);
 80059f8:	f801 3b01 	strb.w	r3, [r1], #1
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_TASK_CREATE);
 80059fc:	f7ff fd0e 	bl	800541c <_SendPacket>
  RECORD_END();
 8005a00:	f384 8811 	msr	BASEPRI, r4
}
 8005a04:	bd10      	pop	{r4, pc}
 8005a06:	bf00      	nop
 8005a08:	20001a1c 	.word	0x20001a1c
 8005a0c:	2000193b 	.word	0x2000193b

08005a10 <SEGGER_SYSVIEW_OnTaskStartExec>:
void SEGGER_SYSVIEW_OnTaskStartExec(U32 TaskId) {
 8005a10:	b510      	push	{r4, lr}
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
 8005a12:	f3ef 8411 	mrs	r4, BASEPRI
 8005a16:	f04f 0120 	mov.w	r1, #32
 8005a1a:	f381 8811 	msr	BASEPRI, r1
  TaskId = SHRINK_ID(TaskId);
 8005a1e:	4b0b      	ldr	r3, [pc, #44]	@ (8005a4c <SEGGER_SYSVIEW_OnTaskStartExec+0x3c>)
  ENCODE_U32(pPayload, TaskId);
 8005a20:	490b      	ldr	r1, [pc, #44]	@ (8005a50 <SEGGER_SYSVIEW_OnTaskStartExec+0x40>)
  TaskId = SHRINK_ID(TaskId);
 8005a22:	691b      	ldr	r3, [r3, #16]
 8005a24:	1ac3      	subs	r3, r0, r3
  ENCODE_U32(pPayload, TaskId);
 8005a26:	2b7f      	cmp	r3, #127	@ 0x7f
 8005a28:	d906      	bls.n	8005a38 <SEGGER_SYSVIEW_OnTaskStartExec+0x28>
 8005a2a:	f063 027f 	orn	r2, r3, #127	@ 0x7f
 8005a2e:	09db      	lsrs	r3, r3, #7
 8005a30:	2b7f      	cmp	r3, #127	@ 0x7f
 8005a32:	f801 2b01 	strb.w	r2, [r1], #1
 8005a36:	d8f8      	bhi.n	8005a2a <SEGGER_SYSVIEW_OnTaskStartExec+0x1a>
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_TASK_START_EXEC);
 8005a38:	2204      	movs	r2, #4
 8005a3a:	4805      	ldr	r0, [pc, #20]	@ (8005a50 <SEGGER_SYSVIEW_OnTaskStartExec+0x40>)
  ENCODE_U32(pPayload, TaskId);
 8005a3c:	f801 3b01 	strb.w	r3, [r1], #1
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_TASK_START_EXEC);
 8005a40:	f7ff fcec 	bl	800541c <_SendPacket>
  RECORD_END();
 8005a44:	f384 8811 	msr	BASEPRI, r4
}
 8005a48:	bd10      	pop	{r4, pc}
 8005a4a:	bf00      	nop
 8005a4c:	20001a1c 	.word	0x20001a1c
 8005a50:	2000193b 	.word	0x2000193b

08005a54 <SEGGER_SYSVIEW_OnTaskStartReady>:
void SEGGER_SYSVIEW_OnTaskStartReady(U32 TaskId) {
 8005a54:	b510      	push	{r4, lr}
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
 8005a56:	f3ef 8411 	mrs	r4, BASEPRI
 8005a5a:	f04f 0120 	mov.w	r1, #32
 8005a5e:	f381 8811 	msr	BASEPRI, r1
  TaskId = SHRINK_ID(TaskId);
 8005a62:	4b0b      	ldr	r3, [pc, #44]	@ (8005a90 <SEGGER_SYSVIEW_OnTaskStartReady+0x3c>)
  ENCODE_U32(pPayload, TaskId);
 8005a64:	490b      	ldr	r1, [pc, #44]	@ (8005a94 <SEGGER_SYSVIEW_OnTaskStartReady+0x40>)
  TaskId = SHRINK_ID(TaskId);
 8005a66:	691b      	ldr	r3, [r3, #16]
 8005a68:	1ac3      	subs	r3, r0, r3
  ENCODE_U32(pPayload, TaskId);
 8005a6a:	2b7f      	cmp	r3, #127	@ 0x7f
 8005a6c:	d906      	bls.n	8005a7c <SEGGER_SYSVIEW_OnTaskStartReady+0x28>
 8005a6e:	f063 027f 	orn	r2, r3, #127	@ 0x7f
 8005a72:	09db      	lsrs	r3, r3, #7
 8005a74:	2b7f      	cmp	r3, #127	@ 0x7f
 8005a76:	f801 2b01 	strb.w	r2, [r1], #1
 8005a7a:	d8f8      	bhi.n	8005a6e <SEGGER_SYSVIEW_OnTaskStartReady+0x1a>
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_TASK_START_READY);
 8005a7c:	2206      	movs	r2, #6
 8005a7e:	4805      	ldr	r0, [pc, #20]	@ (8005a94 <SEGGER_SYSVIEW_OnTaskStartReady+0x40>)
  ENCODE_U32(pPayload, TaskId);
 8005a80:	f801 3b01 	strb.w	r3, [r1], #1
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_TASK_START_READY);
 8005a84:	f7ff fcca 	bl	800541c <_SendPacket>
  RECORD_END();
 8005a88:	f384 8811 	msr	BASEPRI, r4
}
 8005a8c:	bd10      	pop	{r4, pc}
 8005a8e:	bf00      	nop
 8005a90:	20001a1c 	.word	0x20001a1c
 8005a94:	2000193b 	.word	0x2000193b

08005a98 <SEGGER_SYSVIEW_OnTaskStopReady>:
void SEGGER_SYSVIEW_OnTaskStopReady(U32 TaskId, unsigned int Cause) {
 8005a98:	460b      	mov	r3, r1
 8005a9a:	b510      	push	{r4, lr}
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32);
 8005a9c:	f3ef 8411 	mrs	r4, BASEPRI
 8005aa0:	f04f 0120 	mov.w	r1, #32
 8005aa4:	f381 8811 	msr	BASEPRI, r1
  TaskId = SHRINK_ID(TaskId);
 8005aa8:	4a10      	ldr	r2, [pc, #64]	@ (8005aec <SEGGER_SYSVIEW_OnTaskStopReady+0x54>)
  ENCODE_U32(pPayload, TaskId);
 8005aaa:	4911      	ldr	r1, [pc, #68]	@ (8005af0 <SEGGER_SYSVIEW_OnTaskStopReady+0x58>)
  TaskId = SHRINK_ID(TaskId);
 8005aac:	6912      	ldr	r2, [r2, #16]
 8005aae:	1a80      	subs	r0, r0, r2
  ENCODE_U32(pPayload, TaskId);
 8005ab0:	287f      	cmp	r0, #127	@ 0x7f
 8005ab2:	d906      	bls.n	8005ac2 <SEGGER_SYSVIEW_OnTaskStopReady+0x2a>
 8005ab4:	f060 027f 	orn	r2, r0, #127	@ 0x7f
 8005ab8:	09c0      	lsrs	r0, r0, #7
 8005aba:	287f      	cmp	r0, #127	@ 0x7f
 8005abc:	f801 2b01 	strb.w	r2, [r1], #1
 8005ac0:	d8f8      	bhi.n	8005ab4 <SEGGER_SYSVIEW_OnTaskStopReady+0x1c>
  ENCODE_U32(pPayload, Cause);
 8005ac2:	2b7f      	cmp	r3, #127	@ 0x7f
  ENCODE_U32(pPayload, TaskId);
 8005ac4:	f801 0b01 	strb.w	r0, [r1], #1
  ENCODE_U32(pPayload, Cause);
 8005ac8:	d906      	bls.n	8005ad8 <SEGGER_SYSVIEW_OnTaskStopReady+0x40>
 8005aca:	f063 027f 	orn	r2, r3, #127	@ 0x7f
 8005ace:	09db      	lsrs	r3, r3, #7
 8005ad0:	2b7f      	cmp	r3, #127	@ 0x7f
 8005ad2:	f801 2b01 	strb.w	r2, [r1], #1
 8005ad6:	d8f8      	bhi.n	8005aca <SEGGER_SYSVIEW_OnTaskStopReady+0x32>
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_TASK_STOP_READY);
 8005ad8:	2207      	movs	r2, #7
 8005ada:	4805      	ldr	r0, [pc, #20]	@ (8005af0 <SEGGER_SYSVIEW_OnTaskStopReady+0x58>)
  ENCODE_U32(pPayload, Cause);
 8005adc:	f801 3b01 	strb.w	r3, [r1], #1
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_TASK_STOP_READY);
 8005ae0:	f7ff fc9c 	bl	800541c <_SendPacket>
  RECORD_END();
 8005ae4:	f384 8811 	msr	BASEPRI, r4
}
 8005ae8:	bd10      	pop	{r4, pc}
 8005aea:	bf00      	nop
 8005aec:	20001a1c 	.word	0x20001a1c
 8005af0:	2000193b 	.word	0x2000193b

08005af4 <SEGGER_SYSVIEW_RecordSystime>:
  if (_SYSVIEW_Globals.pOSAPI && _SYSVIEW_Globals.pOSAPI->pfGetTime) {
 8005af4:	4b24      	ldr	r3, [pc, #144]	@ (8005b88 <SEGGER_SYSVIEW_RecordSystime+0x94>)
void SEGGER_SYSVIEW_RecordSystime(void) {
 8005af6:	b510      	push	{r4, lr}
  if (_SYSVIEW_Globals.pOSAPI && _SYSVIEW_Globals.pOSAPI->pfGetTime) {
 8005af8:	6a1b      	ldr	r3, [r3, #32]
 8005afa:	b34b      	cbz	r3, 8005b50 <SEGGER_SYSVIEW_RecordSystime+0x5c>
 8005afc:	681b      	ldr	r3, [r3, #0]
 8005afe:	b33b      	cbz	r3, 8005b50 <SEGGER_SYSVIEW_RecordSystime+0x5c>
    Systime = _SYSVIEW_Globals.pOSAPI->pfGetTime();
 8005b00:	4798      	blx	r3
 8005b02:	468c      	mov	ip, r1
    SEGGER_SYSVIEW_RecordU32x2(SYSVIEW_EVTID_SYSTIME_US,
 8005b04:	460b      	mov	r3, r1
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32);
 8005b06:	f3ef 8411 	mrs	r4, BASEPRI
 8005b0a:	f04f 0120 	mov.w	r1, #32
 8005b0e:	f381 8811 	msr	BASEPRI, r1
  ENCODE_U32(pPayload, Para0);
 8005b12:	287f      	cmp	r0, #127	@ 0x7f
 8005b14:	491d      	ldr	r1, [pc, #116]	@ (8005b8c <SEGGER_SYSVIEW_RecordSystime+0x98>)
 8005b16:	d906      	bls.n	8005b26 <SEGGER_SYSVIEW_RecordSystime+0x32>
 8005b18:	f060 027f 	orn	r2, r0, #127	@ 0x7f
 8005b1c:	09c0      	lsrs	r0, r0, #7
 8005b1e:	287f      	cmp	r0, #127	@ 0x7f
 8005b20:	f801 2b01 	strb.w	r2, [r1], #1
 8005b24:	d8f8      	bhi.n	8005b18 <SEGGER_SYSVIEW_RecordSystime+0x24>
  ENCODE_U32(pPayload, Para1);
 8005b26:	f1bc 0f7f 	cmp.w	ip, #127	@ 0x7f
  ENCODE_U32(pPayload, Para0);
 8005b2a:	f801 0b01 	strb.w	r0, [r1], #1
  ENCODE_U32(pPayload, Para1);
 8005b2e:	d906      	bls.n	8005b3e <SEGGER_SYSVIEW_RecordSystime+0x4a>
 8005b30:	f063 027f 	orn	r2, r3, #127	@ 0x7f
 8005b34:	09db      	lsrs	r3, r3, #7
 8005b36:	2b7f      	cmp	r3, #127	@ 0x7f
 8005b38:	f801 2b01 	strb.w	r2, [r1], #1
 8005b3c:	d8f8      	bhi.n	8005b30 <SEGGER_SYSVIEW_RecordSystime+0x3c>
  _SendPacket(pPayloadStart, pPayload, EventID);
 8005b3e:	220d      	movs	r2, #13
 8005b40:	4812      	ldr	r0, [pc, #72]	@ (8005b8c <SEGGER_SYSVIEW_RecordSystime+0x98>)
  ENCODE_U32(pPayload, Para1);
 8005b42:	f801 3b01 	strb.w	r3, [r1], #1
  _SendPacket(pPayloadStart, pPayload, EventID);
 8005b46:	f7ff fc69 	bl	800541c <_SendPacket>
  RECORD_END();
 8005b4a:	f384 8811 	msr	BASEPRI, r4
}
 8005b4e:	bd10      	pop	{r4, pc}
    SEGGER_SYSVIEW_RecordU32(SYSVIEW_EVTID_SYSTIME_CYCLES, SEGGER_SYSVIEW_GET_TIMESTAMP());
 8005b50:	4b0f      	ldr	r3, [pc, #60]	@ (8005b90 <SEGGER_SYSVIEW_RecordSystime+0x9c>)
 8005b52:	685b      	ldr	r3, [r3, #4]
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
 8005b54:	f3ef 8411 	mrs	r4, BASEPRI
 8005b58:	f04f 0120 	mov.w	r1, #32
 8005b5c:	f381 8811 	msr	BASEPRI, r1
  ENCODE_U32(pPayload, Value);
 8005b60:	2b7f      	cmp	r3, #127	@ 0x7f
 8005b62:	490a      	ldr	r1, [pc, #40]	@ (8005b8c <SEGGER_SYSVIEW_RecordSystime+0x98>)
 8005b64:	d906      	bls.n	8005b74 <SEGGER_SYSVIEW_RecordSystime+0x80>
 8005b66:	f063 027f 	orn	r2, r3, #127	@ 0x7f
 8005b6a:	09db      	lsrs	r3, r3, #7
 8005b6c:	2b7f      	cmp	r3, #127	@ 0x7f
 8005b6e:	f801 2b01 	strb.w	r2, [r1], #1
 8005b72:	d8f8      	bhi.n	8005b66 <SEGGER_SYSVIEW_RecordSystime+0x72>
  _SendPacket(pPayloadStart, pPayload, EventID);
 8005b74:	220c      	movs	r2, #12
 8005b76:	4805      	ldr	r0, [pc, #20]	@ (8005b8c <SEGGER_SYSVIEW_RecordSystime+0x98>)
  ENCODE_U32(pPayload, Value);
 8005b78:	f801 3b01 	strb.w	r3, [r1], #1
  _SendPacket(pPayloadStart, pPayload, EventID);
 8005b7c:	f7ff fc4e 	bl	800541c <_SendPacket>
  RECORD_END();
 8005b80:	f384 8811 	msr	BASEPRI, r4
}
 8005b84:	bd10      	pop	{r4, pc}
 8005b86:	bf00      	nop
 8005b88:	20001a1c 	.word	0x20001a1c
 8005b8c:	2000193b 	.word	0x2000193b
 8005b90:	e0001000 	.word	0xe0001000

08005b94 <_PrintUnsigned>:
static void _PrintUnsigned(SEGGER_SYSVIEW_PRINTF_DESC * pBufferDesc, unsigned int v, unsigned int Base, unsigned int NumDigits, unsigned int FieldWidth, unsigned int FormatFlags) {
 8005b94:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  while (Number >= Base) {
 8005b98:	4291      	cmp	r1, r2
static void _PrintUnsigned(SEGGER_SYSVIEW_PRINTF_DESC * pBufferDesc, unsigned int v, unsigned int Base, unsigned int NumDigits, unsigned int FieldWidth, unsigned int FormatFlags) {
 8005b9a:	b083      	sub	sp, #12
 8005b9c:	4689      	mov	r9, r1
 8005b9e:	e9dd b50c 	ldrd	fp, r5, [sp, #48]	@ 0x30
 8005ba2:	4614      	mov	r4, r2
 8005ba4:	4606      	mov	r6, r0
 8005ba6:	4698      	mov	r8, r3
  while (Number >= Base) {
 8005ba8:	f0c0 811d 	bcc.w	8005de6 <_PrintUnsigned+0x252>
  Number = v;
 8005bac:	460b      	mov	r3, r1
  Width = 1u;
 8005bae:	2701      	movs	r7, #1
    Number = (Number / Base);
 8005bb0:	fbb3 f3f4 	udiv	r3, r3, r4
  while (Number >= Base) {
 8005bb4:	429c      	cmp	r4, r3
    Width++;
 8005bb6:	f107 0701 	add.w	r7, r7, #1
  while (Number >= Base) {
 8005bba:	d9f9      	bls.n	8005bb0 <_PrintUnsigned+0x1c>
  if (NumDigits > Width) {
 8005bbc:	4547      	cmp	r7, r8
 8005bbe:	bf38      	it	cc
 8005bc0:	4647      	movcc	r7, r8
  if ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u) {
 8005bc2:	f015 0a01 	ands.w	sl, r5, #1
  Cnt = p->Cnt;
 8005bc6:	6931      	ldr	r1, [r6, #16]
  if ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u) {
 8005bc8:	d103      	bne.n	8005bd2 <_PrintUnsigned+0x3e>
    if (FieldWidth != 0u) {
 8005bca:	f1bb 0f00 	cmp.w	fp, #0
 8005bce:	f040 8081 	bne.w	8005cd4 <_PrintUnsigned+0x140>
 8005bd2:	1c4a      	adds	r2, r1, #1
    if (NumDigits > 1u) {       // User specified a min number of digits to print? => Make sure we loop at least that often, before checking anything else (> 1 check avoids problems with NumDigits being signed / unsigned)
 8005bd4:	f1b8 0f01 	cmp.w	r8, #1
      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
 8005bd8:	f04f 0501 	mov.w	r5, #1
    if (NumDigits > 1u) {       // User specified a min number of digits to print? => Make sure we loop at least that often, before checking anything else (> 1 check avoids problems with NumDigits being signed / unsigned)
 8005bdc:	d906      	bls.n	8005bec <_PrintUnsigned+0x58>
      NumDigits--;
 8005bde:	f108 38ff 	add.w	r8, r8, #4294967295
    if (NumDigits > 1u) {       // User specified a min number of digits to print? => Make sure we loop at least that often, before checking anything else (> 1 check avoids problems with NumDigits being signed / unsigned)
 8005be2:	f1b8 0f01 	cmp.w	r8, #1
    Digit *= Base;
 8005be6:	fb04 f505 	mul.w	r5, r4, r5
    if (NumDigits > 1u) {       // User specified a min number of digits to print? => Make sure we loop at least that often, before checking anything else (> 1 check avoids problems with NumDigits being signed / unsigned)
 8005bea:	d8f8      	bhi.n	8005bde <_PrintUnsigned+0x4a>
      Div = v / Digit;
 8005bec:	fbb9 f3f5 	udiv	r3, r9, r5
      if (Div < Base) {        // Is our divider big enough to extract the highest digit from value? => Done
 8005bf0:	42a3      	cmp	r3, r4
 8005bf2:	d305      	bcc.n	8005c00 <_PrintUnsigned+0x6c>
    Digit *= Base;
 8005bf4:	fb04 f505 	mul.w	r5, r4, r5
      Div = v / Digit;
 8005bf8:	fbb9 f3f5 	udiv	r3, r9, r5
      if (Div < Base) {        // Is our divider big enough to extract the highest digit from value? => Done
 8005bfc:	429c      	cmp	r4, r3
 8005bfe:	d9f9      	bls.n	8005bf4 <_PrintUnsigned+0x60>
  if ((Cnt + 1u) <= SEGGER_SYSVIEW_MAX_STRING_LEN) {
 8005c00:	2a80      	cmp	r2, #128	@ 0x80
 8005c02:	bf98      	it	ls
 8005c04:	4611      	movls	r1, r2
 8005c06:	fb05 9913 	mls	r9, r5, r3, r9
 8005c0a:	d941      	bls.n	8005c90 <_PrintUnsigned+0xfc>
  if (p->Cnt == SEGGER_SYSVIEW_MAX_STRING_LEN) {
 8005c0c:	2980      	cmp	r1, #128	@ 0x80
 8005c0e:	d149      	bne.n	8005ca4 <_PrintUnsigned+0x110>
    *(p->pPayloadStart) = (U8)p->Cnt;
 8005c10:	68b3      	ldr	r3, [r6, #8]
 8005c12:	7019      	strb	r1, [r3, #0]
    Options = p->Options;
 8005c14:	68f3      	ldr	r3, [r6, #12]
    pPayload = p->pPayload;
 8005c16:	6870      	ldr	r0, [r6, #4]
    ENCODE_U32(pPayload, Options);
 8005c18:	2b7f      	cmp	r3, #127	@ 0x7f
 8005c1a:	d906      	bls.n	8005c2a <_PrintUnsigned+0x96>
 8005c1c:	f063 027f 	orn	r2, r3, #127	@ 0x7f
 8005c20:	09db      	lsrs	r3, r3, #7
 8005c22:	2b7f      	cmp	r3, #127	@ 0x7f
 8005c24:	f800 2b01 	strb.w	r2, [r0], #1
 8005c28:	d8f8      	bhi.n	8005c1c <_PrintUnsigned+0x88>
    ENCODE_U32(pPayload, 0);
 8005c2a:	f04f 0800 	mov.w	r8, #0
    ENCODE_U32(pPayload, Options);
 8005c2e:	7003      	strb	r3, [r0, #0]
    ENCODE_U32(pPayload, 0);
 8005c30:	f880 8001 	strb.w	r8, [r0, #1]
    _SendPacket(p->pPayloadStart, pPayload, SYSVIEW_EVTID_PRINT_FORMATTED);
 8005c34:	1c81      	adds	r1, r0, #2
 8005c36:	221a      	movs	r2, #26
 8005c38:	68b0      	ldr	r0, [r6, #8]
 8005c3a:	f7ff fbef 	bl	800541c <_SendPacket>
    p->pPayloadStart = _PreparePacket(p->pBuffer);
 8005c3e:	6833      	ldr	r3, [r6, #0]
  } while (Digit);
 8005c40:	42ac      	cmp	r4, r5
    p->pPayload = p->pPayloadStart + 1u;
 8005c42:	f103 0208 	add.w	r2, r3, #8
  return pPacket + _MAX_ID_BYTES + _MAX_DATA_BYTES;
 8005c46:	f103 0107 	add.w	r1, r3, #7
    p->pPayload = p->pPayloadStart + 1u;
 8005c4a:	e9c6 2101 	strd	r2, r1, [r6, #4]
    p->Cnt = 0u;
 8005c4e:	f8c6 8010 	str.w	r8, [r6, #16]
    Digit /= Base;
 8005c52:	fbb5 f2f4 	udiv	r2, r5, r4
  } while (Digit);
 8005c56:	d828      	bhi.n	8005caa <_PrintUnsigned+0x116>
    *(p->pPayload++) = (U8)c;
 8005c58:	f103 0109 	add.w	r1, r3, #9
 8005c5c:	6071      	str	r1, [r6, #4]
    p->Cnt = Cnt + 1u;
 8005c5e:	2101      	movs	r1, #1
 8005c60:	fbb9 f0f2 	udiv	r0, r9, r2
  if ((Cnt + 1u) <= SEGGER_SYSVIEW_MAX_STRING_LEN) {
 8005c64:	4688      	mov	r8, r1
    _StoreChar(pBufferDesc, _aV2C[Div]);
 8005c66:	4d65      	ldr	r5, [pc, #404]	@ (8005dfc <_PrintUnsigned+0x268>)
 8005c68:	fb02 9910 	mls	r9, r2, r0, r9
 8005c6c:	5c2d      	ldrb	r5, [r5, r0]
    *(p->pPayload++) = (U8)c;
 8005c6e:	721d      	strb	r5, [r3, #8]
    p->Cnt = Cnt + 1u;
 8005c70:	6131      	str	r1, [r6, #16]
  if ((Cnt + 1u) <= SEGGER_SYSVIEW_MAX_STRING_LEN) {
 8005c72:	f108 0001 	add.w	r0, r8, #1
    Digit /= Base;
 8005c76:	4613      	mov	r3, r2
  } while (Digit);
 8005c78:	429c      	cmp	r4, r3
    Digit /= Base;
 8005c7a:	fbb2 f2f4 	udiv	r2, r2, r4
  } while (Digit);
 8005c7e:	d814      	bhi.n	8005caa <_PrintUnsigned+0x116>
 8005c80:	fbb9 f3f2 	udiv	r3, r9, r2
  if ((Cnt + 1u) <= SEGGER_SYSVIEW_MAX_STRING_LEN) {
 8005c84:	2880      	cmp	r0, #128	@ 0x80
 8005c86:	4601      	mov	r1, r0
 8005c88:	fb02 9913 	mls	r9, r2, r3, r9
 8005c8c:	d8f3      	bhi.n	8005c76 <_PrintUnsigned+0xe2>
    Digit /= Base;
 8005c8e:	4615      	mov	r5, r2
    _StoreChar(pBufferDesc, _aV2C[Div]);
 8005c90:	4a5a      	ldr	r2, [pc, #360]	@ (8005dfc <_PrintUnsigned+0x268>)
  if (p->Cnt == SEGGER_SYSVIEW_MAX_STRING_LEN) {
 8005c92:	2980      	cmp	r1, #128	@ 0x80
    _StoreChar(pBufferDesc, _aV2C[Div]);
 8005c94:	5cd2      	ldrb	r2, [r2, r3]
    *(p->pPayload++) = (U8)c;
 8005c96:	6873      	ldr	r3, [r6, #4]
 8005c98:	f103 0001 	add.w	r0, r3, #1
 8005c9c:	6070      	str	r0, [r6, #4]
 8005c9e:	701a      	strb	r2, [r3, #0]
    p->Cnt = Cnt + 1u;
 8005ca0:	6131      	str	r1, [r6, #16]
  if (p->Cnt == SEGGER_SYSVIEW_MAX_STRING_LEN) {
 8005ca2:	d0b5      	beq.n	8005c10 <_PrintUnsigned+0x7c>
 8005ca4:	462a      	mov	r2, r5
 8005ca6:	4688      	mov	r8, r1
 8005ca8:	e7e3      	b.n	8005c72 <_PrintUnsigned+0xde>
  if ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == FORMAT_FLAG_LEFT_JUSTIFY) {
 8005caa:	f1ba 0f00 	cmp.w	sl, #0
 8005cae:	d00e      	beq.n	8005cce <_PrintUnsigned+0x13a>
    if (FieldWidth != 0u) {
 8005cb0:	f1bb 0f00 	cmp.w	fp, #0
 8005cb4:	d00b      	beq.n	8005cce <_PrintUnsigned+0x13a>
      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
 8005cb6:	455f      	cmp	r7, fp
 8005cb8:	d209      	bcs.n	8005cce <_PrintUnsigned+0x13a>
    *(p->pPayload++) = (U8)c;
 8005cba:	2420      	movs	r4, #32
    ENCODE_U32(pPayload, 0);
 8005cbc:	f04f 0900 	mov.w	r9, #0
  if ((Cnt + 1u) <= SEGGER_SYSVIEW_MAX_STRING_LEN) {
 8005cc0:	f108 0801 	add.w	r8, r8, #1
 8005cc4:	f1b8 0f80 	cmp.w	r8, #128	@ 0x80
        FieldWidth--;
 8005cc8:	f10b 35ff 	add.w	r5, fp, #4294967295
  if ((Cnt + 1u) <= SEGGER_SYSVIEW_MAX_STRING_LEN) {
 8005ccc:	d94e      	bls.n	8005d6c <_PrintUnsigned+0x1d8>
}
 8005cce:	b003      	add	sp, #12
 8005cd0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      if (((FormatFlags & FORMAT_FLAG_PAD_ZERO) == FORMAT_FLAG_PAD_ZERO) && (NumDigits == 0u)) {
 8005cd4:	07aa      	lsls	r2, r5, #30
 8005cd6:	d47f      	bmi.n	8005dd8 <_PrintUnsigned+0x244>
        c = ' ';
 8005cd8:	2320      	movs	r3, #32
 8005cda:	9301      	str	r3, [sp, #4]
      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
 8005cdc:	45bb      	cmp	fp, r7
 8005cde:	f67f af78 	bls.w	8005bd2 <_PrintUnsigned+0x3e>
  if ((Cnt + 1u) <= SEGGER_SYSVIEW_MAX_STRING_LEN) {
 8005ce2:	1c4a      	adds	r2, r1, #1
 8005ce4:	2a80      	cmp	r2, #128	@ 0x80
        FieldWidth--;
 8005ce6:	f10b 3bff 	add.w	fp, fp, #4294967295
  if ((Cnt + 1u) <= SEGGER_SYSVIEW_MAX_STRING_LEN) {
 8005cea:	d937      	bls.n	8005d5c <_PrintUnsigned+0x1c8>
  if (p->Cnt == SEGGER_SYSVIEW_MAX_STRING_LEN) {
 8005cec:	2980      	cmp	r1, #128	@ 0x80
 8005cee:	d129      	bne.n	8005d44 <_PrintUnsigned+0x1b0>
    *(p->pPayloadStart) = (U8)p->Cnt;
 8005cf0:	68b3      	ldr	r3, [r6, #8]
 8005cf2:	7019      	strb	r1, [r3, #0]
    Options = p->Options;
 8005cf4:	68f3      	ldr	r3, [r6, #12]
    pPayload = p->pPayload;
 8005cf6:	6870      	ldr	r0, [r6, #4]
    ENCODE_U32(pPayload, Options);
 8005cf8:	2b7f      	cmp	r3, #127	@ 0x7f
 8005cfa:	d906      	bls.n	8005d0a <_PrintUnsigned+0x176>
 8005cfc:	f063 027f 	orn	r2, r3, #127	@ 0x7f
 8005d00:	09db      	lsrs	r3, r3, #7
 8005d02:	2b7f      	cmp	r3, #127	@ 0x7f
 8005d04:	f800 2b01 	strb.w	r2, [r0], #1
 8005d08:	d8f8      	bhi.n	8005cfc <_PrintUnsigned+0x168>
    ENCODE_U32(pPayload, 0);
 8005d0a:	2500      	movs	r5, #0
    ENCODE_U32(pPayload, Options);
 8005d0c:	7003      	strb	r3, [r0, #0]
    ENCODE_U32(pPayload, 0);
 8005d0e:	7045      	strb	r5, [r0, #1]
    _SendPacket(p->pPayloadStart, pPayload, SYSVIEW_EVTID_PRINT_FORMATTED);
 8005d10:	1c81      	adds	r1, r0, #2
 8005d12:	221a      	movs	r2, #26
 8005d14:	68b0      	ldr	r0, [r6, #8]
 8005d16:	f7ff fb81 	bl	800541c <_SendPacket>
    p->pPayloadStart = _PreparePacket(p->pBuffer);
 8005d1a:	6832      	ldr	r2, [r6, #0]
    p->Cnt = 0u;
 8005d1c:	6135      	str	r5, [r6, #16]
  return pPacket + _MAX_ID_BYTES + _MAX_DATA_BYTES;
 8005d1e:	1dd1      	adds	r1, r2, #7
    p->pPayloadStart = _PreparePacket(p->pBuffer);
 8005d20:	60b1      	str	r1, [r6, #8]
    p->pPayload = p->pPayloadStart + 1u;
 8005d22:	f102 0108 	add.w	r1, r2, #8
 8005d26:	6071      	str	r1, [r6, #4]
      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
 8005d28:	f1bb 0f00 	cmp.w	fp, #0
 8005d2c:	d05d      	beq.n	8005dea <_PrintUnsigned+0x256>
 8005d2e:	455f      	cmp	r7, fp
 8005d30:	d05e      	beq.n	8005df0 <_PrintUnsigned+0x25c>
    p->Cnt = Cnt + 1u;
 8005d32:	2101      	movs	r1, #1
    *(p->pPayload++) = (U8)c;
 8005d34:	f102 0309 	add.w	r3, r2, #9
 8005d38:	6073      	str	r3, [r6, #4]
 8005d3a:	9b01      	ldr	r3, [sp, #4]
        FieldWidth--;
 8005d3c:	f10b 3bff 	add.w	fp, fp, #4294967295
    *(p->pPayload++) = (U8)c;
 8005d40:	7213      	strb	r3, [r2, #8]
    p->Cnt = Cnt + 1u;
 8005d42:	6131      	str	r1, [r6, #16]
  if (p->Cnt == SEGGER_SYSVIEW_MAX_STRING_LEN) {
 8005d44:	1c4a      	adds	r2, r1, #1
      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
 8005d46:	f1bb 0f00 	cmp.w	fp, #0
 8005d4a:	f43f af43 	beq.w	8005bd4 <_PrintUnsigned+0x40>
 8005d4e:	455f      	cmp	r7, fp
 8005d50:	f43f af40 	beq.w	8005bd4 <_PrintUnsigned+0x40>
  if ((Cnt + 1u) <= SEGGER_SYSVIEW_MAX_STRING_LEN) {
 8005d54:	2a80      	cmp	r2, #128	@ 0x80
        FieldWidth--;
 8005d56:	f10b 3bff 	add.w	fp, fp, #4294967295
  if ((Cnt + 1u) <= SEGGER_SYSVIEW_MAX_STRING_LEN) {
 8005d5a:	d8f4      	bhi.n	8005d46 <_PrintUnsigned+0x1b2>
    *(p->pPayload++) = (U8)c;
 8005d5c:	6873      	ldr	r3, [r6, #4]
  if ((Cnt + 1u) <= SEGGER_SYSVIEW_MAX_STRING_LEN) {
 8005d5e:	4611      	mov	r1, r2
    *(p->pPayload++) = (U8)c;
 8005d60:	1c58      	adds	r0, r3, #1
 8005d62:	6070      	str	r0, [r6, #4]
 8005d64:	9801      	ldr	r0, [sp, #4]
 8005d66:	7018      	strb	r0, [r3, #0]
    p->Cnt = Cnt + 1u;
 8005d68:	6132      	str	r2, [r6, #16]
 8005d6a:	e7bf      	b.n	8005cec <_PrintUnsigned+0x158>
    *(p->pPayload++) = (U8)c;
 8005d6c:	6873      	ldr	r3, [r6, #4]
 8005d6e:	f103 0201 	add.w	r2, r3, #1
 8005d72:	6072      	str	r2, [r6, #4]
 8005d74:	701c      	strb	r4, [r3, #0]
    p->Cnt = Cnt + 1u;
 8005d76:	f8c6 8010 	str.w	r8, [r6, #16]
  if (p->Cnt == SEGGER_SYSVIEW_MAX_STRING_LEN) {
 8005d7a:	d13c      	bne.n	8005df6 <_PrintUnsigned+0x262>
    *(p->pPayloadStart) = (U8)p->Cnt;
 8005d7c:	68b3      	ldr	r3, [r6, #8]
 8005d7e:	f883 8000 	strb.w	r8, [r3]
    Options = p->Options;
 8005d82:	68f3      	ldr	r3, [r6, #12]
    pPayload = p->pPayload;
 8005d84:	6871      	ldr	r1, [r6, #4]
    ENCODE_U32(pPayload, Options);
 8005d86:	2b7f      	cmp	r3, #127	@ 0x7f
 8005d88:	d906      	bls.n	8005d98 <_PrintUnsigned+0x204>
 8005d8a:	f063 027f 	orn	r2, r3, #127	@ 0x7f
 8005d8e:	09db      	lsrs	r3, r3, #7
 8005d90:	2b7f      	cmp	r3, #127	@ 0x7f
 8005d92:	f801 2b01 	strb.w	r2, [r1], #1
 8005d96:	d8f8      	bhi.n	8005d8a <_PrintUnsigned+0x1f6>
 8005d98:	700b      	strb	r3, [r1, #0]
    ENCODE_U32(pPayload, 0);
 8005d9a:	f881 9001 	strb.w	r9, [r1, #1]
    _SendPacket(p->pPayloadStart, pPayload, SYSVIEW_EVTID_PRINT_FORMATTED);
 8005d9e:	221a      	movs	r2, #26
 8005da0:	68b0      	ldr	r0, [r6, #8]
 8005da2:	3102      	adds	r1, #2
 8005da4:	f7ff fb3a 	bl	800541c <_SendPacket>
    p->pPayloadStart = _PreparePacket(p->pBuffer);
 8005da8:	6833      	ldr	r3, [r6, #0]
      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
 8005daa:	42bd      	cmp	r5, r7
  return pPacket + _MAX_ID_BYTES + _MAX_DATA_BYTES;
 8005dac:	f103 0207 	add.w	r2, r3, #7
    p->pPayloadStart = _PreparePacket(p->pBuffer);
 8005db0:	60b2      	str	r2, [r6, #8]
    p->pPayload = p->pPayloadStart + 1u;
 8005db2:	f103 0208 	add.w	r2, r3, #8
    p->Cnt = 0u;
 8005db6:	f8c6 9010 	str.w	r9, [r6, #16]
    p->pPayload = p->pPayloadStart + 1u;
 8005dba:	6072      	str	r2, [r6, #4]
      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
 8005dbc:	d087      	beq.n	8005cce <_PrintUnsigned+0x13a>
    p->Cnt = Cnt + 1u;
 8005dbe:	2201      	movs	r2, #1
  if ((Cnt + 1u) <= SEGGER_SYSVIEW_MAX_STRING_LEN) {
 8005dc0:	46d0      	mov	r8, sl
    *(p->pPayload++) = (U8)c;
 8005dc2:	f103 0109 	add.w	r1, r3, #9
 8005dc6:	6071      	str	r1, [r6, #4]
        FieldWidth--;
 8005dc8:	f1ab 0b02 	sub.w	fp, fp, #2
    *(p->pPayload++) = (U8)c;
 8005dcc:	721c      	strb	r4, [r3, #8]
    p->Cnt = Cnt + 1u;
 8005dce:	6132      	str	r2, [r6, #16]
      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
 8005dd0:	455f      	cmp	r7, fp
 8005dd2:	f47f af75 	bne.w	8005cc0 <_PrintUnsigned+0x12c>
 8005dd6:	e77a      	b.n	8005cce <_PrintUnsigned+0x13a>
        c = ' ';
 8005dd8:	f1b8 0f00 	cmp.w	r8, #0
 8005ddc:	bf0c      	ite	eq
 8005dde:	2330      	moveq	r3, #48	@ 0x30
 8005de0:	2320      	movne	r3, #32
 8005de2:	9301      	str	r3, [sp, #4]
 8005de4:	e77a      	b.n	8005cdc <_PrintUnsigned+0x148>
  Width = 1u;
 8005de6:	2701      	movs	r7, #1
 8005de8:	e6e8      	b.n	8005bbc <_PrintUnsigned+0x28>
      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
 8005dea:	4659      	mov	r1, fp
 8005dec:	2201      	movs	r2, #1
 8005dee:	e6f1      	b.n	8005bd4 <_PrintUnsigned+0x40>
 8005df0:	4629      	mov	r1, r5
 8005df2:	2201      	movs	r2, #1
 8005df4:	e6ee      	b.n	8005bd4 <_PrintUnsigned+0x40>
 8005df6:	46ab      	mov	fp, r5
 8005df8:	e7ea      	b.n	8005dd0 <_PrintUnsigned+0x23c>
 8005dfa:	bf00      	nop
 8005dfc:	08006f60 	.word	0x08006f60

08005e00 <SEGGER_SYSVIEW_Start>:
void SEGGER_SYSVIEW_Start(void) {
 8005e00:	b538      	push	{r3, r4, r5, lr}
    _SYSVIEW_Globals.EnableState = 1;
 8005e02:	2301      	movs	r3, #1
 8005e04:	4c3b      	ldr	r4, [pc, #236]	@ (8005ef4 <SEGGER_SYSVIEW_Start+0xf4>)
 8005e06:	7023      	strb	r3, [r4, #0]
    SEGGER_SYSVIEW_LOCK();
 8005e08:	f3ef 8511 	mrs	r5, BASEPRI
 8005e0c:	f04f 0120 	mov.w	r1, #32
 8005e10:	f381 8811 	msr	BASEPRI, r1
    SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, _abSync, 10);
 8005e14:	220a      	movs	r2, #10
 8005e16:	4938      	ldr	r1, [pc, #224]	@ (8005ef8 <SEGGER_SYSVIEW_Start+0xf8>)
 8005e18:	7860      	ldrb	r0, [r4, #1]
 8005e1a:	f7fa f999 	bl	8000150 <SEGGER_RTT_ASM_WriteSkipNoLock>
    SEGGER_SYSVIEW_UNLOCK();
 8005e1e:	f385 8811 	msr	BASEPRI, r5
    SEGGER_SYSVIEW_ON_EVENT_RECORDED(10);
 8005e22:	f7fe fe5b 	bl	8004adc <HIF_UART_EnableTXEInterrupt>
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE);
 8005e26:	f3ef 8511 	mrs	r5, BASEPRI
 8005e2a:	f04f 0120 	mov.w	r1, #32
 8005e2e:	f381 8811 	msr	BASEPRI, r1
  _SendPacket(pPayloadStart, pPayloadStart, EventID);
 8005e32:	4932      	ldr	r1, [pc, #200]	@ (8005efc <SEGGER_SYSVIEW_Start+0xfc>)
 8005e34:	220a      	movs	r2, #10
 8005e36:	4608      	mov	r0, r1
 8005e38:	f7ff faf0 	bl	800541c <_SendPacket>
  RECORD_END();
 8005e3c:	f385 8811 	msr	BASEPRI, r5
      RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 4 * SEGGER_SYSVIEW_QUANTA_U32);
 8005e40:	f3ef 8511 	mrs	r5, BASEPRI
 8005e44:	f04f 0120 	mov.w	r1, #32
 8005e48:	f381 8811 	msr	BASEPRI, r1
      ENCODE_U32(pPayload, _SYSVIEW_Globals.SysFreq);
 8005e4c:	6862      	ldr	r2, [r4, #4]
 8005e4e:	4b2b      	ldr	r3, [pc, #172]	@ (8005efc <SEGGER_SYSVIEW_Start+0xfc>)
 8005e50:	2a7f      	cmp	r2, #127	@ 0x7f
 8005e52:	d906      	bls.n	8005e62 <SEGGER_SYSVIEW_Start+0x62>
 8005e54:	f062 017f 	orn	r1, r2, #127	@ 0x7f
 8005e58:	09d2      	lsrs	r2, r2, #7
 8005e5a:	2a7f      	cmp	r2, #127	@ 0x7f
 8005e5c:	f803 1b01 	strb.w	r1, [r3], #1
 8005e60:	d8f8      	bhi.n	8005e54 <SEGGER_SYSVIEW_Start+0x54>
      ENCODE_U32(pPayload, _SYSVIEW_Globals.CPUFreq);
 8005e62:	68a1      	ldr	r1, [r4, #8]
      ENCODE_U32(pPayload, _SYSVIEW_Globals.SysFreq);
 8005e64:	f803 2b01 	strb.w	r2, [r3], #1
      ENCODE_U32(pPayload, _SYSVIEW_Globals.CPUFreq);
 8005e68:	297f      	cmp	r1, #127	@ 0x7f
 8005e6a:	d906      	bls.n	8005e7a <SEGGER_SYSVIEW_Start+0x7a>
 8005e6c:	f061 027f 	orn	r2, r1, #127	@ 0x7f
 8005e70:	09c9      	lsrs	r1, r1, #7
 8005e72:	297f      	cmp	r1, #127	@ 0x7f
 8005e74:	f803 2b01 	strb.w	r2, [r3], #1
 8005e78:	d8f8      	bhi.n	8005e6c <SEGGER_SYSVIEW_Start+0x6c>
      ENCODE_U32(pPayload, _SYSVIEW_Globals.RAMBaseAddress);
 8005e7a:	6922      	ldr	r2, [r4, #16]
      ENCODE_U32(pPayload, _SYSVIEW_Globals.CPUFreq);
 8005e7c:	f803 1b01 	strb.w	r1, [r3], #1
      ENCODE_U32(pPayload, _SYSVIEW_Globals.RAMBaseAddress);
 8005e80:	2a7f      	cmp	r2, #127	@ 0x7f
 8005e82:	d906      	bls.n	8005e92 <SEGGER_SYSVIEW_Start+0x92>
 8005e84:	f062 017f 	orn	r1, r2, #127	@ 0x7f
 8005e88:	09d2      	lsrs	r2, r2, #7
 8005e8a:	2a7f      	cmp	r2, #127	@ 0x7f
 8005e8c:	f803 1b01 	strb.w	r1, [r3], #1
 8005e90:	d8f8      	bhi.n	8005e84 <SEGGER_SYSVIEW_Start+0x84>
      ENCODE_U32(pPayload, SEGGER_SYSVIEW_ID_SHIFT);
 8005e92:	f04f 0c00 	mov.w	ip, #0
      ENCODE_U32(pPayload, _SYSVIEW_Globals.RAMBaseAddress);
 8005e96:	701a      	strb	r2, [r3, #0]
      _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_INIT);
 8005e98:	4818      	ldr	r0, [pc, #96]	@ (8005efc <SEGGER_SYSVIEW_Start+0xfc>)
 8005e9a:	2218      	movs	r2, #24
 8005e9c:	1c99      	adds	r1, r3, #2
      ENCODE_U32(pPayload, SEGGER_SYSVIEW_ID_SHIFT);
 8005e9e:	f883 c001 	strb.w	ip, [r3, #1]
      _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_INIT);
 8005ea2:	f7ff fabb 	bl	800541c <_SendPacket>
      RECORD_END();
 8005ea6:	f385 8811 	msr	BASEPRI, r5
    if (_SYSVIEW_Globals.pfSendSysDesc) {
 8005eaa:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 8005eac:	b103      	cbz	r3, 8005eb0 <SEGGER_SYSVIEW_Start+0xb0>
      _SYSVIEW_Globals.pfSendSysDesc();
 8005eae:	4798      	blx	r3
    SEGGER_SYSVIEW_RecordSystime();
 8005eb0:	f7ff fe20 	bl	8005af4 <SEGGER_SYSVIEW_RecordSystime>
  if (_SYSVIEW_Globals.pOSAPI && _SYSVIEW_Globals.pOSAPI->pfSendTaskList) {
 8005eb4:	6a23      	ldr	r3, [r4, #32]
 8005eb6:	b113      	cbz	r3, 8005ebe <SEGGER_SYSVIEW_Start+0xbe>
 8005eb8:	685b      	ldr	r3, [r3, #4]
 8005eba:	b103      	cbz	r3, 8005ebe <SEGGER_SYSVIEW_Start+0xbe>
    _SYSVIEW_Globals.pOSAPI->pfSendTaskList();
 8005ebc:	4798      	blx	r3
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2*SEGGER_SYSVIEW_QUANTA_U32);
 8005ebe:	f3ef 8411 	mrs	r4, BASEPRI
 8005ec2:	f04f 0120 	mov.w	r1, #32
 8005ec6:	f381 8811 	msr	BASEPRI, r1
  ENCODE_U32(pPayload, _NumModules);
 8005eca:	4b0d      	ldr	r3, [pc, #52]	@ (8005f00 <SEGGER_SYSVIEW_Start+0x100>)
 8005ecc:	f993 2000 	ldrsb.w	r2, [r3]
 8005ed0:	781b      	ldrb	r3, [r3, #0]
 8005ed2:	2a00      	cmp	r2, #0
 8005ed4:	da0c      	bge.n	8005ef0 <SEGGER_SYSVIEW_Start+0xf0>
 8005ed6:	490b      	ldr	r1, [pc, #44]	@ (8005f04 <SEGGER_SYSVIEW_Start+0x104>)
 8005ed8:	71cb      	strb	r3, [r1, #7]
 8005eda:	2301      	movs	r3, #1
 8005edc:	3108      	adds	r1, #8
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_NUMMODULES);
 8005ede:	221b      	movs	r2, #27
 8005ee0:	4806      	ldr	r0, [pc, #24]	@ (8005efc <SEGGER_SYSVIEW_Start+0xfc>)
  ENCODE_U32(pPayload, _NumModules);
 8005ee2:	f801 3b01 	strb.w	r3, [r1], #1
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_NUMMODULES);
 8005ee6:	f7ff fa99 	bl	800541c <_SendPacket>
  RECORD_END();
 8005eea:	f384 8811 	msr	BASEPRI, r4
}
 8005eee:	bd38      	pop	{r3, r4, r5, pc}
 8005ef0:	4902      	ldr	r1, [pc, #8]	@ (8005efc <SEGGER_SYSVIEW_Start+0xfc>)
 8005ef2:	e7f4      	b.n	8005ede <SEGGER_SYSVIEW_Start+0xde>
 8005ef4:	20001a1c 	.word	0x20001a1c
 8005ef8:	08006f70 	.word	0x08006f70
 8005efc:	2000193b 	.word	0x2000193b
 8005f00:	20001a17 	.word	0x20001a17
 8005f04:	20001934 	.word	0x20001934

08005f08 <_VPrintTarget>:
static void _VPrintTarget(const char* sFormat, U32 Options, va_list* pParamList) {
 8005f08:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8005f0c:	460b      	mov	r3, r1
 8005f0e:	b08b      	sub	sp, #44	@ 0x2c
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_MAX_STRING_LEN + 1 + 2 * SEGGER_SYSVIEW_QUANTA_U32);
 8005f10:	f3ef 8611 	mrs	r6, BASEPRI
 8005f14:	f04f 0120 	mov.w	r1, #32
 8005f18:	f381 8811 	msr	BASEPRI, r1
    c = *sFormat;
 8005f1c:	4604      	mov	r4, r0
  BufferDesc.Cnt            = 0u;
 8005f1e:	f04f 0800 	mov.w	r8, #0
  BufferDesc.Options        =  Options;
 8005f22:	9308      	str	r3, [sp, #32]
  BufferDesc.pBuffer        = _aPacket;
 8005f24:	4bab      	ldr	r3, [pc, #684]	@ (80061d4 <_VPrintTarget+0x2cc>)
  BufferDesc.Cnt            = 0u;
 8005f26:	f8cd 8024 	str.w	r8, [sp, #36]	@ 0x24
  BufferDesc.pPayloadStart  = pPayloadStart;
 8005f2a:	1dd9      	adds	r1, r3, #7
  BufferDesc.pBuffer        = _aPacket;
 8005f2c:	9305      	str	r3, [sp, #20]
  BufferDesc.pPayload       = BufferDesc.pPayloadStart + 1u;
 8005f2e:	3308      	adds	r3, #8
 8005f30:	9306      	str	r3, [sp, #24]
    c = *sFormat;
 8005f32:	f814 3b01 	ldrb.w	r3, [r4], #1
  BufferDesc.pPayloadStart  = pPayloadStart;
 8005f36:	9107      	str	r1, [sp, #28]
    if (c == 0u) {
 8005f38:	2b00      	cmp	r3, #0
 8005f3a:	f000 80da 	beq.w	80060f2 <_VPrintTarget+0x1ea>
 8005f3e:	4693      	mov	fp, r2
 8005f40:	e011      	b.n	8005f66 <_VPrintTarget+0x5e>
  Cnt = p->Cnt;
 8005f42:	9a09      	ldr	r2, [sp, #36]	@ 0x24
  if ((Cnt + 1u) <= SEGGER_SYSVIEW_MAX_STRING_LEN) {
 8005f44:	1c51      	adds	r1, r2, #1
 8005f46:	2980      	cmp	r1, #128	@ 0x80
 8005f48:	d805      	bhi.n	8005f56 <_VPrintTarget+0x4e>
    *(p->pPayload++) = (U8)c;
 8005f4a:	9806      	ldr	r0, [sp, #24]
    p->Cnt = Cnt + 1u;
 8005f4c:	460a      	mov	r2, r1
 8005f4e:	9109      	str	r1, [sp, #36]	@ 0x24
    *(p->pPayload++) = (U8)c;
 8005f50:	1c41      	adds	r1, r0, #1
 8005f52:	9106      	str	r1, [sp, #24]
 8005f54:	7003      	strb	r3, [r0, #0]
  if (p->Cnt == SEGGER_SYSVIEW_MAX_STRING_LEN) {
 8005f56:	2a80      	cmp	r2, #128	@ 0x80
 8005f58:	f000 8096 	beq.w	8006088 <_VPrintTarget+0x180>
  } while (*sFormat);
 8005f5c:	7823      	ldrb	r3, [r4, #0]
 8005f5e:	2b00      	cmp	r3, #0
 8005f60:	f000 80b1 	beq.w	80060c6 <_VPrintTarget+0x1be>
    sFormat++;
 8005f64:	3401      	adds	r4, #1
    if (c == '%') {
 8005f66:	2b25      	cmp	r3, #37	@ 0x25
 8005f68:	d1eb      	bne.n	8005f42 <_VPrintTarget+0x3a>
      FormatFlags = 0u;
 8005f6a:	2700      	movs	r7, #0
        c = *sFormat;
 8005f6c:	4622      	mov	r2, r4
 8005f6e:	f812 3b01 	ldrb.w	r3, [r2], #1
        switch (c) {
 8005f72:	f1a3 0123 	sub.w	r1, r3, #35	@ 0x23
 8005f76:	290d      	cmp	r1, #13
 8005f78:	d808      	bhi.n	8005f8c <_VPrintTarget+0x84>
 8005f7a:	e8df f001 	tbb	[pc, r1]
 8005f7e:	077d      	.short	0x077d
 8005f80:	07070707 	.word	0x07070707
 8005f84:	07790707 	.word	0x07790707
 8005f88:	75070781 	.word	0x75070781
        if ((c < '0') || (c > '9')) {
 8005f8c:	f1a3 0130 	sub.w	r1, r3, #48	@ 0x30
 8005f90:	2909      	cmp	r1, #9
      FieldWidth = 0u;
 8005f92:	f04f 0500 	mov.w	r5, #0
        if ((c < '0') || (c > '9')) {
 8005f96:	d901      	bls.n	8005f9c <_VPrintTarget+0x94>
 8005f98:	e00c      	b.n	8005fb4 <_VPrintTarget+0xac>
 8005f9a:	3201      	adds	r2, #1
        FieldWidth = (FieldWidth * 10u) + ((unsigned int)c - '0');
 8005f9c:	eb05 0585 	add.w	r5, r5, r5, lsl #2
 8005fa0:	eb03 0545 	add.w	r5, r3, r5, lsl #1
        c = *sFormat;
 8005fa4:	7813      	ldrb	r3, [r2, #0]
        sFormat++;
 8005fa6:	4614      	mov	r4, r2
        if ((c < '0') || (c > '9')) {
 8005fa8:	f1a3 0130 	sub.w	r1, r3, #48	@ 0x30
 8005fac:	2909      	cmp	r1, #9
        FieldWidth = (FieldWidth * 10u) + ((unsigned int)c - '0');
 8005fae:	f1a5 0530 	sub.w	r5, r5, #48	@ 0x30
        if ((c < '0') || (c > '9')) {
 8005fb2:	d9f2      	bls.n	8005f9a <_VPrintTarget+0x92>
      if (c == '.') {
 8005fb4:	2b2e      	cmp	r3, #46	@ 0x2e
 8005fb6:	f000 81f6 	beq.w	80063a6 <_VPrintTarget+0x49e>
      NumDigits = 0u;
 8005fba:	f04f 0a00 	mov.w	sl, #0
        if ((c == 'l') || (c == 'h')) {
 8005fbe:	f003 02fb 	and.w	r2, r3, #251	@ 0xfb
 8005fc2:	2a68      	cmp	r2, #104	@ 0x68
 8005fc4:	f000 809a 	beq.w	80060fc <_VPrintTarget+0x1f4>
      switch (c) {
 8005fc8:	2b25      	cmp	r3, #37	@ 0x25
          sFormat++;
 8005fca:	f104 0401 	add.w	r4, r4, #1
      switch (c) {
 8005fce:	f000 80a1 	beq.w	8006114 <_VPrintTarget+0x20c>
 8005fd2:	3b58      	subs	r3, #88	@ 0x58
 8005fd4:	b2da      	uxtb	r2, r3
 8005fd6:	2a20      	cmp	r2, #32
 8005fd8:	d8c0      	bhi.n	8005f5c <_VPrintTarget+0x54>
 8005fda:	2b20      	cmp	r3, #32
 8005fdc:	d8be      	bhi.n	8005f5c <_VPrintTarget+0x54>
 8005fde:	a201      	add	r2, pc, #4	@ (adr r2, 8005fe4 <_VPrintTarget+0xdc>)
 8005fe0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8005fe4:	08006169 	.word	0x08006169
 8005fe8:	08005f5d 	.word	0x08005f5d
 8005fec:	08005f5d 	.word	0x08005f5d
 8005ff0:	08005f5d 	.word	0x08005f5d
 8005ff4:	08005f5d 	.word	0x08005f5d
 8005ff8:	08005f5d 	.word	0x08005f5d
 8005ffc:	08005f5d 	.word	0x08005f5d
 8006000:	08005f5d 	.word	0x08005f5d
 8006004:	08005f5d 	.word	0x08005f5d
 8006008:	08005f5d 	.word	0x08005f5d
 800600c:	08005f5d 	.word	0x08005f5d
 8006010:	08006185 	.word	0x08006185
 8006014:	080062fd 	.word	0x080062fd
 8006018:	08005f5d 	.word	0x08005f5d
 800601c:	08005f5d 	.word	0x08005f5d
 8006020:	08005f5d 	.word	0x08005f5d
 8006024:	08005f5d 	.word	0x08005f5d
 8006028:	08005f5d 	.word	0x08005f5d
 800602c:	08005f5d 	.word	0x08005f5d
 8006030:	08005f5d 	.word	0x08005f5d
 8006034:	08005f5d 	.word	0x08005f5d
 8006038:	08005f5d 	.word	0x08005f5d
 800603c:	08005f5d 	.word	0x08005f5d
 8006040:	08005f5d 	.word	0x08005f5d
 8006044:	08006217 	.word	0x08006217
 8006048:	08005f5d 	.word	0x08005f5d
 800604c:	08005f5d 	.word	0x08005f5d
 8006050:	080061d9 	.word	0x080061d9
 8006054:	08005f5d 	.word	0x08005f5d
 8006058:	080061c9 	.word	0x080061c9
 800605c:	08005f5d 	.word	0x08005f5d
 8006060:	08005f5d 	.word	0x08005f5d
 8006064:	08006169 	.word	0x08006169
static void _VPrintTarget(const char* sFormat, U32 Options, va_list* pParamList) {
 8006068:	4614      	mov	r4, r2
        case '0': FormatFlags |= FORMAT_FLAG_PAD_ZERO;     sFormat++; break;
 800606a:	f047 0702 	orr.w	r7, r7, #2
 800606e:	e77d      	b.n	8005f6c <_VPrintTarget+0x64>
static void _VPrintTarget(const char* sFormat, U32 Options, va_list* pParamList) {
 8006070:	4614      	mov	r4, r2
        case '+': FormatFlags |= FORMAT_FLAG_PRINT_SIGN;   sFormat++; break;
 8006072:	f047 0704 	orr.w	r7, r7, #4
 8006076:	e779      	b.n	8005f6c <_VPrintTarget+0x64>
static void _VPrintTarget(const char* sFormat, U32 Options, va_list* pParamList) {
 8006078:	4614      	mov	r4, r2
        case '#': FormatFlags |= FORMAT_FLAG_ALTERNATE;    sFormat++; break;
 800607a:	f047 0708 	orr.w	r7, r7, #8
 800607e:	e775      	b.n	8005f6c <_VPrintTarget+0x64>
static void _VPrintTarget(const char* sFormat, U32 Options, va_list* pParamList) {
 8006080:	4614      	mov	r4, r2
        case '-': FormatFlags |= FORMAT_FLAG_LEFT_JUSTIFY; sFormat++; break;
 8006082:	f047 0701 	orr.w	r7, r7, #1
 8006086:	e771      	b.n	8005f6c <_VPrintTarget+0x64>
    Options = p->Options;
 8006088:	e9dd 0307 	ldrd	r0, r3, [sp, #28]
    ENCODE_U32(pPayload, Options);
 800608c:	2b7f      	cmp	r3, #127	@ 0x7f
    pPayload = p->pPayload;
 800608e:	9906      	ldr	r1, [sp, #24]
    *(p->pPayloadStart) = (U8)p->Cnt;
 8006090:	7002      	strb	r2, [r0, #0]
    ENCODE_U32(pPayload, Options);
 8006092:	d906      	bls.n	80060a2 <_VPrintTarget+0x19a>
 8006094:	f063 027f 	orn	r2, r3, #127	@ 0x7f
 8006098:	09db      	lsrs	r3, r3, #7
 800609a:	2b7f      	cmp	r3, #127	@ 0x7f
 800609c:	f801 2b01 	strb.w	r2, [r1], #1
 80060a0:	d8f8      	bhi.n	8006094 <_VPrintTarget+0x18c>
 80060a2:	700b      	strb	r3, [r1, #0]
    _SendPacket(p->pPayloadStart, pPayload, SYSVIEW_EVTID_PRINT_FORMATTED);
 80060a4:	221a      	movs	r2, #26
    ENCODE_U32(pPayload, 0);
 80060a6:	f881 8001 	strb.w	r8, [r1, #1]
    _SendPacket(p->pPayloadStart, pPayload, SYSVIEW_EVTID_PRINT_FORMATTED);
 80060aa:	3102      	adds	r1, #2
 80060ac:	f7ff f9b6 	bl	800541c <_SendPacket>
    p->pPayloadStart = _PreparePacket(p->pBuffer);
 80060b0:	9b05      	ldr	r3, [sp, #20]
    p->Cnt = 0u;
 80060b2:	f8cd 8024 	str.w	r8, [sp, #36]	@ 0x24
  return pPacket + _MAX_ID_BYTES + _MAX_DATA_BYTES;
 80060b6:	1dda      	adds	r2, r3, #7
    p->pPayload = p->pPayloadStart + 1u;
 80060b8:	3308      	adds	r3, #8
 80060ba:	e9cd 3206 	strd	r3, r2, [sp, #24]
  } while (*sFormat);
 80060be:	7823      	ldrb	r3, [r4, #0]
 80060c0:	2b00      	cmp	r3, #0
 80060c2:	f47f af4f 	bne.w	8005f64 <_VPrintTarget+0x5c>
  if (BufferDesc.Cnt != 0u) {
 80060c6:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 80060c8:	b19a      	cbz	r2, 80060f2 <_VPrintTarget+0x1ea>
    ENCODE_U32(BufferDesc.pPayload, BufferDesc.Options);
 80060ca:	e9dd 0307 	ldrd	r0, r3, [sp, #28]
 80060ce:	2b7f      	cmp	r3, #127	@ 0x7f
 80060d0:	9c06      	ldr	r4, [sp, #24]
    *(BufferDesc.pPayloadStart) = (U8)BufferDesc.Cnt;
 80060d2:	7002      	strb	r2, [r0, #0]
    ENCODE_U32(BufferDesc.pPayload, BufferDesc.Options);
 80060d4:	d906      	bls.n	80060e4 <_VPrintTarget+0x1dc>
 80060d6:	f063 027f 	orn	r2, r3, #127	@ 0x7f
 80060da:	09db      	lsrs	r3, r3, #7
 80060dc:	2b7f      	cmp	r3, #127	@ 0x7f
 80060de:	f804 2b01 	strb.w	r2, [r4], #1
 80060e2:	d8f8      	bhi.n	80060d6 <_VPrintTarget+0x1ce>
    ENCODE_U32(BufferDesc.pPayload, 0);
 80060e4:	2500      	movs	r5, #0
    _SendPacket(BufferDesc.pPayloadStart, BufferDesc.pPayload, SYSVIEW_EVTID_PRINT_FORMATTED);
 80060e6:	221a      	movs	r2, #26
    ENCODE_U32(BufferDesc.pPayload, BufferDesc.Options);
 80060e8:	7023      	strb	r3, [r4, #0]
    _SendPacket(BufferDesc.pPayloadStart, BufferDesc.pPayload, SYSVIEW_EVTID_PRINT_FORMATTED);
 80060ea:	1ca1      	adds	r1, r4, #2
    ENCODE_U32(BufferDesc.pPayload, 0);
 80060ec:	7065      	strb	r5, [r4, #1]
    _SendPacket(BufferDesc.pPayloadStart, BufferDesc.pPayload, SYSVIEW_EVTID_PRINT_FORMATTED);
 80060ee:	f7ff f995 	bl	800541c <_SendPacket>
  RECORD_END();
 80060f2:	f386 8811 	msr	BASEPRI, r6
}
 80060f6:	b00b      	add	sp, #44	@ 0x2c
 80060f8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80060fc:	3c01      	subs	r4, #1
          c = *sFormat;
 80060fe:	7863      	ldrb	r3, [r4, #1]
 8006100:	1c61      	adds	r1, r4, #1
        if ((c == 'l') || (c == 'h')) {
 8006102:	f003 02fb 	and.w	r2, r3, #251	@ 0xfb
 8006106:	2a68      	cmp	r2, #104	@ 0x68
 8006108:	d02c      	beq.n	8006164 <_VPrintTarget+0x25c>
      switch (c) {
 800610a:	2b25      	cmp	r3, #37	@ 0x25
          sFormat++;
 800610c:	f104 0403 	add.w	r4, r4, #3
      switch (c) {
 8006110:	f47f af5f 	bne.w	8005fd2 <_VPrintTarget+0xca>
  Cnt = p->Cnt;
 8006114:	9a09      	ldr	r2, [sp, #36]	@ 0x24
  if ((Cnt + 1u) <= SEGGER_SYSVIEW_MAX_STRING_LEN) {
 8006116:	1c51      	adds	r1, r2, #1
 8006118:	2980      	cmp	r1, #128	@ 0x80
 800611a:	d805      	bhi.n	8006128 <_VPrintTarget+0x220>
    p->Cnt = Cnt + 1u;
 800611c:	460a      	mov	r2, r1
    *(p->pPayload++) = (U8)c;
 800611e:	9806      	ldr	r0, [sp, #24]
    p->Cnt = Cnt + 1u;
 8006120:	9109      	str	r1, [sp, #36]	@ 0x24
    *(p->pPayload++) = (U8)c;
 8006122:	7003      	strb	r3, [r0, #0]
 8006124:	3001      	adds	r0, #1
 8006126:	9006      	str	r0, [sp, #24]
  if (p->Cnt == SEGGER_SYSVIEW_MAX_STRING_LEN) {
 8006128:	2a80      	cmp	r2, #128	@ 0x80
 800612a:	f47f af17 	bne.w	8005f5c <_VPrintTarget+0x54>
    Options = p->Options;
 800612e:	9b08      	ldr	r3, [sp, #32]
    *(p->pPayloadStart) = (U8)p->Cnt;
 8006130:	9807      	ldr	r0, [sp, #28]
    ENCODE_U32(pPayload, Options);
 8006132:	2b7f      	cmp	r3, #127	@ 0x7f
    pPayload = p->pPayload;
 8006134:	9d06      	ldr	r5, [sp, #24]
    *(p->pPayloadStart) = (U8)p->Cnt;
 8006136:	7002      	strb	r2, [r0, #0]
    ENCODE_U32(pPayload, Options);
 8006138:	d906      	bls.n	8006148 <_VPrintTarget+0x240>
 800613a:	f063 027f 	orn	r2, r3, #127	@ 0x7f
 800613e:	09db      	lsrs	r3, r3, #7
 8006140:	2b7f      	cmp	r3, #127	@ 0x7f
 8006142:	f805 2b01 	strb.w	r2, [r5], #1
 8006146:	d8f8      	bhi.n	800613a <_VPrintTarget+0x232>
    ENCODE_U32(pPayload, 0);
 8006148:	2700      	movs	r7, #0
    _SendPacket(p->pPayloadStart, pPayload, SYSVIEW_EVTID_PRINT_FORMATTED);
 800614a:	221a      	movs	r2, #26
    ENCODE_U32(pPayload, Options);
 800614c:	702b      	strb	r3, [r5, #0]
    _SendPacket(p->pPayloadStart, pPayload, SYSVIEW_EVTID_PRINT_FORMATTED);
 800614e:	1ca9      	adds	r1, r5, #2
    ENCODE_U32(pPayload, 0);
 8006150:	706f      	strb	r7, [r5, #1]
    _SendPacket(p->pPayloadStart, pPayload, SYSVIEW_EVTID_PRINT_FORMATTED);
 8006152:	f7ff f963 	bl	800541c <_SendPacket>
    p->pPayloadStart = _PreparePacket(p->pBuffer);
 8006156:	9b05      	ldr	r3, [sp, #20]
    p->Cnt = 0u;
 8006158:	9709      	str	r7, [sp, #36]	@ 0x24
  return pPacket + _MAX_ID_BYTES + _MAX_DATA_BYTES;
 800615a:	1dda      	adds	r2, r3, #7
    p->pPayload = p->pPayloadStart + 1u;
 800615c:	3308      	adds	r3, #8
    p->pPayloadStart = _PreparePacket(p->pBuffer);
 800615e:	9207      	str	r2, [sp, #28]
    p->pPayload = p->pPayloadStart + 1u;
 8006160:	9306      	str	r3, [sp, #24]
}
 8006162:	e6fb      	b.n	8005f5c <_VPrintTarget+0x54>
 8006164:	460c      	mov	r4, r1
 8006166:	e7ca      	b.n	80060fe <_VPrintTarget+0x1f6>
        _PrintUnsigned(&BufferDesc, (unsigned int)v, 16u, NumDigits, FieldWidth, FormatFlags);
 8006168:	4653      	mov	r3, sl
 800616a:	2210      	movs	r2, #16
        v = va_arg(*pParamList, int);
 800616c:	f8db 0000 	ldr.w	r0, [fp]
        _PrintUnsigned(&BufferDesc, (unsigned int)v, 16u, NumDigits, FieldWidth, FormatFlags);
 8006170:	6801      	ldr	r1, [r0, #0]
        v = va_arg(*pParamList, int);
 8006172:	3004      	adds	r0, #4
        _PrintUnsigned(&BufferDesc, (unsigned int)v, 16u, NumDigits, FieldWidth, FormatFlags);
 8006174:	e9cd 5700 	strd	r5, r7, [sp]
        v = va_arg(*pParamList, int);
 8006178:	f8cb 0000 	str.w	r0, [fp]
        _PrintUnsigned(&BufferDesc, (unsigned int)v, 16u, NumDigits, FieldWidth, FormatFlags);
 800617c:	a805      	add	r0, sp, #20
 800617e:	f7ff fd09 	bl	8005b94 <_PrintUnsigned>
        break;
 8006182:	e6eb      	b.n	8005f5c <_VPrintTarget+0x54>
        v = va_arg(*pParamList, int);
 8006184:	f8db 1000 	ldr.w	r1, [fp]
  Cnt = p->Cnt;
 8006188:	9b09      	ldr	r3, [sp, #36]	@ 0x24
        v = va_arg(*pParamList, int);
 800618a:	1d0a      	adds	r2, r1, #4
 800618c:	f8cb 2000 	str.w	r2, [fp]
  if ((Cnt + 1u) <= SEGGER_SYSVIEW_MAX_STRING_LEN) {
 8006190:	1c5a      	adds	r2, r3, #1
 8006192:	2a80      	cmp	r2, #128	@ 0x80
 8006194:	d807      	bhi.n	80061a6 <_VPrintTarget+0x29e>
    p->Cnt = Cnt + 1u;
 8006196:	4613      	mov	r3, r2
    *(p->pPayload++) = (U8)c;
 8006198:	9806      	ldr	r0, [sp, #24]
        v = va_arg(*pParamList, int);
 800619a:	6809      	ldr	r1, [r1, #0]
    *(p->pPayload++) = (U8)c;
 800619c:	3001      	adds	r0, #1
        c0 = (char)v;
 800619e:	f800 1c01 	strb.w	r1, [r0, #-1]
    p->Cnt = Cnt + 1u;
 80061a2:	9209      	str	r2, [sp, #36]	@ 0x24
    *(p->pPayload++) = (U8)c;
 80061a4:	9006      	str	r0, [sp, #24]
  if (p->Cnt == SEGGER_SYSVIEW_MAX_STRING_LEN) {
 80061a6:	2b80      	cmp	r3, #128	@ 0x80
 80061a8:	f47f aed8 	bne.w	8005f5c <_VPrintTarget+0x54>
    *(p->pPayloadStart) = (U8)p->Cnt;
 80061ac:	9807      	ldr	r0, [sp, #28]
    pPayload = p->pPayload;
 80061ae:	9d06      	ldr	r5, [sp, #24]
    *(p->pPayloadStart) = (U8)p->Cnt;
 80061b0:	7003      	strb	r3, [r0, #0]
    Options = p->Options;
 80061b2:	9b08      	ldr	r3, [sp, #32]
    ENCODE_U32(pPayload, Options);
 80061b4:	2b7f      	cmp	r3, #127	@ 0x7f
 80061b6:	d9c7      	bls.n	8006148 <_VPrintTarget+0x240>
 80061b8:	f063 027f 	orn	r2, r3, #127	@ 0x7f
 80061bc:	09db      	lsrs	r3, r3, #7
 80061be:	2b7f      	cmp	r3, #127	@ 0x7f
 80061c0:	f805 2b01 	strb.w	r2, [r5], #1
 80061c4:	d8f8      	bhi.n	80061b8 <_VPrintTarget+0x2b0>
 80061c6:	e7bf      	b.n	8006148 <_VPrintTarget+0x240>
        _PrintUnsigned(&BufferDesc, (unsigned int)v, 10u, NumDigits, FieldWidth, FormatFlags);
 80061c8:	4653      	mov	r3, sl
 80061ca:	220a      	movs	r2, #10
        v = va_arg(*pParamList, int);
 80061cc:	f8db 0000 	ldr.w	r0, [fp]
 80061d0:	e7ce      	b.n	8006170 <_VPrintTarget+0x268>
 80061d2:	bf00      	nop
 80061d4:	20001934 	.word	0x20001934
        s = va_arg(*pParamList, const char*);
 80061d8:	f8db 3000 	ldr.w	r3, [fp]
          s = "(null)";
 80061dc:	4aad      	ldr	r2, [pc, #692]	@ (8006494 <_VPrintTarget+0x58c>)
        s = va_arg(*pParamList, const char*);
 80061de:	1d19      	adds	r1, r3, #4
 80061e0:	f8cb 1000 	str.w	r1, [fp]
 80061e4:	681d      	ldr	r5, [r3, #0]
    *(p->pPayloadStart) = (U8)p->Cnt;
 80061e6:	2780      	movs	r7, #128	@ 0x80
          s = "(null)";
 80061e8:	2d00      	cmp	r5, #0
 80061ea:	bf08      	it	eq
 80061ec:	4615      	moveq	r5, r2
    ENCODE_U32(pPayload, 0);
 80061ee:	f04f 0900 	mov.w	r9, #0
          c = *s;
 80061f2:	f815 3b01 	ldrb.w	r3, [r5], #1
          if (c == '\0') {
 80061f6:	2b00      	cmp	r3, #0
 80061f8:	f43f aeb0 	beq.w	8005f5c <_VPrintTarget+0x54>
  Cnt = p->Cnt;
 80061fc:	9a09      	ldr	r2, [sp, #36]	@ 0x24
  if ((Cnt + 1u) <= SEGGER_SYSVIEW_MAX_STRING_LEN) {
 80061fe:	1c51      	adds	r1, r2, #1
 8006200:	2980      	cmp	r1, #128	@ 0x80
 8006202:	f200 80b1 	bhi.w	8006368 <_VPrintTarget+0x460>
    p->Cnt = Cnt + 1u;
 8006206:	9109      	str	r1, [sp, #36]	@ 0x24
    *(p->pPayload++) = (U8)c;
 8006208:	9906      	ldr	r1, [sp, #24]
 800620a:	700b      	strb	r3, [r1, #0]
 800620c:	f101 0101 	add.w	r1, r1, #1
 8006210:	9106      	str	r1, [sp, #24]
  if (p->Cnt == SEGGER_SYSVIEW_MAX_STRING_LEN) {
 8006212:	d1ee      	bne.n	80061f2 <_VPrintTarget+0x2ea>
 8006214:	e0ac      	b.n	8006370 <_VPrintTarget+0x468>
        v = va_arg(*pParamList, int);
 8006216:	f8db 3000 	ldr.w	r3, [fp]
        _PrintUnsigned(&BufferDesc, (unsigned int)v, 16u, 8u, 8u, 0u);
 800621a:	681f      	ldr	r7, [r3, #0]
        v = va_arg(*pParamList, int);
 800621c:	3304      	adds	r3, #4
  while (Number >= Base) {
 800621e:	2f0f      	cmp	r7, #15
        v = va_arg(*pParamList, int);
 8006220:	f8cb 3000 	str.w	r3, [fp]
  while (Number >= Base) {
 8006224:	d903      	bls.n	800622e <_VPrintTarget+0x326>
  Number = v;
 8006226:	463b      	mov	r3, r7
    Number = (Number / Base);
 8006228:	091b      	lsrs	r3, r3, #4
  while (Number >= Base) {
 800622a:	2b0f      	cmp	r3, #15
 800622c:	d8fc      	bhi.n	8006228 <_VPrintTarget+0x320>
 800622e:	2501      	movs	r5, #1
 8006230:	2308      	movs	r3, #8
      NumDigits--;
 8006232:	3b01      	subs	r3, #1
    if (NumDigits > 1u) {       // User specified a min number of digits to print? => Make sure we loop at least that often, before checking anything else (> 1 check avoids problems with NumDigits being signed / unsigned)
 8006234:	2b01      	cmp	r3, #1
 8006236:	4629      	mov	r1, r5
    Digit *= Base;
 8006238:	ea4f 1505 	mov.w	r5, r5, lsl #4
    if (NumDigits > 1u) {       // User specified a min number of digits to print? => Make sure we loop at least that often, before checking anything else (> 1 check avoids problems with NumDigits being signed / unsigned)
 800623c:	d1f9      	bne.n	8006232 <_VPrintTarget+0x32a>
      Div = v / Digit;
 800623e:	fbb7 f3f5 	udiv	r3, r7, r5
      if (Div < Base) {        // Is our divider big enough to extract the highest digit from value? => Done
 8006242:	2b0f      	cmp	r3, #15
 8006244:	d909      	bls.n	800625a <_VPrintTarget+0x352>
    Digit *= Base;
 8006246:	020d      	lsls	r5, r1, #8
      Div = v / Digit;
 8006248:	fbb7 f3f5 	udiv	r3, r7, r5
      if (Div < Base) {        // Is our divider big enough to extract the highest digit from value? => Done
 800624c:	2b0f      	cmp	r3, #15
 800624e:	d904      	bls.n	800625a <_VPrintTarget+0x352>
    Digit *= Base;
 8006250:	012d      	lsls	r5, r5, #4
      Div = v / Digit;
 8006252:	fbb7 f3f5 	udiv	r3, r7, r5
      if (Div < Base) {        // Is our divider big enough to extract the highest digit from value? => Done
 8006256:	2b0f      	cmp	r3, #15
 8006258:	d8fa      	bhi.n	8006250 <_VPrintTarget+0x348>
  Cnt = p->Cnt;
 800625a:	9909      	ldr	r1, [sp, #36]	@ 0x24
    v -= Div * Digit;
 800625c:	fb05 7713 	mls	r7, r5, r3, r7
  if ((Cnt + 1u) <= SEGGER_SYSVIEW_MAX_STRING_LEN) {
 8006260:	1c4a      	adds	r2, r1, #1
 8006262:	2a80      	cmp	r2, #128	@ 0x80
 8006264:	bf98      	it	ls
 8006266:	4611      	movls	r1, r2
 8006268:	d93f      	bls.n	80062ea <_VPrintTarget+0x3e2>
  if (p->Cnt == SEGGER_SYSVIEW_MAX_STRING_LEN) {
 800626a:	2980      	cmp	r1, #128	@ 0x80
 800626c:	f040 816b 	bne.w	8006546 <_VPrintTarget+0x63e>
    Options = p->Options;
 8006270:	9b08      	ldr	r3, [sp, #32]
    *(p->pPayloadStart) = (U8)p->Cnt;
 8006272:	9807      	ldr	r0, [sp, #28]
    ENCODE_U32(pPayload, Options);
 8006274:	2b7f      	cmp	r3, #127	@ 0x7f
    *(p->pPayloadStart) = (U8)p->Cnt;
 8006276:	7001      	strb	r1, [r0, #0]
    pPayload = p->pPayload;
 8006278:	9906      	ldr	r1, [sp, #24]
    ENCODE_U32(pPayload, Options);
 800627a:	d906      	bls.n	800628a <_VPrintTarget+0x382>
 800627c:	f063 027f 	orn	r2, r3, #127	@ 0x7f
 8006280:	09db      	lsrs	r3, r3, #7
 8006282:	2b7f      	cmp	r3, #127	@ 0x7f
 8006284:	f801 2b01 	strb.w	r2, [r1], #1
 8006288:	d8f8      	bhi.n	800627c <_VPrintTarget+0x374>
 800628a:	700b      	strb	r3, [r1, #0]
    _SendPacket(p->pPayloadStart, pPayload, SYSVIEW_EVTID_PRINT_FORMATTED);
 800628c:	221a      	movs	r2, #26
    ENCODE_U32(pPayload, 0);
 800628e:	f881 8001 	strb.w	r8, [r1, #1]
    _SendPacket(p->pPayloadStart, pPayload, SYSVIEW_EVTID_PRINT_FORMATTED);
 8006292:	3102      	adds	r1, #2
 8006294:	f7ff f8c2 	bl	800541c <_SendPacket>
    p->pPayloadStart = _PreparePacket(p->pBuffer);
 8006298:	9b05      	ldr	r3, [sp, #20]
  } while (Digit);
 800629a:	2d0f      	cmp	r5, #15
  return pPacket + _MAX_ID_BYTES + _MAX_DATA_BYTES;
 800629c:	f103 0207 	add.w	r2, r3, #7
    p->pPayloadStart = _PreparePacket(p->pBuffer);
 80062a0:	9207      	str	r2, [sp, #28]
    p->pPayload = p->pPayloadStart + 1u;
 80062a2:	f103 0208 	add.w	r2, r3, #8
    p->Cnt = 0u;
 80062a6:	f8cd 8024 	str.w	r8, [sp, #36]	@ 0x24
    Digit /= Base;
 80062aa:	ea4f 1c15 	mov.w	ip, r5, lsr #4
    p->pPayload = p->pPayloadStart + 1u;
 80062ae:	9206      	str	r2, [sp, #24]
  } while (Digit);
 80062b0:	f67f ae54 	bls.w	8005f5c <_VPrintTarget+0x54>
    v -= Div * Digit;
 80062b4:	fbb7 f2fc 	udiv	r2, r7, ip
    p->Cnt = Cnt + 1u;
 80062b8:	2101      	movs	r1, #1
    _StoreChar(pBufferDesc, _aV2C[Div]);
 80062ba:	4877      	ldr	r0, [pc, #476]	@ (8006498 <_VPrintTarget+0x590>)
 80062bc:	fb0c 7712 	mls	r7, ip, r2, r7
 80062c0:	5c80      	ldrb	r0, [r0, r2]
    *(p->pPayload++) = (U8)c;
 80062c2:	f103 0509 	add.w	r5, r3, #9
 80062c6:	9506      	str	r5, [sp, #24]
 80062c8:	7218      	strb	r0, [r3, #8]
    p->Cnt = Cnt + 1u;
 80062ca:	9109      	str	r1, [sp, #36]	@ 0x24
  if ((Cnt + 1u) <= SEGGER_SYSVIEW_MAX_STRING_LEN) {
 80062cc:	1c48      	adds	r0, r1, #1
    v -= Div * Digit;
 80062ce:	4663      	mov	r3, ip
  } while (Digit);
 80062d0:	2b0f      	cmp	r3, #15
 80062d2:	ea4f 1c1c 	mov.w	ip, ip, lsr #4
 80062d6:	f67f ae41 	bls.w	8005f5c <_VPrintTarget+0x54>
 80062da:	fbb7 f3fc 	udiv	r3, r7, ip
  if ((Cnt + 1u) <= SEGGER_SYSVIEW_MAX_STRING_LEN) {
 80062de:	2880      	cmp	r0, #128	@ 0x80
 80062e0:	4601      	mov	r1, r0
 80062e2:	fb0c 7713 	mls	r7, ip, r3, r7
 80062e6:	d8f2      	bhi.n	80062ce <_VPrintTarget+0x3c6>
    Digit /= Base;
 80062e8:	4665      	mov	r5, ip
    _StoreChar(pBufferDesc, _aV2C[Div]);
 80062ea:	4a6b      	ldr	r2, [pc, #428]	@ (8006498 <_VPrintTarget+0x590>)
    *(p->pPayload++) = (U8)c;
 80062ec:	9806      	ldr	r0, [sp, #24]
    _StoreChar(pBufferDesc, _aV2C[Div]);
 80062ee:	5cd3      	ldrb	r3, [r2, r3]
    *(p->pPayload++) = (U8)c;
 80062f0:	3001      	adds	r0, #1
 80062f2:	f800 3c01 	strb.w	r3, [r0, #-1]
    p->Cnt = Cnt + 1u;
 80062f6:	9109      	str	r1, [sp, #36]	@ 0x24
    *(p->pPayload++) = (U8)c;
 80062f8:	9006      	str	r0, [sp, #24]
 80062fa:	e7b6      	b.n	800626a <_VPrintTarget+0x362>
        v = va_arg(*pParamList, int);
 80062fc:	f8db 3000 	ldr.w	r3, [fp]
  Width = 1u;
 8006300:	2101      	movs	r1, #1
        v = va_arg(*pParamList, int);
 8006302:	f8d3 9000 	ldr.w	r9, [r3]
 8006306:	3304      	adds	r3, #4
 8006308:	f8cb 3000 	str.w	r3, [fp]
  Number = (v < 0) ? -v : v;
 800630c:	ea89 73e9 	eor.w	r3, r9, r9, asr #31
 8006310:	eba3 73e9 	sub.w	r3, r3, r9, asr #31
  while (Number >= (int)Base) {
 8006314:	2b09      	cmp	r3, #9
 8006316:	dd09      	ble.n	800632c <_VPrintTarget+0x424>
    Number = (Number / (int)Base);
 8006318:	4860      	ldr	r0, [pc, #384]	@ (800649c <_VPrintTarget+0x594>)
 800631a:	461a      	mov	r2, r3
 800631c:	fba0 c303 	umull	ip, r3, r0, r3
  while (Number >= (int)Base) {
 8006320:	2a63      	cmp	r2, #99	@ 0x63
    Width++;
 8006322:	f101 0101 	add.w	r1, r1, #1
    Number = (Number / (int)Base);
 8006326:	ea4f 03d3 	mov.w	r3, r3, lsr #3
  while (Number >= (int)Base) {
 800632a:	dcf6      	bgt.n	800631a <_VPrintTarget+0x412>
  if (NumDigits > Width) {
 800632c:	4551      	cmp	r1, sl
 800632e:	bf38      	it	cc
 8006330:	4651      	movcc	r1, sl
 8006332:	9103      	str	r1, [sp, #12]
  if ((FieldWidth > 0u) && ((v < 0) || ((FormatFlags & FORMAT_FLAG_PRINT_SIGN) == FORMAT_FLAG_PRINT_SIGN))) {
 8006334:	2d00      	cmp	r5, #0
 8006336:	d14d      	bne.n	80063d4 <_VPrintTarget+0x4cc>
 8006338:	2500      	movs	r5, #0
  if (v < 0) {
 800633a:	f1b9 0f00 	cmp.w	r9, #0
 800633e:	f2c0 80d9 	blt.w	80064f4 <_VPrintTarget+0x5ec>
 8006342:	f007 0304 	and.w	r3, r7, #4
  } else if ((FormatFlags & FORMAT_FLAG_PRINT_SIGN) == FORMAT_FLAG_PRINT_SIGN) {
 8006346:	2b00      	cmp	r3, #0
 8006348:	f040 80ff 	bne.w	800654a <_VPrintTarget+0x642>
  if (((FormatFlags & FORMAT_FLAG_PAD_ZERO) == FORMAT_FLAG_PAD_ZERO) && ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u) && (NumDigits == 0u)) {
 800634c:	f007 0303 	and.w	r3, r7, #3
 8006350:	2b02      	cmp	r3, #2
 8006352:	f000 80a5 	beq.w	80064a0 <_VPrintTarget+0x598>
  _PrintUnsigned(pBufferDesc, (unsigned int)v, Base, NumDigits, FieldWidth, FormatFlags);
 8006356:	4653      	mov	r3, sl
 8006358:	4649      	mov	r1, r9
 800635a:	220a      	movs	r2, #10
 800635c:	e9cd 5700 	strd	r5, r7, [sp]
 8006360:	a805      	add	r0, sp, #20
 8006362:	f7ff fc17 	bl	8005b94 <_PrintUnsigned>
}
 8006366:	e5f9      	b.n	8005f5c <_VPrintTarget+0x54>
  if (p->Cnt == SEGGER_SYSVIEW_MAX_STRING_LEN) {
 8006368:	2a80      	cmp	r2, #128	@ 0x80
 800636a:	f47f adf7 	bne.w	8005f5c <_VPrintTarget+0x54>
 800636e:	9906      	ldr	r1, [sp, #24]
    Options = p->Options;
 8006370:	9b08      	ldr	r3, [sp, #32]
    *(p->pPayloadStart) = (U8)p->Cnt;
 8006372:	9807      	ldr	r0, [sp, #28]
    ENCODE_U32(pPayload, Options);
 8006374:	2b7f      	cmp	r3, #127	@ 0x7f
    *(p->pPayloadStart) = (U8)p->Cnt;
 8006376:	7007      	strb	r7, [r0, #0]
    ENCODE_U32(pPayload, Options);
 8006378:	d906      	bls.n	8006388 <_VPrintTarget+0x480>
 800637a:	f063 027f 	orn	r2, r3, #127	@ 0x7f
 800637e:	09db      	lsrs	r3, r3, #7
 8006380:	2b7f      	cmp	r3, #127	@ 0x7f
 8006382:	f801 2b01 	strb.w	r2, [r1], #1
 8006386:	d8f8      	bhi.n	800637a <_VPrintTarget+0x472>
 8006388:	700b      	strb	r3, [r1, #0]
    _SendPacket(p->pPayloadStart, pPayload, SYSVIEW_EVTID_PRINT_FORMATTED);
 800638a:	221a      	movs	r2, #26
    ENCODE_U32(pPayload, 0);
 800638c:	f881 9001 	strb.w	r9, [r1, #1]
    _SendPacket(p->pPayloadStart, pPayload, SYSVIEW_EVTID_PRINT_FORMATTED);
 8006390:	3102      	adds	r1, #2
 8006392:	f7ff f843 	bl	800541c <_SendPacket>
    p->pPayloadStart = _PreparePacket(p->pBuffer);
 8006396:	9b05      	ldr	r3, [sp, #20]
    p->Cnt = 0u;
 8006398:	f8cd 9024 	str.w	r9, [sp, #36]	@ 0x24
  return pPacket + _MAX_ID_BYTES + _MAX_DATA_BYTES;
 800639c:	1dda      	adds	r2, r3, #7
    p->pPayload = p->pPayloadStart + 1u;
 800639e:	3308      	adds	r3, #8
    p->pPayloadStart = _PreparePacket(p->pBuffer);
 80063a0:	9207      	str	r2, [sp, #28]
    p->pPayload = p->pPayloadStart + 1u;
 80063a2:	9306      	str	r3, [sp, #24]
        } while (BufferDesc.Cnt < SEGGER_SYSVIEW_MAX_STRING_LEN);
 80063a4:	e725      	b.n	80061f2 <_VPrintTarget+0x2ea>
          c = *sFormat;
 80063a6:	7863      	ldrb	r3, [r4, #1]
      NumDigits = 0u;
 80063a8:	f04f 0a00 	mov.w	sl, #0
          if ((c < '0') || (c > '9')) {
 80063ac:	f1a3 0230 	sub.w	r2, r3, #48	@ 0x30
 80063b0:	2a09      	cmp	r2, #9
        sFormat++;
 80063b2:	f104 0401 	add.w	r4, r4, #1
          if ((c < '0') || (c > '9')) {
 80063b6:	f63f ae02 	bhi.w	8005fbe <_VPrintTarget+0xb6>
          NumDigits = NumDigits * 10u + ((unsigned int)c - '0');
 80063ba:	eb0a 0a8a 	add.w	sl, sl, sl, lsl #2
 80063be:	eb03 0a4a 	add.w	sl, r3, sl, lsl #1
          c = *sFormat;
 80063c2:	f814 3f01 	ldrb.w	r3, [r4, #1]!
          NumDigits = NumDigits * 10u + ((unsigned int)c - '0');
 80063c6:	f1aa 0a30 	sub.w	sl, sl, #48	@ 0x30
          if ((c < '0') || (c > '9')) {
 80063ca:	f1a3 0230 	sub.w	r2, r3, #48	@ 0x30
 80063ce:	2a09      	cmp	r2, #9
 80063d0:	d9f3      	bls.n	80063ba <_VPrintTarget+0x4b2>
 80063d2:	e5f4      	b.n	8005fbe <_VPrintTarget+0xb6>
  if ((FieldWidth > 0u) && ((v < 0) || ((FormatFlags & FORMAT_FLAG_PRINT_SIGN) == FORMAT_FLAG_PRINT_SIGN))) {
 80063d4:	f1b9 0f00 	cmp.w	r9, #0
  if ((((FormatFlags & FORMAT_FLAG_PAD_ZERO) == 0u) || (NumDigits != 0u)) && ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u)) {
 80063d8:	f007 0202 	and.w	r2, r7, #2
  if ((FieldWidth > 0u) && ((v < 0) || ((FormatFlags & FORMAT_FLAG_PRINT_SIGN) == FORMAT_FLAG_PRINT_SIGN))) {
 80063dc:	f2c0 8082 	blt.w	80064e4 <_VPrintTarget+0x5dc>
 80063e0:	f017 0304 	ands.w	r3, r7, #4
 80063e4:	f040 80ea 	bne.w	80065bc <_VPrintTarget+0x6b4>
  if ((((FormatFlags & FORMAT_FLAG_PAD_ZERO) == 0u) || (NumDigits != 0u)) && ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u)) {
 80063e8:	2a00      	cmp	r2, #0
 80063ea:	f000 811b 	beq.w	8006624 <_VPrintTarget+0x71c>
 80063ee:	f1ba 0f00 	cmp.w	sl, #0
 80063f2:	f000 8120 	beq.w	8006636 <_VPrintTarget+0x72e>
 80063f6:	07f8      	lsls	r0, r7, #31
 80063f8:	d4ad      	bmi.n	8006356 <_VPrintTarget+0x44e>
      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
 80063fa:	428d      	cmp	r5, r1
 80063fc:	d9a6      	bls.n	800634c <_VPrintTarget+0x444>
  Cnt = p->Cnt;
 80063fe:	9b09      	ldr	r3, [sp, #36]	@ 0x24
        FieldWidth--;
 8006400:	3d01      	subs	r5, #1
  if ((Cnt + 1u) <= SEGGER_SYSVIEW_MAX_STRING_LEN) {
 8006402:	1c5a      	adds	r2, r3, #1
 8006404:	2a80      	cmp	r2, #128	@ 0x80
 8006406:	f240 811c 	bls.w	8006642 <_VPrintTarget+0x73a>
  if (p->Cnt == SEGGER_SYSVIEW_MAX_STRING_LEN) {
 800640a:	2b80      	cmp	r3, #128	@ 0x80
 800640c:	d12d      	bne.n	800646a <_VPrintTarget+0x562>
    *(p->pPayloadStart) = (U8)p->Cnt;
 800640e:	9807      	ldr	r0, [sp, #28]
    pPayload = p->pPayload;
 8006410:	f8dd c018 	ldr.w	ip, [sp, #24]
    *(p->pPayloadStart) = (U8)p->Cnt;
 8006414:	7003      	strb	r3, [r0, #0]
    Options = p->Options;
 8006416:	9b08      	ldr	r3, [sp, #32]
    ENCODE_U32(pPayload, Options);
 8006418:	2b7f      	cmp	r3, #127	@ 0x7f
 800641a:	d906      	bls.n	800642a <_VPrintTarget+0x522>
 800641c:	f063 027f 	orn	r2, r3, #127	@ 0x7f
 8006420:	09db      	lsrs	r3, r3, #7
 8006422:	2b7f      	cmp	r3, #127	@ 0x7f
 8006424:	f80c 2b01 	strb.w	r2, [ip], #1
 8006428:	d8f8      	bhi.n	800641c <_VPrintTarget+0x514>
 800642a:	f88c 3000 	strb.w	r3, [ip]
    ENCODE_U32(pPayload, 0);
 800642e:	2300      	movs	r3, #0
    _SendPacket(p->pPayloadStart, pPayload, SYSVIEW_EVTID_PRINT_FORMATTED);
 8006430:	221a      	movs	r2, #26
    ENCODE_U32(pPayload, 0);
 8006432:	f88c 3001 	strb.w	r3, [ip, #1]
    _SendPacket(p->pPayloadStart, pPayload, SYSVIEW_EVTID_PRINT_FORMATTED);
 8006436:	f10c 0102 	add.w	r1, ip, #2
 800643a:	f7fe ffef 	bl	800541c <_SendPacket>
    p->Cnt = 0u;
 800643e:	2300      	movs	r3, #0
    p->pPayloadStart = _PreparePacket(p->pBuffer);
 8006440:	9a05      	ldr	r2, [sp, #20]
    p->Cnt = 0u;
 8006442:	9309      	str	r3, [sp, #36]	@ 0x24
  return pPacket + _MAX_ID_BYTES + _MAX_DATA_BYTES;
 8006444:	1dd3      	adds	r3, r2, #7
    p->pPayloadStart = _PreparePacket(p->pBuffer);
 8006446:	9307      	str	r3, [sp, #28]
    p->pPayload = p->pPayloadStart + 1u;
 8006448:	f102 0308 	add.w	r3, r2, #8
 800644c:	9306      	str	r3, [sp, #24]
      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
 800644e:	2d00      	cmp	r5, #0
 8006450:	f43f af72 	beq.w	8006338 <_VPrintTarget+0x430>
 8006454:	9b03      	ldr	r3, [sp, #12]
 8006456:	42ab      	cmp	r3, r5
 8006458:	f000 80be 	beq.w	80065d8 <_VPrintTarget+0x6d0>
    *(p->pPayload++) = (U8)c;
 800645c:	2120      	movs	r1, #32
    p->Cnt = Cnt + 1u;
 800645e:	2301      	movs	r3, #1
    *(p->pPayload++) = (U8)c;
 8006460:	7211      	strb	r1, [r2, #8]
 8006462:	3209      	adds	r2, #9
        FieldWidth--;
 8006464:	3d01      	subs	r5, #1
    *(p->pPayload++) = (U8)c;
 8006466:	9206      	str	r2, [sp, #24]
    p->Cnt = Cnt + 1u;
 8006468:	9309      	str	r3, [sp, #36]	@ 0x24
  if ((Cnt + 1u) <= SEGGER_SYSVIEW_MAX_STRING_LEN) {
 800646a:	9903      	ldr	r1, [sp, #12]
 800646c:	1c5a      	adds	r2, r3, #1
      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
 800646e:	2d00      	cmp	r5, #0
 8006470:	f43f af62 	beq.w	8006338 <_VPrintTarget+0x430>
 8006474:	42a9      	cmp	r1, r5
        FieldWidth--;
 8006476:	f105 35ff 	add.w	r5, r5, #4294967295
      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
 800647a:	f000 80da 	beq.w	8006632 <_VPrintTarget+0x72a>
  if ((Cnt + 1u) <= SEGGER_SYSVIEW_MAX_STRING_LEN) {
 800647e:	2a80      	cmp	r2, #128	@ 0x80
 8006480:	4613      	mov	r3, r2
 8006482:	d8f4      	bhi.n	800646e <_VPrintTarget+0x566>
    *(p->pPayload++) = (U8)c;
 8006484:	2120      	movs	r1, #32
 8006486:	9a06      	ldr	r2, [sp, #24]
    p->Cnt = Cnt + 1u;
 8006488:	9309      	str	r3, [sp, #36]	@ 0x24
    *(p->pPayload++) = (U8)c;
 800648a:	7011      	strb	r1, [r2, #0]
 800648c:	3201      	adds	r2, #1
 800648e:	9206      	str	r2, [sp, #24]
 8006490:	e7bb      	b.n	800640a <_VPrintTarget+0x502>
 8006492:	bf00      	nop
 8006494:	08006f14 	.word	0x08006f14
 8006498:	08006f60 	.word	0x08006f60
 800649c:	cccccccd 	.word	0xcccccccd
  if (((FormatFlags & FORMAT_FLAG_PAD_ZERO) == FORMAT_FLAG_PAD_ZERO) && ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u) && (NumDigits == 0u)) {
 80064a0:	f1ba 0f00 	cmp.w	sl, #0
 80064a4:	f47f af57 	bne.w	8006356 <_VPrintTarget+0x44e>
    if (FieldWidth != 0u) {
 80064a8:	2d00      	cmp	r5, #0
 80064aa:	f43f af54 	beq.w	8006356 <_VPrintTarget+0x44e>
      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
 80064ae:	9a03      	ldr	r2, [sp, #12]
 80064b0:	4295      	cmp	r5, r2
 80064b2:	f67f af50 	bls.w	8006356 <_VPrintTarget+0x44e>
    ENCODE_U32(pPayload, 0);
 80064b6:	9403      	str	r4, [sp, #12]
 80064b8:	2300      	movs	r3, #0
 80064ba:	4614      	mov	r4, r2
  Cnt = p->Cnt;
 80064bc:	9a09      	ldr	r2, [sp, #36]	@ 0x24
        FieldWidth--;
 80064be:	3d01      	subs	r5, #1
  if ((Cnt + 1u) <= SEGGER_SYSVIEW_MAX_STRING_LEN) {
 80064c0:	1c51      	adds	r1, r2, #1
 80064c2:	2980      	cmp	r1, #128	@ 0x80
 80064c4:	d807      	bhi.n	80064d6 <_VPrintTarget+0x5ce>
    *(p->pPayload++) = (U8)c;
 80064c6:	f04f 0030 	mov.w	r0, #48	@ 0x30
    p->Cnt = Cnt + 1u;
 80064ca:	460a      	mov	r2, r1
 80064cc:	9109      	str	r1, [sp, #36]	@ 0x24
    *(p->pPayload++) = (U8)c;
 80064ce:	9906      	ldr	r1, [sp, #24]
 80064d0:	7008      	strb	r0, [r1, #0]
 80064d2:	3101      	adds	r1, #1
 80064d4:	9106      	str	r1, [sp, #24]
  if (p->Cnt == SEGGER_SYSVIEW_MAX_STRING_LEN) {
 80064d6:	2a80      	cmp	r2, #128	@ 0x80
 80064d8:	d055      	beq.n	8006586 <_VPrintTarget+0x67e>
      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
 80064da:	b10d      	cbz	r5, 80064e0 <_VPrintTarget+0x5d8>
 80064dc:	42ac      	cmp	r4, r5
 80064de:	d1ed      	bne.n	80064bc <_VPrintTarget+0x5b4>
 80064e0:	9c03      	ldr	r4, [sp, #12]
 80064e2:	e738      	b.n	8006356 <_VPrintTarget+0x44e>
    FieldWidth--;
 80064e4:	3d01      	subs	r5, #1
  if ((((FormatFlags & FORMAT_FLAG_PAD_ZERO) == 0u) || (NumDigits != 0u)) && ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u)) {
 80064e6:	2a00      	cmp	r2, #0
 80064e8:	f000 8086 	beq.w	80065f8 <_VPrintTarget+0x6f0>
 80064ec:	f1ba 0f00 	cmp.w	sl, #0
 80064f0:	f040 8082 	bne.w	80065f8 <_VPrintTarget+0x6f0>
  Cnt = p->Cnt;
 80064f4:	9b09      	ldr	r3, [sp, #36]	@ 0x24
    v = -v;
 80064f6:	f1c9 0900 	rsb	r9, r9, #0
  if ((Cnt + 1u) <= SEGGER_SYSVIEW_MAX_STRING_LEN) {
 80064fa:	1c5a      	adds	r2, r3, #1
 80064fc:	2a80      	cmp	r2, #128	@ 0x80
 80064fe:	d973      	bls.n	80065e8 <_VPrintTarget+0x6e0>
  if (p->Cnt == SEGGER_SYSVIEW_MAX_STRING_LEN) {
 8006500:	2b80      	cmp	r3, #128	@ 0x80
 8006502:	f47f af23 	bne.w	800634c <_VPrintTarget+0x444>
    *(p->pPayloadStart) = (U8)p->Cnt;
 8006506:	9807      	ldr	r0, [sp, #28]
    pPayload = p->pPayload;
 8006508:	f8dd c018 	ldr.w	ip, [sp, #24]
    *(p->pPayloadStart) = (U8)p->Cnt;
 800650c:	7003      	strb	r3, [r0, #0]
    Options = p->Options;
 800650e:	9b08      	ldr	r3, [sp, #32]
    ENCODE_U32(pPayload, Options);
 8006510:	2b7f      	cmp	r3, #127	@ 0x7f
 8006512:	d906      	bls.n	8006522 <_VPrintTarget+0x61a>
 8006514:	f063 027f 	orn	r2, r3, #127	@ 0x7f
 8006518:	09db      	lsrs	r3, r3, #7
 800651a:	2b7f      	cmp	r3, #127	@ 0x7f
 800651c:	f80c 2b01 	strb.w	r2, [ip], #1
 8006520:	d8f8      	bhi.n	8006514 <_VPrintTarget+0x60c>
 8006522:	f88c 3000 	strb.w	r3, [ip]
    ENCODE_U32(pPayload, 0);
 8006526:	2300      	movs	r3, #0
    _SendPacket(p->pPayloadStart, pPayload, SYSVIEW_EVTID_PRINT_FORMATTED);
 8006528:	221a      	movs	r2, #26
    ENCODE_U32(pPayload, 0);
 800652a:	f88c 3001 	strb.w	r3, [ip, #1]
    _SendPacket(p->pPayloadStart, pPayload, SYSVIEW_EVTID_PRINT_FORMATTED);
 800652e:	f10c 0102 	add.w	r1, ip, #2
 8006532:	f7fe ff73 	bl	800541c <_SendPacket>
    p->Cnt = 0u;
 8006536:	2300      	movs	r3, #0
 8006538:	9309      	str	r3, [sp, #36]	@ 0x24
    p->pPayloadStart = _PreparePacket(p->pBuffer);
 800653a:	9b05      	ldr	r3, [sp, #20]
  return pPacket + _MAX_ID_BYTES + _MAX_DATA_BYTES;
 800653c:	1dda      	adds	r2, r3, #7
    p->pPayload = p->pPayloadStart + 1u;
 800653e:	3308      	adds	r3, #8
    p->pPayloadStart = _PreparePacket(p->pBuffer);
 8006540:	9207      	str	r2, [sp, #28]
    p->pPayload = p->pPayloadStart + 1u;
 8006542:	9306      	str	r3, [sp, #24]
}
 8006544:	e702      	b.n	800634c <_VPrintTarget+0x444>
 8006546:	46ac      	mov	ip, r5
 8006548:	e6c0      	b.n	80062cc <_VPrintTarget+0x3c4>
  Cnt = p->Cnt;
 800654a:	9a09      	ldr	r2, [sp, #36]	@ 0x24
  if ((Cnt + 1u) <= SEGGER_SYSVIEW_MAX_STRING_LEN) {
 800654c:	1c53      	adds	r3, r2, #1
 800654e:	2b80      	cmp	r3, #128	@ 0x80
 8006550:	d806      	bhi.n	8006560 <_VPrintTarget+0x658>
    *(p->pPayload++) = (U8)c;
 8006552:	212b      	movs	r1, #43	@ 0x2b
    p->Cnt = Cnt + 1u;
 8006554:	461a      	mov	r2, r3
 8006556:	9309      	str	r3, [sp, #36]	@ 0x24
    *(p->pPayload++) = (U8)c;
 8006558:	9b06      	ldr	r3, [sp, #24]
 800655a:	7019      	strb	r1, [r3, #0]
 800655c:	3301      	adds	r3, #1
 800655e:	9306      	str	r3, [sp, #24]
  if (p->Cnt == SEGGER_SYSVIEW_MAX_STRING_LEN) {
 8006560:	2a80      	cmp	r2, #128	@ 0x80
 8006562:	f47f aef3 	bne.w	800634c <_VPrintTarget+0x444>
    *(p->pPayloadStart) = (U8)p->Cnt;
 8006566:	2380      	movs	r3, #128	@ 0x80
 8006568:	9807      	ldr	r0, [sp, #28]
    pPayload = p->pPayload;
 800656a:	f8dd c018 	ldr.w	ip, [sp, #24]
    *(p->pPayloadStart) = (U8)p->Cnt;
 800656e:	7003      	strb	r3, [r0, #0]
    Options = p->Options;
 8006570:	9b08      	ldr	r3, [sp, #32]
    ENCODE_U32(pPayload, Options);
 8006572:	2b7f      	cmp	r3, #127	@ 0x7f
 8006574:	d9d5      	bls.n	8006522 <_VPrintTarget+0x61a>
 8006576:	f063 027f 	orn	r2, r3, #127	@ 0x7f
 800657a:	09db      	lsrs	r3, r3, #7
 800657c:	2b7f      	cmp	r3, #127	@ 0x7f
 800657e:	f80c 2b01 	strb.w	r2, [ip], #1
 8006582:	d8f8      	bhi.n	8006576 <_VPrintTarget+0x66e>
 8006584:	e7cd      	b.n	8006522 <_VPrintTarget+0x61a>
    *(p->pPayloadStart) = (U8)p->Cnt;
 8006586:	9807      	ldr	r0, [sp, #28]
    pPayload = p->pPayload;
 8006588:	9906      	ldr	r1, [sp, #24]
    *(p->pPayloadStart) = (U8)p->Cnt;
 800658a:	7002      	strb	r2, [r0, #0]
    Options = p->Options;
 800658c:	9a08      	ldr	r2, [sp, #32]
    ENCODE_U32(pPayload, Options);
 800658e:	2a7f      	cmp	r2, #127	@ 0x7f
 8006590:	d906      	bls.n	80065a0 <_VPrintTarget+0x698>
 8006592:	f062 0c7f 	orn	ip, r2, #127	@ 0x7f
 8006596:	09d2      	lsrs	r2, r2, #7
 8006598:	2a7f      	cmp	r2, #127	@ 0x7f
 800659a:	f801 cb01 	strb.w	ip, [r1], #1
 800659e:	d8f8      	bhi.n	8006592 <_VPrintTarget+0x68a>
 80065a0:	700a      	strb	r2, [r1, #0]
    ENCODE_U32(pPayload, 0);
 80065a2:	704b      	strb	r3, [r1, #1]
    _SendPacket(p->pPayloadStart, pPayload, SYSVIEW_EVTID_PRINT_FORMATTED);
 80065a4:	221a      	movs	r2, #26
 80065a6:	3102      	adds	r1, #2
 80065a8:	f7fe ff38 	bl	800541c <_SendPacket>
    p->Cnt = 0u;
 80065ac:	2300      	movs	r3, #0
    p->pPayloadStart = _PreparePacket(p->pBuffer);
 80065ae:	9a05      	ldr	r2, [sp, #20]
    p->Cnt = 0u;
 80065b0:	9309      	str	r3, [sp, #36]	@ 0x24
  return pPacket + _MAX_ID_BYTES + _MAX_DATA_BYTES;
 80065b2:	1dd1      	adds	r1, r2, #7
    p->pPayload = p->pPayloadStart + 1u;
 80065b4:	3208      	adds	r2, #8
    p->pPayloadStart = _PreparePacket(p->pBuffer);
 80065b6:	9107      	str	r1, [sp, #28]
    p->pPayload = p->pPayloadStart + 1u;
 80065b8:	9206      	str	r2, [sp, #24]
}
 80065ba:	e78e      	b.n	80064da <_VPrintTarget+0x5d2>
    FieldWidth--;
 80065bc:	3d01      	subs	r5, #1
  if ((((FormatFlags & FORMAT_FLAG_PAD_ZERO) == 0u) || (NumDigits != 0u)) && ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u)) {
 80065be:	b32a      	cbz	r2, 800660c <_VPrintTarget+0x704>
 80065c0:	f1ba 0f00 	cmp.w	sl, #0
 80065c4:	d0c1      	beq.n	800654a <_VPrintTarget+0x642>
 80065c6:	07fa      	lsls	r2, r7, #31
 80065c8:	d4bf      	bmi.n	800654a <_VPrintTarget+0x642>
    if (FieldWidth != 0u) {
 80065ca:	2d00      	cmp	r5, #0
 80065cc:	f43f aebb 	beq.w	8006346 <_VPrintTarget+0x43e>
      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
 80065d0:	42a9      	cmp	r1, r5
 80065d2:	f4ff af14 	bcc.w	80063fe <_VPrintTarget+0x4f6>
 80065d6:	e6b6      	b.n	8006346 <_VPrintTarget+0x43e>
  if (v < 0) {
 80065d8:	f1b9 0f00 	cmp.w	r9, #0
 80065dc:	461d      	mov	r5, r3
 80065de:	f6bf aeb0 	bge.w	8006342 <_VPrintTarget+0x43a>
  if ((Cnt + 1u) <= SEGGER_SYSVIEW_MAX_STRING_LEN) {
 80065e2:	2201      	movs	r2, #1
    v = -v;
 80065e4:	f1c9 0900 	rsb	r9, r9, #0
    *(p->pPayload++) = (U8)c;
 80065e8:	212d      	movs	r1, #45	@ 0x2d
    p->Cnt = Cnt + 1u;
 80065ea:	4613      	mov	r3, r2
 80065ec:	9209      	str	r2, [sp, #36]	@ 0x24
    *(p->pPayload++) = (U8)c;
 80065ee:	9a06      	ldr	r2, [sp, #24]
 80065f0:	7011      	strb	r1, [r2, #0]
 80065f2:	3201      	adds	r2, #1
 80065f4:	9206      	str	r2, [sp, #24]
 80065f6:	e783      	b.n	8006500 <_VPrintTarget+0x5f8>
  if ((((FormatFlags & FORMAT_FLAG_PAD_ZERO) == 0u) || (NumDigits != 0u)) && ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u)) {
 80065f8:	07fb      	lsls	r3, r7, #31
 80065fa:	f53f af7b 	bmi.w	80064f4 <_VPrintTarget+0x5ec>
    if (FieldWidth != 0u) {
 80065fe:	2d00      	cmp	r5, #0
 8006600:	f43f af78 	beq.w	80064f4 <_VPrintTarget+0x5ec>
      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
 8006604:	42a9      	cmp	r1, r5
 8006606:	f4ff aefa 	bcc.w	80063fe <_VPrintTarget+0x4f6>
 800660a:	e773      	b.n	80064f4 <_VPrintTarget+0x5ec>
  if ((((FormatFlags & FORMAT_FLAG_PAD_ZERO) == 0u) || (NumDigits != 0u)) && ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u)) {
 800660c:	07fa      	lsls	r2, r7, #31
 800660e:	d401      	bmi.n	8006614 <_VPrintTarget+0x70c>
    if (FieldWidth != 0u) {
 8006610:	2d00      	cmp	r5, #0
 8006612:	d1dd      	bne.n	80065d0 <_VPrintTarget+0x6c8>
  Cnt = p->Cnt;
 8006614:	9a09      	ldr	r2, [sp, #36]	@ 0x24
  if ((Cnt + 1u) <= SEGGER_SYSVIEW_MAX_STRING_LEN) {
 8006616:	1c53      	adds	r3, r2, #1
 8006618:	2b80      	cmp	r3, #128	@ 0x80
 800661a:	d99a      	bls.n	8006552 <_VPrintTarget+0x64a>
  if (p->Cnt == SEGGER_SYSVIEW_MAX_STRING_LEN) {
 800661c:	2a80      	cmp	r2, #128	@ 0x80
 800661e:	f47f ae9a 	bne.w	8006356 <_VPrintTarget+0x44e>
 8006622:	e7a0      	b.n	8006566 <_VPrintTarget+0x65e>
  if ((((FormatFlags & FORMAT_FLAG_PAD_ZERO) == 0u) || (NumDigits != 0u)) && ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u)) {
 8006624:	07f8      	lsls	r0, r7, #31
 8006626:	f53f ae96 	bmi.w	8006356 <_VPrintTarget+0x44e>
      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
 800662a:	428d      	cmp	r5, r1
 800662c:	f63f aee7 	bhi.w	80063fe <_VPrintTarget+0x4f6>
 8006630:	e691      	b.n	8006356 <_VPrintTarget+0x44e>
 8006632:	9d03      	ldr	r5, [sp, #12]
 8006634:	e681      	b.n	800633a <_VPrintTarget+0x432>
  if (((FormatFlags & FORMAT_FLAG_PAD_ZERO) == FORMAT_FLAG_PAD_ZERO) && ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u) && (NumDigits == 0u)) {
 8006636:	f007 0303 	and.w	r3, r7, #3
 800663a:	2b02      	cmp	r3, #2
 800663c:	f47f ae8b 	bne.w	8006356 <_VPrintTarget+0x44e>
 8006640:	e735      	b.n	80064ae <_VPrintTarget+0x5a6>
 8006642:	4613      	mov	r3, r2
 8006644:	e71e      	b.n	8006484 <_VPrintTarget+0x57c>
 8006646:	bf00      	nop

08006648 <SEGGER_SYSVIEW_RecordExitISR>:
void SEGGER_SYSVIEW_RecordExitISR(void) {
 8006648:	b5f0      	push	{r4, r5, r6, r7, lr}
 800664a:	b085      	sub	sp, #20
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE);
 800664c:	f3ef 8511 	mrs	r5, BASEPRI
 8006650:	f04f 0120 	mov.w	r1, #32
 8006654:	f381 8811 	msr	BASEPRI, r1
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
 8006658:	4c3d      	ldr	r4, [pc, #244]	@ (8006750 <SEGGER_SYSVIEW_RecordExitISR+0x108>)
 800665a:	7823      	ldrb	r3, [r4, #0]
 800665c:	2b01      	cmp	r3, #1
 800665e:	d002      	beq.n	8006666 <SEGGER_SYSVIEW_RecordExitISR+0x1e>
  if (_SYSVIEW_Globals.EnableState == 0) {
 8006660:	b313      	cbz	r3, 80066a8 <SEGGER_SYSVIEW_RecordExitISR+0x60>
  if (_SYSVIEW_Globals.EnableState == 2) {
 8006662:	2b02      	cmp	r3, #2
 8006664:	d03d      	beq.n	80066e2 <SEGGER_SYSVIEW_RecordExitISR+0x9a>
    if (_SYSVIEW_Globals.DisabledEvents & ((U32)1u << EventId)) {
 8006666:	69e3      	ldr	r3, [r4, #28]
 8006668:	071b      	lsls	r3, r3, #28
 800666a:	d41d      	bmi.n	80066a8 <SEGGER_SYSVIEW_RecordExitISR+0x60>
    *--pStartPacket = (U8)EventId;
 800666c:	2103      	movs	r1, #3
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
 800666e:	4a39      	ldr	r2, [pc, #228]	@ (8006754 <SEGGER_SYSVIEW_RecordExitISR+0x10c>)
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
 8006670:	68e3      	ldr	r3, [r4, #12]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
 8006672:	6856      	ldr	r6, [r2, #4]
    *--pStartPacket = (U8)EventId;
 8006674:	4a38      	ldr	r2, [pc, #224]	@ (8006758 <SEGGER_SYSVIEW_RecordExitISR+0x110>)
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
 8006676:	1af3      	subs	r3, r6, r3
  ENCODE_U32(pEndPacket, Delta);
 8006678:	2b7f      	cmp	r3, #127	@ 0x7f
    *--pStartPacket = (U8)EventId;
 800667a:	7191      	strb	r1, [r2, #6]
  ENCODE_U32(pEndPacket, Delta);
 800667c:	f102 0207 	add.w	r2, r2, #7
 8006680:	d906      	bls.n	8006690 <SEGGER_SYSVIEW_RecordExitISR+0x48>
 8006682:	f063 017f 	orn	r1, r3, #127	@ 0x7f
 8006686:	09db      	lsrs	r3, r3, #7
 8006688:	2b7f      	cmp	r3, #127	@ 0x7f
 800668a:	f802 1b01 	strb.w	r1, [r2], #1
 800668e:	d8f8      	bhi.n	8006682 <SEGGER_SYSVIEW_RecordExitISR+0x3a>
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, (unsigned int)(pEndPacket - pStartPacket));
 8006690:	4932      	ldr	r1, [pc, #200]	@ (800675c <SEGGER_SYSVIEW_RecordExitISR+0x114>)
  ENCODE_U32(pEndPacket, Delta);
 8006692:	f802 3b01 	strb.w	r3, [r2], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, (unsigned int)(pEndPacket - pStartPacket));
 8006696:	7860      	ldrb	r0, [r4, #1]
 8006698:	1a52      	subs	r2, r2, r1
 800669a:	f7f9 fd59 	bl	8000150 <SEGGER_RTT_ASM_WriteSkipNoLock>
 800669e:	4607      	mov	r7, r0
  SEGGER_SYSVIEW_ON_EVENT_RECORDED(pEndPacket - pStartPacket);
 80066a0:	f7fe fa1c 	bl	8004adc <HIF_UART_EnableTXEInterrupt>
  if (Status) {
 80066a4:	b1cf      	cbz	r7, 80066da <SEGGER_SYSVIEW_RecordExitISR+0x92>
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
 80066a6:	60e6      	str	r6, [r4, #12]
  if (SEGGER_RTT_HASDATA(CHANNEL_ID_DOWN)) {
 80066a8:	7e22      	ldrb	r2, [r4, #24]
 80066aa:	4b2d      	ldr	r3, [pc, #180]	@ (8006760 <SEGGER_SYSVIEW_RecordExitISR+0x118>)
 80066ac:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 80066b0:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 80066b4:	6eda      	ldr	r2, [r3, #108]	@ 0x6c
 80066b6:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 80066b8:	429a      	cmp	r2, r3
 80066ba:	d001      	beq.n	80066c0 <SEGGER_SYSVIEW_RecordExitISR+0x78>
    if (_SYSVIEW_Globals.RecursionCnt == 0) {   // Avoid uncontrolled nesting. This way, this routine can call itself once, but no more often than that.
 80066bc:	78a6      	ldrb	r6, [r4, #2]
 80066be:	b11e      	cbz	r6, 80066c8 <SEGGER_SYSVIEW_RecordExitISR+0x80>
  RECORD_END();
 80066c0:	f385 8811 	msr	BASEPRI, r5
}
 80066c4:	b005      	add	sp, #20
 80066c6:	bdf0      	pop	{r4, r5, r6, r7, pc}
      _SYSVIEW_Globals.RecursionCnt = 1;
 80066c8:	2301      	movs	r3, #1
 80066ca:	70a3      	strb	r3, [r4, #2]
      _HandleIncomingPacket();
 80066cc:	f7fe fe1c 	bl	8005308 <_HandleIncomingPacket>
      _SYSVIEW_Globals.RecursionCnt = 0;
 80066d0:	70a6      	strb	r6, [r4, #2]
  RECORD_END();
 80066d2:	f385 8811 	msr	BASEPRI, r5
}
 80066d6:	b005      	add	sp, #20
 80066d8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    _SYSVIEW_Globals.EnableState++; // EnableState has been 1, will be 2. Always.
 80066da:	7823      	ldrb	r3, [r4, #0]
 80066dc:	3301      	adds	r3, #1
 80066de:	7023      	strb	r3, [r4, #0]
 80066e0:	e7e2      	b.n	80066a8 <SEGGER_SYSVIEW_RecordExitISR+0x60>
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
 80066e2:	2301      	movs	r3, #1
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
 80066e4:	6961      	ldr	r1, [r4, #20]
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
 80066e6:	f88d 3004 	strb.w	r3, [sp, #4]
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
 80066ea:	297f      	cmp	r1, #127	@ 0x7f
 80066ec:	f10d 0205 	add.w	r2, sp, #5
 80066f0:	d906      	bls.n	8006700 <SEGGER_SYSVIEW_RecordExitISR+0xb8>
 80066f2:	f061 037f 	orn	r3, r1, #127	@ 0x7f
 80066f6:	09c9      	lsrs	r1, r1, #7
 80066f8:	297f      	cmp	r1, #127	@ 0x7f
 80066fa:	f802 3b01 	strb.w	r3, [r2], #1
 80066fe:	d8f8      	bhi.n	80066f2 <SEGGER_SYSVIEW_RecordExitISR+0xaa>
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
 8006700:	4814      	ldr	r0, [pc, #80]	@ (8006754 <SEGGER_SYSVIEW_RecordExitISR+0x10c>)
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
 8006702:	f802 1b01 	strb.w	r1, [r2], #1
  Delta = (I32)(TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp);
 8006706:	68e3      	ldr	r3, [r4, #12]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
 8006708:	6846      	ldr	r6, [r0, #4]
  Delta = (I32)(TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp);
 800670a:	1af3      	subs	r3, r6, r3
  ENCODE_U32(pPayload, Delta);
 800670c:	2b7f      	cmp	r3, #127	@ 0x7f
 800670e:	d906      	bls.n	800671e <SEGGER_SYSVIEW_RecordExitISR+0xd6>
 8006710:	f063 017f 	orn	r1, r3, #127	@ 0x7f
 8006714:	09db      	lsrs	r3, r3, #7
 8006716:	2b7f      	cmp	r3, #127	@ 0x7f
 8006718:	f802 1b01 	strb.w	r1, [r2], #1
 800671c:	d8f8      	bhi.n	8006710 <SEGGER_SYSVIEW_RecordExitISR+0xc8>
  Status = (int)SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, (unsigned int)(pPayload - aPacket));
 800671e:	a901      	add	r1, sp, #4
  ENCODE_U32(pPayload, Delta);
 8006720:	f802 3b01 	strb.w	r3, [r2], #1
  Status = (int)SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, (unsigned int)(pPayload - aPacket));
 8006724:	7860      	ldrb	r0, [r4, #1]
 8006726:	1a52      	subs	r2, r2, r1
 8006728:	f7f9 fd12 	bl	8000150 <SEGGER_RTT_ASM_WriteSkipNoLock>
 800672c:	4607      	mov	r7, r0
  SEGGER_SYSVIEW_ON_EVENT_RECORDED(pPayload - aPacket);
 800672e:	f7fe f9d5 	bl	8004adc <HIF_UART_EnableTXEInterrupt>
  if (Status) {
 8006732:	b13f      	cbz	r7, 8006744 <SEGGER_SYSVIEW_RecordExitISR+0xfc>
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
 8006734:	7823      	ldrb	r3, [r4, #0]
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
 8006736:	60e6      	str	r6, [r4, #12]
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
 8006738:	3b01      	subs	r3, #1
 800673a:	b2db      	uxtb	r3, r3
 800673c:	7023      	strb	r3, [r4, #0]
    if (_SYSVIEW_Globals.EnableState != 1) {
 800673e:	2b01      	cmp	r3, #1
 8006740:	d1b2      	bne.n	80066a8 <SEGGER_SYSVIEW_RecordExitISR+0x60>
 8006742:	e790      	b.n	8006666 <SEGGER_SYSVIEW_RecordExitISR+0x1e>
    _SYSVIEW_Globals.DropCount++;
 8006744:	6962      	ldr	r2, [r4, #20]
    if (_SYSVIEW_Globals.EnableState != 1) {
 8006746:	7823      	ldrb	r3, [r4, #0]
    _SYSVIEW_Globals.DropCount++;
 8006748:	3201      	adds	r2, #1
 800674a:	6162      	str	r2, [r4, #20]
 800674c:	e7f7      	b.n	800673e <SEGGER_SYSVIEW_RecordExitISR+0xf6>
 800674e:	bf00      	nop
 8006750:	20001a1c 	.word	0x20001a1c
 8006754:	e0001000 	.word	0xe0001000
 8006758:	20001934 	.word	0x20001934
 800675c:	2000193a 	.word	0x2000193a
 8006760:	2000188c 	.word	0x2000188c

08006764 <SEGGER_SYSVIEW_RecordExitISRToScheduler>:
void SEGGER_SYSVIEW_RecordExitISRToScheduler(void) {
 8006764:	b5f0      	push	{r4, r5, r6, r7, lr}
 8006766:	b085      	sub	sp, #20
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE);
 8006768:	f3ef 8511 	mrs	r5, BASEPRI
 800676c:	f04f 0120 	mov.w	r1, #32
 8006770:	f381 8811 	msr	BASEPRI, r1
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
 8006774:	4c3d      	ldr	r4, [pc, #244]	@ (800686c <SEGGER_SYSVIEW_RecordExitISRToScheduler+0x108>)
 8006776:	7823      	ldrb	r3, [r4, #0]
 8006778:	2b01      	cmp	r3, #1
 800677a:	d002      	beq.n	8006782 <SEGGER_SYSVIEW_RecordExitISRToScheduler+0x1e>
  if (_SYSVIEW_Globals.EnableState == 0) {
 800677c:	b313      	cbz	r3, 80067c4 <SEGGER_SYSVIEW_RecordExitISRToScheduler+0x60>
  if (_SYSVIEW_Globals.EnableState == 2) {
 800677e:	2b02      	cmp	r3, #2
 8006780:	d03d      	beq.n	80067fe <SEGGER_SYSVIEW_RecordExitISRToScheduler+0x9a>
    if (_SYSVIEW_Globals.DisabledEvents & ((U32)1u << EventId)) {
 8006782:	69e3      	ldr	r3, [r4, #28]
 8006784:	035b      	lsls	r3, r3, #13
 8006786:	d41d      	bmi.n	80067c4 <SEGGER_SYSVIEW_RecordExitISRToScheduler+0x60>
    *--pStartPacket = (U8)EventId;
 8006788:	2112      	movs	r1, #18
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
 800678a:	4a39      	ldr	r2, [pc, #228]	@ (8006870 <SEGGER_SYSVIEW_RecordExitISRToScheduler+0x10c>)
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
 800678c:	68e3      	ldr	r3, [r4, #12]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
 800678e:	6856      	ldr	r6, [r2, #4]
    *--pStartPacket = (U8)EventId;
 8006790:	4a38      	ldr	r2, [pc, #224]	@ (8006874 <SEGGER_SYSVIEW_RecordExitISRToScheduler+0x110>)
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
 8006792:	1af3      	subs	r3, r6, r3
  ENCODE_U32(pEndPacket, Delta);
 8006794:	2b7f      	cmp	r3, #127	@ 0x7f
    *--pStartPacket = (U8)EventId;
 8006796:	7191      	strb	r1, [r2, #6]
  ENCODE_U32(pEndPacket, Delta);
 8006798:	f102 0207 	add.w	r2, r2, #7
 800679c:	d906      	bls.n	80067ac <SEGGER_SYSVIEW_RecordExitISRToScheduler+0x48>
 800679e:	f063 017f 	orn	r1, r3, #127	@ 0x7f
 80067a2:	09db      	lsrs	r3, r3, #7
 80067a4:	2b7f      	cmp	r3, #127	@ 0x7f
 80067a6:	f802 1b01 	strb.w	r1, [r2], #1
 80067aa:	d8f8      	bhi.n	800679e <SEGGER_SYSVIEW_RecordExitISRToScheduler+0x3a>
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, (unsigned int)(pEndPacket - pStartPacket));
 80067ac:	4932      	ldr	r1, [pc, #200]	@ (8006878 <SEGGER_SYSVIEW_RecordExitISRToScheduler+0x114>)
  ENCODE_U32(pEndPacket, Delta);
 80067ae:	f802 3b01 	strb.w	r3, [r2], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, (unsigned int)(pEndPacket - pStartPacket));
 80067b2:	7860      	ldrb	r0, [r4, #1]
 80067b4:	1a52      	subs	r2, r2, r1
 80067b6:	f7f9 fccb 	bl	8000150 <SEGGER_RTT_ASM_WriteSkipNoLock>
 80067ba:	4607      	mov	r7, r0
  SEGGER_SYSVIEW_ON_EVENT_RECORDED(pEndPacket - pStartPacket);
 80067bc:	f7fe f98e 	bl	8004adc <HIF_UART_EnableTXEInterrupt>
  if (Status) {
 80067c0:	b1cf      	cbz	r7, 80067f6 <SEGGER_SYSVIEW_RecordExitISRToScheduler+0x92>
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
 80067c2:	60e6      	str	r6, [r4, #12]
  if (SEGGER_RTT_HASDATA(CHANNEL_ID_DOWN)) {
 80067c4:	7e22      	ldrb	r2, [r4, #24]
 80067c6:	4b2d      	ldr	r3, [pc, #180]	@ (800687c <SEGGER_SYSVIEW_RecordExitISRToScheduler+0x118>)
 80067c8:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 80067cc:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 80067d0:	6eda      	ldr	r2, [r3, #108]	@ 0x6c
 80067d2:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 80067d4:	429a      	cmp	r2, r3
 80067d6:	d001      	beq.n	80067dc <SEGGER_SYSVIEW_RecordExitISRToScheduler+0x78>
    if (_SYSVIEW_Globals.RecursionCnt == 0) {   // Avoid uncontrolled nesting. This way, this routine can call itself once, but no more often than that.
 80067d8:	78a6      	ldrb	r6, [r4, #2]
 80067da:	b11e      	cbz	r6, 80067e4 <SEGGER_SYSVIEW_RecordExitISRToScheduler+0x80>
  RECORD_END();
 80067dc:	f385 8811 	msr	BASEPRI, r5
}
 80067e0:	b005      	add	sp, #20
 80067e2:	bdf0      	pop	{r4, r5, r6, r7, pc}
      _SYSVIEW_Globals.RecursionCnt = 1;
 80067e4:	2301      	movs	r3, #1
 80067e6:	70a3      	strb	r3, [r4, #2]
      _HandleIncomingPacket();
 80067e8:	f7fe fd8e 	bl	8005308 <_HandleIncomingPacket>
      _SYSVIEW_Globals.RecursionCnt = 0;
 80067ec:	70a6      	strb	r6, [r4, #2]
  RECORD_END();
 80067ee:	f385 8811 	msr	BASEPRI, r5
}
 80067f2:	b005      	add	sp, #20
 80067f4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    _SYSVIEW_Globals.EnableState++; // EnableState has been 1, will be 2. Always.
 80067f6:	7823      	ldrb	r3, [r4, #0]
 80067f8:	3301      	adds	r3, #1
 80067fa:	7023      	strb	r3, [r4, #0]
 80067fc:	e7e2      	b.n	80067c4 <SEGGER_SYSVIEW_RecordExitISRToScheduler+0x60>
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
 80067fe:	2301      	movs	r3, #1
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
 8006800:	6961      	ldr	r1, [r4, #20]
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
 8006802:	f88d 3004 	strb.w	r3, [sp, #4]
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
 8006806:	297f      	cmp	r1, #127	@ 0x7f
 8006808:	f10d 0205 	add.w	r2, sp, #5
 800680c:	d906      	bls.n	800681c <SEGGER_SYSVIEW_RecordExitISRToScheduler+0xb8>
 800680e:	f061 037f 	orn	r3, r1, #127	@ 0x7f
 8006812:	09c9      	lsrs	r1, r1, #7
 8006814:	297f      	cmp	r1, #127	@ 0x7f
 8006816:	f802 3b01 	strb.w	r3, [r2], #1
 800681a:	d8f8      	bhi.n	800680e <SEGGER_SYSVIEW_RecordExitISRToScheduler+0xaa>
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
 800681c:	4814      	ldr	r0, [pc, #80]	@ (8006870 <SEGGER_SYSVIEW_RecordExitISRToScheduler+0x10c>)
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
 800681e:	f802 1b01 	strb.w	r1, [r2], #1
  Delta = (I32)(TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp);
 8006822:	68e3      	ldr	r3, [r4, #12]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
 8006824:	6846      	ldr	r6, [r0, #4]
  Delta = (I32)(TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp);
 8006826:	1af3      	subs	r3, r6, r3
  ENCODE_U32(pPayload, Delta);
 8006828:	2b7f      	cmp	r3, #127	@ 0x7f
 800682a:	d906      	bls.n	800683a <SEGGER_SYSVIEW_RecordExitISRToScheduler+0xd6>
 800682c:	f063 017f 	orn	r1, r3, #127	@ 0x7f
 8006830:	09db      	lsrs	r3, r3, #7
 8006832:	2b7f      	cmp	r3, #127	@ 0x7f
 8006834:	f802 1b01 	strb.w	r1, [r2], #1
 8006838:	d8f8      	bhi.n	800682c <SEGGER_SYSVIEW_RecordExitISRToScheduler+0xc8>
  Status = (int)SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, (unsigned int)(pPayload - aPacket));
 800683a:	a901      	add	r1, sp, #4
  ENCODE_U32(pPayload, Delta);
 800683c:	f802 3b01 	strb.w	r3, [r2], #1
  Status = (int)SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, (unsigned int)(pPayload - aPacket));
 8006840:	7860      	ldrb	r0, [r4, #1]
 8006842:	1a52      	subs	r2, r2, r1
 8006844:	f7f9 fc84 	bl	8000150 <SEGGER_RTT_ASM_WriteSkipNoLock>
 8006848:	4607      	mov	r7, r0
  SEGGER_SYSVIEW_ON_EVENT_RECORDED(pPayload - aPacket);
 800684a:	f7fe f947 	bl	8004adc <HIF_UART_EnableTXEInterrupt>
  if (Status) {
 800684e:	b13f      	cbz	r7, 8006860 <SEGGER_SYSVIEW_RecordExitISRToScheduler+0xfc>
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
 8006850:	7823      	ldrb	r3, [r4, #0]
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
 8006852:	60e6      	str	r6, [r4, #12]
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
 8006854:	3b01      	subs	r3, #1
 8006856:	b2db      	uxtb	r3, r3
 8006858:	7023      	strb	r3, [r4, #0]
    if (_SYSVIEW_Globals.EnableState != 1) {
 800685a:	2b01      	cmp	r3, #1
 800685c:	d1b2      	bne.n	80067c4 <SEGGER_SYSVIEW_RecordExitISRToScheduler+0x60>
 800685e:	e790      	b.n	8006782 <SEGGER_SYSVIEW_RecordExitISRToScheduler+0x1e>
    _SYSVIEW_Globals.DropCount++;
 8006860:	6962      	ldr	r2, [r4, #20]
    if (_SYSVIEW_Globals.EnableState != 1) {
 8006862:	7823      	ldrb	r3, [r4, #0]
    _SYSVIEW_Globals.DropCount++;
 8006864:	3201      	adds	r2, #1
 8006866:	6162      	str	r2, [r4, #20]
 8006868:	e7f7      	b.n	800685a <SEGGER_SYSVIEW_RecordExitISRToScheduler+0xf6>
 800686a:	bf00      	nop
 800686c:	20001a1c 	.word	0x20001a1c
 8006870:	e0001000 	.word	0xe0001000
 8006874:	20001934 	.word	0x20001934
 8006878:	2000193a 	.word	0x2000193a
 800687c:	2000188c 	.word	0x2000188c

08006880 <SEGGER_SYSVIEW_OnIdle>:
void SEGGER_SYSVIEW_OnIdle(void) {
 8006880:	b5f0      	push	{r4, r5, r6, r7, lr}
 8006882:	b085      	sub	sp, #20
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE);
 8006884:	f3ef 8511 	mrs	r5, BASEPRI
 8006888:	f04f 0120 	mov.w	r1, #32
 800688c:	f381 8811 	msr	BASEPRI, r1
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
 8006890:	4c3d      	ldr	r4, [pc, #244]	@ (8006988 <SEGGER_SYSVIEW_OnIdle+0x108>)
 8006892:	7823      	ldrb	r3, [r4, #0]
 8006894:	2b01      	cmp	r3, #1
 8006896:	d002      	beq.n	800689e <SEGGER_SYSVIEW_OnIdle+0x1e>
  if (_SYSVIEW_Globals.EnableState == 0) {
 8006898:	b313      	cbz	r3, 80068e0 <SEGGER_SYSVIEW_OnIdle+0x60>
  if (_SYSVIEW_Globals.EnableState == 2) {
 800689a:	2b02      	cmp	r3, #2
 800689c:	d03d      	beq.n	800691a <SEGGER_SYSVIEW_OnIdle+0x9a>
    if (_SYSVIEW_Globals.DisabledEvents & ((U32)1u << EventId)) {
 800689e:	69e3      	ldr	r3, [r4, #28]
 80068a0:	039b      	lsls	r3, r3, #14
 80068a2:	d41d      	bmi.n	80068e0 <SEGGER_SYSVIEW_OnIdle+0x60>
    *--pStartPacket = (U8)EventId;
 80068a4:	2111      	movs	r1, #17
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
 80068a6:	4a39      	ldr	r2, [pc, #228]	@ (800698c <SEGGER_SYSVIEW_OnIdle+0x10c>)
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
 80068a8:	68e3      	ldr	r3, [r4, #12]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
 80068aa:	6856      	ldr	r6, [r2, #4]
    *--pStartPacket = (U8)EventId;
 80068ac:	4a38      	ldr	r2, [pc, #224]	@ (8006990 <SEGGER_SYSVIEW_OnIdle+0x110>)
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
 80068ae:	1af3      	subs	r3, r6, r3
  ENCODE_U32(pEndPacket, Delta);
 80068b0:	2b7f      	cmp	r3, #127	@ 0x7f
    *--pStartPacket = (U8)EventId;
 80068b2:	7191      	strb	r1, [r2, #6]
  ENCODE_U32(pEndPacket, Delta);
 80068b4:	f102 0207 	add.w	r2, r2, #7
 80068b8:	d906      	bls.n	80068c8 <SEGGER_SYSVIEW_OnIdle+0x48>
 80068ba:	f063 017f 	orn	r1, r3, #127	@ 0x7f
 80068be:	09db      	lsrs	r3, r3, #7
 80068c0:	2b7f      	cmp	r3, #127	@ 0x7f
 80068c2:	f802 1b01 	strb.w	r1, [r2], #1
 80068c6:	d8f8      	bhi.n	80068ba <SEGGER_SYSVIEW_OnIdle+0x3a>
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, (unsigned int)(pEndPacket - pStartPacket));
 80068c8:	4932      	ldr	r1, [pc, #200]	@ (8006994 <SEGGER_SYSVIEW_OnIdle+0x114>)
  ENCODE_U32(pEndPacket, Delta);
 80068ca:	f802 3b01 	strb.w	r3, [r2], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, (unsigned int)(pEndPacket - pStartPacket));
 80068ce:	7860      	ldrb	r0, [r4, #1]
 80068d0:	1a52      	subs	r2, r2, r1
 80068d2:	f7f9 fc3d 	bl	8000150 <SEGGER_RTT_ASM_WriteSkipNoLock>
 80068d6:	4607      	mov	r7, r0
  SEGGER_SYSVIEW_ON_EVENT_RECORDED(pEndPacket - pStartPacket);
 80068d8:	f7fe f900 	bl	8004adc <HIF_UART_EnableTXEInterrupt>
  if (Status) {
 80068dc:	b1cf      	cbz	r7, 8006912 <SEGGER_SYSVIEW_OnIdle+0x92>
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
 80068de:	60e6      	str	r6, [r4, #12]
  if (SEGGER_RTT_HASDATA(CHANNEL_ID_DOWN)) {
 80068e0:	7e22      	ldrb	r2, [r4, #24]
 80068e2:	4b2d      	ldr	r3, [pc, #180]	@ (8006998 <SEGGER_SYSVIEW_OnIdle+0x118>)
 80068e4:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 80068e8:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 80068ec:	6eda      	ldr	r2, [r3, #108]	@ 0x6c
 80068ee:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 80068f0:	429a      	cmp	r2, r3
 80068f2:	d001      	beq.n	80068f8 <SEGGER_SYSVIEW_OnIdle+0x78>
    if (_SYSVIEW_Globals.RecursionCnt == 0) {   // Avoid uncontrolled nesting. This way, this routine can call itself once, but no more often than that.
 80068f4:	78a6      	ldrb	r6, [r4, #2]
 80068f6:	b11e      	cbz	r6, 8006900 <SEGGER_SYSVIEW_OnIdle+0x80>
  RECORD_END();
 80068f8:	f385 8811 	msr	BASEPRI, r5
}
 80068fc:	b005      	add	sp, #20
 80068fe:	bdf0      	pop	{r4, r5, r6, r7, pc}
      _SYSVIEW_Globals.RecursionCnt = 1;
 8006900:	2301      	movs	r3, #1
 8006902:	70a3      	strb	r3, [r4, #2]
      _HandleIncomingPacket();
 8006904:	f7fe fd00 	bl	8005308 <_HandleIncomingPacket>
      _SYSVIEW_Globals.RecursionCnt = 0;
 8006908:	70a6      	strb	r6, [r4, #2]
  RECORD_END();
 800690a:	f385 8811 	msr	BASEPRI, r5
}
 800690e:	b005      	add	sp, #20
 8006910:	bdf0      	pop	{r4, r5, r6, r7, pc}
    _SYSVIEW_Globals.EnableState++; // EnableState has been 1, will be 2. Always.
 8006912:	7823      	ldrb	r3, [r4, #0]
 8006914:	3301      	adds	r3, #1
 8006916:	7023      	strb	r3, [r4, #0]
 8006918:	e7e2      	b.n	80068e0 <SEGGER_SYSVIEW_OnIdle+0x60>
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
 800691a:	2301      	movs	r3, #1
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
 800691c:	6961      	ldr	r1, [r4, #20]
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
 800691e:	f88d 3004 	strb.w	r3, [sp, #4]
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
 8006922:	297f      	cmp	r1, #127	@ 0x7f
 8006924:	f10d 0205 	add.w	r2, sp, #5
 8006928:	d906      	bls.n	8006938 <SEGGER_SYSVIEW_OnIdle+0xb8>
 800692a:	f061 037f 	orn	r3, r1, #127	@ 0x7f
 800692e:	09c9      	lsrs	r1, r1, #7
 8006930:	297f      	cmp	r1, #127	@ 0x7f
 8006932:	f802 3b01 	strb.w	r3, [r2], #1
 8006936:	d8f8      	bhi.n	800692a <SEGGER_SYSVIEW_OnIdle+0xaa>
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
 8006938:	4814      	ldr	r0, [pc, #80]	@ (800698c <SEGGER_SYSVIEW_OnIdle+0x10c>)
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
 800693a:	f802 1b01 	strb.w	r1, [r2], #1
  Delta = (I32)(TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp);
 800693e:	68e3      	ldr	r3, [r4, #12]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
 8006940:	6846      	ldr	r6, [r0, #4]
  Delta = (I32)(TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp);
 8006942:	1af3      	subs	r3, r6, r3
  ENCODE_U32(pPayload, Delta);
 8006944:	2b7f      	cmp	r3, #127	@ 0x7f
 8006946:	d906      	bls.n	8006956 <SEGGER_SYSVIEW_OnIdle+0xd6>
 8006948:	f063 017f 	orn	r1, r3, #127	@ 0x7f
 800694c:	09db      	lsrs	r3, r3, #7
 800694e:	2b7f      	cmp	r3, #127	@ 0x7f
 8006950:	f802 1b01 	strb.w	r1, [r2], #1
 8006954:	d8f8      	bhi.n	8006948 <SEGGER_SYSVIEW_OnIdle+0xc8>
  Status = (int)SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, (unsigned int)(pPayload - aPacket));
 8006956:	a901      	add	r1, sp, #4
  ENCODE_U32(pPayload, Delta);
 8006958:	f802 3b01 	strb.w	r3, [r2], #1
  Status = (int)SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, (unsigned int)(pPayload - aPacket));
 800695c:	7860      	ldrb	r0, [r4, #1]
 800695e:	1a52      	subs	r2, r2, r1
 8006960:	f7f9 fbf6 	bl	8000150 <SEGGER_RTT_ASM_WriteSkipNoLock>
 8006964:	4607      	mov	r7, r0
  SEGGER_SYSVIEW_ON_EVENT_RECORDED(pPayload - aPacket);
 8006966:	f7fe f8b9 	bl	8004adc <HIF_UART_EnableTXEInterrupt>
  if (Status) {
 800696a:	b13f      	cbz	r7, 800697c <SEGGER_SYSVIEW_OnIdle+0xfc>
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
 800696c:	7823      	ldrb	r3, [r4, #0]
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
 800696e:	60e6      	str	r6, [r4, #12]
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
 8006970:	3b01      	subs	r3, #1
 8006972:	b2db      	uxtb	r3, r3
 8006974:	7023      	strb	r3, [r4, #0]
    if (_SYSVIEW_Globals.EnableState != 1) {
 8006976:	2b01      	cmp	r3, #1
 8006978:	d1b2      	bne.n	80068e0 <SEGGER_SYSVIEW_OnIdle+0x60>
 800697a:	e790      	b.n	800689e <SEGGER_SYSVIEW_OnIdle+0x1e>
    _SYSVIEW_Globals.DropCount++;
 800697c:	6962      	ldr	r2, [r4, #20]
    if (_SYSVIEW_Globals.EnableState != 1) {
 800697e:	7823      	ldrb	r3, [r4, #0]
    _SYSVIEW_Globals.DropCount++;
 8006980:	3201      	adds	r2, #1
 8006982:	6162      	str	r2, [r4, #20]
 8006984:	e7f7      	b.n	8006976 <SEGGER_SYSVIEW_OnIdle+0xf6>
 8006986:	bf00      	nop
 8006988:	20001a1c 	.word	0x20001a1c
 800698c:	e0001000 	.word	0xe0001000
 8006990:	20001934 	.word	0x20001934
 8006994:	2000193a 	.word	0x2000193a
 8006998:	2000188c 	.word	0x2000188c

0800699c <SEGGER_SYSVIEW_RecordVoid>:
void SEGGER_SYSVIEW_RecordVoid(unsigned int EventID) {
 800699c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80069a0:	4605      	mov	r5, r0
 80069a2:	b084      	sub	sp, #16
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE);
 80069a4:	f3ef 8611 	mrs	r6, BASEPRI
 80069a8:	f04f 0120 	mov.w	r1, #32
 80069ac:	f381 8811 	msr	BASEPRI, r1
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
 80069b0:	4c63      	ldr	r4, [pc, #396]	@ (8006b40 <SEGGER_SYSVIEW_RecordVoid+0x1a4>)
 80069b2:	7823      	ldrb	r3, [r4, #0]
 80069b4:	2b01      	cmp	r3, #1
 80069b6:	d002      	beq.n	80069be <SEGGER_SYSVIEW_RecordVoid+0x22>
  if (_SYSVIEW_Globals.EnableState == 0) {
 80069b8:	b363      	cbz	r3, 8006a14 <SEGGER_SYSVIEW_RecordVoid+0x78>
  if (_SYSVIEW_Globals.EnableState == 2) {
 80069ba:	2b02      	cmp	r3, #2
 80069bc:	d068      	beq.n	8006a90 <SEGGER_SYSVIEW_RecordVoid+0xf4>
  if (EventId < 32) {
 80069be:	2d1f      	cmp	r5, #31
 80069c0:	d839      	bhi.n	8006a36 <SEGGER_SYSVIEW_RecordVoid+0x9a>
    if (_SYSVIEW_Globals.DisabledEvents & ((U32)1u << EventId)) {
 80069c2:	69e3      	ldr	r3, [r4, #28]
 80069c4:	40eb      	lsrs	r3, r5
 80069c6:	f013 0301 	ands.w	r3, r3, #1
 80069ca:	d123      	bne.n	8006a14 <SEGGER_SYSVIEW_RecordVoid+0x78>
  if (EventId < 24) {
 80069cc:	2d17      	cmp	r5, #23
 80069ce:	d803      	bhi.n	80069d8 <SEGGER_SYSVIEW_RecordVoid+0x3c>
    *--pStartPacket = (U8)EventId;
 80069d0:	495c      	ldr	r1, [pc, #368]	@ (8006b44 <SEGGER_SYSVIEW_RecordVoid+0x1a8>)
 80069d2:	f801 5f06 	strb.w	r5, [r1, #6]!
 80069d6:	e003      	b.n	80069e0 <SEGGER_SYSVIEW_RecordVoid+0x44>
      *--pStartPacket = (U8)NumBytes;
 80069d8:	4a5a      	ldr	r2, [pc, #360]	@ (8006b44 <SEGGER_SYSVIEW_RecordVoid+0x1a8>)
 80069da:	7193      	strb	r3, [r2, #6]
      *--pStartPacket = (U8)EventId;
 80069dc:	495a      	ldr	r1, [pc, #360]	@ (8006b48 <SEGGER_SYSVIEW_RecordVoid+0x1ac>)
 80069de:	7155      	strb	r5, [r2, #5]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
 80069e0:	4a5a      	ldr	r2, [pc, #360]	@ (8006b4c <SEGGER_SYSVIEW_RecordVoid+0x1b0>)
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
 80069e2:	68e3      	ldr	r3, [r4, #12]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
 80069e4:	6855      	ldr	r5, [r2, #4]
  ENCODE_U32(pEndPacket, Delta);
 80069e6:	4a5a      	ldr	r2, [pc, #360]	@ (8006b50 <SEGGER_SYSVIEW_RecordVoid+0x1b4>)
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
 80069e8:	1aeb      	subs	r3, r5, r3
  ENCODE_U32(pEndPacket, Delta);
 80069ea:	2b7f      	cmp	r3, #127	@ 0x7f
 80069ec:	d906      	bls.n	80069fc <SEGGER_SYSVIEW_RecordVoid+0x60>
 80069ee:	f063 007f 	orn	r0, r3, #127	@ 0x7f
 80069f2:	09db      	lsrs	r3, r3, #7
 80069f4:	2b7f      	cmp	r3, #127	@ 0x7f
 80069f6:	f802 0b01 	strb.w	r0, [r2], #1
 80069fa:	d8f8      	bhi.n	80069ee <SEGGER_SYSVIEW_RecordVoid+0x52>
 80069fc:	f802 3b01 	strb.w	r3, [r2], #1
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, (unsigned int)(pEndPacket - pStartPacket));
 8006a00:	7860      	ldrb	r0, [r4, #1]
 8006a02:	1a52      	subs	r2, r2, r1
 8006a04:	f7f9 fba4 	bl	8000150 <SEGGER_RTT_ASM_WriteSkipNoLock>
 8006a08:	4607      	mov	r7, r0
  SEGGER_SYSVIEW_ON_EVENT_RECORDED(pEndPacket - pStartPacket);
 8006a0a:	f7fe f867 	bl	8004adc <HIF_UART_EnableTXEInterrupt>
  if (Status) {
 8006a0e:	2f00      	cmp	r7, #0
 8006a10:	d035      	beq.n	8006a7e <SEGGER_SYSVIEW_RecordVoid+0xe2>
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
 8006a12:	60e5      	str	r5, [r4, #12]
  if (SEGGER_RTT_HASDATA(CHANNEL_ID_DOWN)) {
 8006a14:	7e22      	ldrb	r2, [r4, #24]
 8006a16:	4b4f      	ldr	r3, [pc, #316]	@ (8006b54 <SEGGER_SYSVIEW_RecordVoid+0x1b8>)
 8006a18:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 8006a1c:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8006a20:	6eda      	ldr	r2, [r3, #108]	@ 0x6c
 8006a22:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8006a24:	429a      	cmp	r2, r3
 8006a26:	d001      	beq.n	8006a2c <SEGGER_SYSVIEW_RecordVoid+0x90>
    if (_SYSVIEW_Globals.RecursionCnt == 0) {   // Avoid uncontrolled nesting. This way, this routine can call itself once, but no more often than that.
 8006a28:	78a5      	ldrb	r5, [r4, #2]
 8006a2a:	b1f5      	cbz	r5, 8006a6a <SEGGER_SYSVIEW_RecordVoid+0xce>
  RECORD_END();
 8006a2c:	f386 8811 	msr	BASEPRI, r6
}
 8006a30:	b004      	add	sp, #16
 8006a32:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      *--pStartPacket = (U8)NumBytes;
 8006a36:	2300      	movs	r3, #0
 8006a38:	4a42      	ldr	r2, [pc, #264]	@ (8006b44 <SEGGER_SYSVIEW_RecordVoid+0x1a8>)
    if (EventId < 127) {
 8006a3a:	2d7e      	cmp	r5, #126	@ 0x7e
      *--pStartPacket = (U8)NumBytes;
 8006a3c:	7193      	strb	r3, [r2, #6]
    if (EventId < 127) {
 8006a3e:	d9cd      	bls.n	80069dc <SEGGER_SYSVIEW_RecordVoid+0x40>
        *--pStartPacket = (U8)(EventId | 0x80);
 8006a40:	f065 017f 	orn	r1, r5, #127	@ 0x7f
      if (EventId < (1u << 14)) { // Encodes in 2 bytes
 8006a44:	f5b5 4f80 	cmp.w	r5, #16384	@ 0x4000
        *--pStartPacket = (U8)(EventId | 0x80);
 8006a48:	b2cf      	uxtb	r7, r1
        *--pStartPacket = (U8)(EventId >>  7);
 8006a4a:	f3c5 11c7 	ubfx	r1, r5, #7, #8
      if (EventId < (1u << 14)) { // Encodes in 2 bytes
 8006a4e:	d31a      	bcc.n	8006a86 <SEGGER_SYSVIEW_RecordVoid+0xea>
      } else if (EventId < (1ul << 21)) {    // Encodes in 3 bytes
 8006a50:	f5b5 1f00 	cmp.w	r5, #2097152	@ 0x200000
        *--pStartPacket = (U8)((EventId >>  7) | 0x80);
 8006a54:	f041 0080 	orr.w	r0, r1, #128	@ 0x80
        *--pStartPacket = (U8)(EventId >> 14);
 8006a58:	f3c5 3187 	ubfx	r1, r5, #14, #8
      } else if (EventId < (1ul << 21)) {    // Encodes in 3 bytes
 8006a5c:	d24b      	bcs.n	8006af6 <SEGGER_SYSVIEW_RecordVoid+0x15a>
        *--pStartPacket = (U8)(EventId >> 14);
 8006a5e:	7151      	strb	r1, [r2, #5]
        *--pStartPacket = (U8)(EventId | 0x80);
 8006a60:	4611      	mov	r1, r2
        *--pStartPacket = (U8)((EventId >>  7) | 0x80);
 8006a62:	7110      	strb	r0, [r2, #4]
        *--pStartPacket = (U8)(EventId | 0x80);
 8006a64:	f801 7f03 	strb.w	r7, [r1, #3]!
 8006a68:	e7ba      	b.n	80069e0 <SEGGER_SYSVIEW_RecordVoid+0x44>
      _SYSVIEW_Globals.RecursionCnt = 1;
 8006a6a:	2301      	movs	r3, #1
 8006a6c:	70a3      	strb	r3, [r4, #2]
      _HandleIncomingPacket();
 8006a6e:	f7fe fc4b 	bl	8005308 <_HandleIncomingPacket>
      _SYSVIEW_Globals.RecursionCnt = 0;
 8006a72:	70a5      	strb	r5, [r4, #2]
  RECORD_END();
 8006a74:	f386 8811 	msr	BASEPRI, r6
}
 8006a78:	b004      	add	sp, #16
 8006a7a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    _SYSVIEW_Globals.EnableState++; // EnableState has been 1, will be 2. Always.
 8006a7e:	7823      	ldrb	r3, [r4, #0]
 8006a80:	3301      	adds	r3, #1
 8006a82:	7023      	strb	r3, [r4, #0]
 8006a84:	e7c6      	b.n	8006a14 <SEGGER_SYSVIEW_RecordVoid+0x78>
        *--pStartPacket = (U8)(EventId >>  7);
 8006a86:	7151      	strb	r1, [r2, #5]
        *--pStartPacket = (U8)(EventId | 0x80);
 8006a88:	4611      	mov	r1, r2
 8006a8a:	f801 7f04 	strb.w	r7, [r1, #4]!
 8006a8e:	e7a7      	b.n	80069e0 <SEGGER_SYSVIEW_RecordVoid+0x44>
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
 8006a90:	2301      	movs	r3, #1
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
 8006a92:	6961      	ldr	r1, [r4, #20]
  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
 8006a94:	f88d 3004 	strb.w	r3, [sp, #4]
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
 8006a98:	297f      	cmp	r1, #127	@ 0x7f
 8006a9a:	f10d 0205 	add.w	r2, sp, #5
 8006a9e:	d906      	bls.n	8006aae <SEGGER_SYSVIEW_RecordVoid+0x112>
 8006aa0:	f061 037f 	orn	r3, r1, #127	@ 0x7f
 8006aa4:	09c9      	lsrs	r1, r1, #7
 8006aa6:	297f      	cmp	r1, #127	@ 0x7f
 8006aa8:	f802 3b01 	strb.w	r3, [r2], #1
 8006aac:	d8f8      	bhi.n	8006aa0 <SEGGER_SYSVIEW_RecordVoid+0x104>
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
 8006aae:	4827      	ldr	r0, [pc, #156]	@ (8006b4c <SEGGER_SYSVIEW_RecordVoid+0x1b0>)
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
 8006ab0:	f802 1b01 	strb.w	r1, [r2], #1
  Delta = (I32)(TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp);
 8006ab4:	68e3      	ldr	r3, [r4, #12]
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
 8006ab6:	6847      	ldr	r7, [r0, #4]
  Delta = (I32)(TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp);
 8006ab8:	1afb      	subs	r3, r7, r3
  ENCODE_U32(pPayload, Delta);
 8006aba:	2b7f      	cmp	r3, #127	@ 0x7f
 8006abc:	d906      	bls.n	8006acc <SEGGER_SYSVIEW_RecordVoid+0x130>
 8006abe:	f063 017f 	orn	r1, r3, #127	@ 0x7f
 8006ac2:	09db      	lsrs	r3, r3, #7
 8006ac4:	2b7f      	cmp	r3, #127	@ 0x7f
 8006ac6:	f802 1b01 	strb.w	r1, [r2], #1
 8006aca:	d8f8      	bhi.n	8006abe <SEGGER_SYSVIEW_RecordVoid+0x122>
 8006acc:	f802 3b01 	strb.w	r3, [r2], #1
  Status = (int)SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, (unsigned int)(pPayload - aPacket));
 8006ad0:	a901      	add	r1, sp, #4
 8006ad2:	7860      	ldrb	r0, [r4, #1]
 8006ad4:	1a52      	subs	r2, r2, r1
 8006ad6:	f7f9 fb3b 	bl	8000150 <SEGGER_RTT_ASM_WriteSkipNoLock>
 8006ada:	4680      	mov	r8, r0
  SEGGER_SYSVIEW_ON_EVENT_RECORDED(pPayload - aPacket);
 8006adc:	f7fd fffe 	bl	8004adc <HIF_UART_EnableTXEInterrupt>
  if (Status) {
 8006ae0:	f1b8 0f00 	cmp.w	r8, #0
 8006ae4:	d01a      	beq.n	8006b1c <SEGGER_SYSVIEW_RecordVoid+0x180>
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
 8006ae6:	7823      	ldrb	r3, [r4, #0]
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
 8006ae8:	60e7      	str	r7, [r4, #12]
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
 8006aea:	3b01      	subs	r3, #1
 8006aec:	b2db      	uxtb	r3, r3
 8006aee:	7023      	strb	r3, [r4, #0]
    if (_SYSVIEW_Globals.EnableState != 1) {
 8006af0:	2b01      	cmp	r3, #1
 8006af2:	d18f      	bne.n	8006a14 <SEGGER_SYSVIEW_RecordVoid+0x78>
 8006af4:	e763      	b.n	80069be <SEGGER_SYSVIEW_RecordVoid+0x22>
      } else if (EventId < (1ul << 28)) {    // Encodes in 4 bytes
 8006af6:	f1b5 5f80 	cmp.w	r5, #268435456	@ 0x10000000
        *--pStartPacket = (U8)((EventId >> 14) | 0x80);
 8006afa:	f041 0c80 	orr.w	ip, r1, #128	@ 0x80
        *--pStartPacket = (U8)(EventId >> 21);
 8006afe:	f3c5 5e47 	ubfx	lr, r5, #21, #8
      } else if (EventId < (1ul << 28)) {    // Encodes in 4 bytes
 8006b02:	d210      	bcs.n	8006b26 <SEGGER_SYSVIEW_RecordVoid+0x18a>
        *--pStartPacket = (U8)(EventId | 0x80);
 8006b04:	4611      	mov	r1, r2
 8006b06:	f367 0307 	bfi	r3, r7, #0, #8
 8006b0a:	f360 230f 	bfi	r3, r0, #8, #8
 8006b0e:	f36c 4317 	bfi	r3, ip, #16, #8
 8006b12:	f36e 631f 	bfi	r3, lr, #24, #8
 8006b16:	f841 3f02 	str.w	r3, [r1, #2]!
 8006b1a:	e761      	b.n	80069e0 <SEGGER_SYSVIEW_RecordVoid+0x44>
    _SYSVIEW_Globals.DropCount++;
 8006b1c:	6962      	ldr	r2, [r4, #20]
    if (_SYSVIEW_Globals.EnableState != 1) {
 8006b1e:	7823      	ldrb	r3, [r4, #0]
    _SYSVIEW_Globals.DropCount++;
 8006b20:	3201      	adds	r2, #1
 8006b22:	6162      	str	r2, [r4, #20]
 8006b24:	e7e4      	b.n	8006af0 <SEGGER_SYSVIEW_RecordVoid+0x154>
        *--pStartPacket = (U8)(EventId | 0x80);
 8006b26:	4611      	mov	r1, r2
        *--pStartPacket = (U8)(EventId >> 28);
 8006b28:	0f2d      	lsrs	r5, r5, #28
        *--pStartPacket = (U8)((EventId >> 21) | 0x80);
 8006b2a:	f06e 0e7f 	orn	lr, lr, #127	@ 0x7f
        *--pStartPacket = (U8)((EventId >> 14) | 0x80);
 8006b2e:	f882 c003 	strb.w	ip, [r2, #3]
        *--pStartPacket = (U8)((EventId >>  7) | 0x80);
 8006b32:	7090      	strb	r0, [r2, #2]
        *--pStartPacket = (U8)(EventId >> 28);
 8006b34:	7155      	strb	r5, [r2, #5]
        *--pStartPacket = (U8)((EventId >> 21) | 0x80);
 8006b36:	f882 e004 	strb.w	lr, [r2, #4]
        *--pStartPacket = (U8)(EventId | 0x80);
 8006b3a:	f801 7f01 	strb.w	r7, [r1, #1]!
 8006b3e:	e74f      	b.n	80069e0 <SEGGER_SYSVIEW_RecordVoid+0x44>
 8006b40:	20001a1c 	.word	0x20001a1c
 8006b44:	20001934 	.word	0x20001934
 8006b48:	20001939 	.word	0x20001939
 8006b4c:	e0001000 	.word	0xe0001000
 8006b50:	2000193b 	.word	0x2000193b
 8006b54:	2000188c 	.word	0x2000188c

08006b58 <SEGGER_SYSVIEW_PrintfTarget>:
*    the host.
*
*  Parameters
*    s        - String to be formatted.
*/
void SEGGER_SYSVIEW_PrintfTarget(const char* s, ...) {
 8006b58:	b40f      	push	{r0, r1, r2, r3}
 8006b5a:	b500      	push	{lr}
 8006b5c:	b083      	sub	sp, #12
 8006b5e:	ab04      	add	r3, sp, #16
 8006b60:	f853 0b04 	ldr.w	r0, [r3], #4
  va_list ParamList;

  va_start(ParamList, s);
  _VPrintTarget(s, SEGGER_SYSVIEW_LOG, &ParamList);
 8006b64:	2100      	movs	r1, #0
 8006b66:	aa01      	add	r2, sp, #4
  va_start(ParamList, s);
 8006b68:	9301      	str	r3, [sp, #4]
  _VPrintTarget(s, SEGGER_SYSVIEW_LOG, &ParamList);
 8006b6a:	f7ff f9cd 	bl	8005f08 <_VPrintTarget>
  va_end(ParamList);
}
 8006b6e:	b003      	add	sp, #12
 8006b70:	f85d eb04 	ldr.w	lr, [sp], #4
 8006b74:	b004      	add	sp, #16
 8006b76:	4770      	bx	lr

08006b78 <SEGGER_SYSVIEW_Warn>:
*    Print a warning string to the host.
*
*  Parameters
*    s        - String to sent.
*/
void SEGGER_SYSVIEW_Warn(const char* s) {
 8006b78:	b538      	push	{r3, r4, r5, lr}
  U8* pPayload;
  U8* pPayloadStart;
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32 + SEGGER_SYSVIEW_MAX_STRING_LEN);
 8006b7a:	f3ef 8511 	mrs	r5, BASEPRI
 8006b7e:	f04f 0120 	mov.w	r1, #32
 8006b82:	f381 8811 	msr	BASEPRI, r1
  if (pText == NULL) {
 8006b86:	b1e8      	cbz	r0, 8006bc4 <SEGGER_SYSVIEW_Warn+0x4c>
 8006b88:	4602      	mov	r2, r0
 8006b8a:	4910      	ldr	r1, [pc, #64]	@ (8006bcc <SEGGER_SYSVIEW_Warn+0x54>)
 8006b8c:	f100 0c80 	add.w	ip, r0, #128	@ 0x80
 8006b90:	e003      	b.n	8006b9a <SEGGER_SYSVIEW_Warn+0x22>
    while ((Limit-- > 0) && (*pText != '\0')) {
 8006b92:	4562      	cmp	r2, ip
      *pPayload++ = *pText++;
 8006b94:	f801 4b01 	strb.w	r4, [r1], #1
    while ((Limit-- > 0) && (*pText != '\0')) {
 8006b98:	d012      	beq.n	8006bc0 <SEGGER_SYSVIEW_Warn+0x48>
 8006b9a:	7814      	ldrb	r4, [r2, #0]
 8006b9c:	4613      	mov	r3, r2
 8006b9e:	3201      	adds	r2, #1
 8006ba0:	2c00      	cmp	r4, #0
 8006ba2:	d1f6      	bne.n	8006b92 <SEGGER_SYSVIEW_Warn+0x1a>
    *pLen = (U8)(pText - sStart);
 8006ba4:	1a1b      	subs	r3, r3, r0
 8006ba6:	b2db      	uxtb	r3, r3
  //
  pPayload = _EncodeStr(pPayloadStart, s, SEGGER_SYSVIEW_MAX_STRING_LEN);
  ENCODE_U32(pPayload, SEGGER_SYSVIEW_WARNING);
 8006ba8:	2401      	movs	r4, #1
    *pPayload++ = (U8)0;
 8006baa:	4809      	ldr	r0, [pc, #36]	@ (8006bd0 <SEGGER_SYSVIEW_Warn+0x58>)
  ENCODE_U32(pPayload, 0);
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_PRINT_FORMATTED);
 8006bac:	221a      	movs	r2, #26
    *pPayload++ = (U8)0;
 8006bae:	f800 3f07 	strb.w	r3, [r0, #7]!
  ENCODE_U32(pPayload, SEGGER_SYSVIEW_WARNING);
 8006bb2:	f821 4b02 	strh.w	r4, [r1], #2
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_PRINT_FORMATTED);
 8006bb6:	f7fe fc31 	bl	800541c <_SendPacket>
  RECORD_END();
 8006bba:	f385 8811 	msr	BASEPRI, r5
}
 8006bbe:	bd38      	pop	{r3, r4, r5, pc}
      *pPayload++ = *pText++;
 8006bc0:	4613      	mov	r3, r2
 8006bc2:	e7ef      	b.n	8006ba4 <SEGGER_SYSVIEW_Warn+0x2c>
 8006bc4:	4603      	mov	r3, r0
    *pPayload++ = (U8)0;
 8006bc6:	4901      	ldr	r1, [pc, #4]	@ (8006bcc <SEGGER_SYSVIEW_Warn+0x54>)
 8006bc8:	e7ee      	b.n	8006ba8 <SEGGER_SYSVIEW_Warn+0x30>
 8006bca:	bf00      	nop
 8006bcc:	2000193c 	.word	0x2000193c
 8006bd0:	20001934 	.word	0x20001934

08006bd4 <SEGGER_SYSVIEW_IsStarted>:
*
*  Return value
*      0: Recording not started.
*    > 0: Recording started.
*/
int SEGGER_SYSVIEW_IsStarted(void) {
 8006bd4:	b538      	push	{r3, r4, r5, lr}
#if (SEGGER_SYSVIEW_POST_MORTEM_MODE != 1)
  //
  // Check if host is sending data which needs to be processed.
  //
  if (SEGGER_RTT_HASDATA(CHANNEL_ID_DOWN)) {
 8006bd6:	4c0b      	ldr	r4, [pc, #44]	@ (8006c04 <SEGGER_SYSVIEW_IsStarted+0x30>)
 8006bd8:	4b0b      	ldr	r3, [pc, #44]	@ (8006c08 <SEGGER_SYSVIEW_IsStarted+0x34>)
 8006bda:	7e22      	ldrb	r2, [r4, #24]
 8006bdc:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 8006be0:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8006be4:	6eda      	ldr	r2, [r3, #108]	@ 0x6c
 8006be6:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8006be8:	429a      	cmp	r2, r3
 8006bea:	d001      	beq.n	8006bf0 <SEGGER_SYSVIEW_IsStarted+0x1c>
    if (_SYSVIEW_Globals.RecursionCnt == 0) {   // Avoid uncontrolled nesting. This way, this routine can call itself once, but no more often than that.
 8006bec:	78a5      	ldrb	r5, [r4, #2]
 8006bee:	b10d      	cbz	r5, 8006bf4 <SEGGER_SYSVIEW_IsStarted+0x20>
      _SYSVIEW_Globals.RecursionCnt = 0;
    }
  }
#endif
  return _SYSVIEW_Globals.EnableState;
}
 8006bf0:	7820      	ldrb	r0, [r4, #0]
 8006bf2:	bd38      	pop	{r3, r4, r5, pc}
      _SYSVIEW_Globals.RecursionCnt = 1;
 8006bf4:	2301      	movs	r3, #1
 8006bf6:	70a3      	strb	r3, [r4, #2]
      _HandleIncomingPacket();
 8006bf8:	f7fe fb86 	bl	8005308 <_HandleIncomingPacket>
      _SYSVIEW_Globals.RecursionCnt = 0;
 8006bfc:	70a5      	strb	r5, [r4, #2]
}
 8006bfe:	7820      	ldrb	r0, [r4, #0]
 8006c00:	bd38      	pop	{r3, r4, r5, pc}
 8006c02:	bf00      	nop
 8006c04:	20001a1c 	.word	0x20001a1c
 8006c08:	2000188c 	.word	0x2000188c

08006c0c <memcmp>:
 8006c0c:	b510      	push	{r4, lr}
 8006c0e:	3901      	subs	r1, #1
 8006c10:	4402      	add	r2, r0
 8006c12:	4290      	cmp	r0, r2
 8006c14:	d101      	bne.n	8006c1a <memcmp+0xe>
 8006c16:	2000      	movs	r0, #0
 8006c18:	e005      	b.n	8006c26 <memcmp+0x1a>
 8006c1a:	7803      	ldrb	r3, [r0, #0]
 8006c1c:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 8006c20:	42a3      	cmp	r3, r4
 8006c22:	d001      	beq.n	8006c28 <memcmp+0x1c>
 8006c24:	1b18      	subs	r0, r3, r4
 8006c26:	bd10      	pop	{r4, pc}
 8006c28:	3001      	adds	r0, #1
 8006c2a:	e7f2      	b.n	8006c12 <memcmp+0x6>

08006c2c <memset>:
 8006c2c:	4603      	mov	r3, r0
 8006c2e:	4402      	add	r2, r0
 8006c30:	4293      	cmp	r3, r2
 8006c32:	d100      	bne.n	8006c36 <memset+0xa>
 8006c34:	4770      	bx	lr
 8006c36:	f803 1b01 	strb.w	r1, [r3], #1
 8006c3a:	e7f9      	b.n	8006c30 <memset+0x4>

08006c3c <_reclaim_reent>:
 8006c3c:	4b2d      	ldr	r3, [pc, #180]	@ (8006cf4 <_reclaim_reent+0xb8>)
 8006c3e:	b570      	push	{r4, r5, r6, lr}
 8006c40:	681b      	ldr	r3, [r3, #0]
 8006c42:	4604      	mov	r4, r0
 8006c44:	4283      	cmp	r3, r0
 8006c46:	d053      	beq.n	8006cf0 <_reclaim_reent+0xb4>
 8006c48:	69c3      	ldr	r3, [r0, #28]
 8006c4a:	b31b      	cbz	r3, 8006c94 <_reclaim_reent+0x58>
 8006c4c:	68db      	ldr	r3, [r3, #12]
 8006c4e:	b163      	cbz	r3, 8006c6a <_reclaim_reent+0x2e>
 8006c50:	2500      	movs	r5, #0
 8006c52:	69e3      	ldr	r3, [r4, #28]
 8006c54:	68db      	ldr	r3, [r3, #12]
 8006c56:	5959      	ldr	r1, [r3, r5]
 8006c58:	b9b1      	cbnz	r1, 8006c88 <_reclaim_reent+0x4c>
 8006c5a:	3504      	adds	r5, #4
 8006c5c:	2d80      	cmp	r5, #128	@ 0x80
 8006c5e:	d1f8      	bne.n	8006c52 <_reclaim_reent+0x16>
 8006c60:	69e3      	ldr	r3, [r4, #28]
 8006c62:	4620      	mov	r0, r4
 8006c64:	68d9      	ldr	r1, [r3, #12]
 8006c66:	f000 f87b 	bl	8006d60 <_free_r>
 8006c6a:	69e3      	ldr	r3, [r4, #28]
 8006c6c:	6819      	ldr	r1, [r3, #0]
 8006c6e:	b111      	cbz	r1, 8006c76 <_reclaim_reent+0x3a>
 8006c70:	4620      	mov	r0, r4
 8006c72:	f000 f875 	bl	8006d60 <_free_r>
 8006c76:	69e3      	ldr	r3, [r4, #28]
 8006c78:	689d      	ldr	r5, [r3, #8]
 8006c7a:	b15d      	cbz	r5, 8006c94 <_reclaim_reent+0x58>
 8006c7c:	4629      	mov	r1, r5
 8006c7e:	4620      	mov	r0, r4
 8006c80:	682d      	ldr	r5, [r5, #0]
 8006c82:	f000 f86d 	bl	8006d60 <_free_r>
 8006c86:	e7f8      	b.n	8006c7a <_reclaim_reent+0x3e>
 8006c88:	680e      	ldr	r6, [r1, #0]
 8006c8a:	4620      	mov	r0, r4
 8006c8c:	f000 f868 	bl	8006d60 <_free_r>
 8006c90:	4631      	mov	r1, r6
 8006c92:	e7e1      	b.n	8006c58 <_reclaim_reent+0x1c>
 8006c94:	6961      	ldr	r1, [r4, #20]
 8006c96:	b111      	cbz	r1, 8006c9e <_reclaim_reent+0x62>
 8006c98:	4620      	mov	r0, r4
 8006c9a:	f000 f861 	bl	8006d60 <_free_r>
 8006c9e:	69e1      	ldr	r1, [r4, #28]
 8006ca0:	b111      	cbz	r1, 8006ca8 <_reclaim_reent+0x6c>
 8006ca2:	4620      	mov	r0, r4
 8006ca4:	f000 f85c 	bl	8006d60 <_free_r>
 8006ca8:	6b21      	ldr	r1, [r4, #48]	@ 0x30
 8006caa:	b111      	cbz	r1, 8006cb2 <_reclaim_reent+0x76>
 8006cac:	4620      	mov	r0, r4
 8006cae:	f000 f857 	bl	8006d60 <_free_r>
 8006cb2:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 8006cb4:	b111      	cbz	r1, 8006cbc <_reclaim_reent+0x80>
 8006cb6:	4620      	mov	r0, r4
 8006cb8:	f000 f852 	bl	8006d60 <_free_r>
 8006cbc:	6ba1      	ldr	r1, [r4, #56]	@ 0x38
 8006cbe:	b111      	cbz	r1, 8006cc6 <_reclaim_reent+0x8a>
 8006cc0:	4620      	mov	r0, r4
 8006cc2:	f000 f84d 	bl	8006d60 <_free_r>
 8006cc6:	6ca1      	ldr	r1, [r4, #72]	@ 0x48
 8006cc8:	b111      	cbz	r1, 8006cd0 <_reclaim_reent+0x94>
 8006cca:	4620      	mov	r0, r4
 8006ccc:	f000 f848 	bl	8006d60 <_free_r>
 8006cd0:	6c61      	ldr	r1, [r4, #68]	@ 0x44
 8006cd2:	b111      	cbz	r1, 8006cda <_reclaim_reent+0x9e>
 8006cd4:	4620      	mov	r0, r4
 8006cd6:	f000 f843 	bl	8006d60 <_free_r>
 8006cda:	6ae1      	ldr	r1, [r4, #44]	@ 0x2c
 8006cdc:	b111      	cbz	r1, 8006ce4 <_reclaim_reent+0xa8>
 8006cde:	4620      	mov	r0, r4
 8006ce0:	f000 f83e 	bl	8006d60 <_free_r>
 8006ce4:	6a23      	ldr	r3, [r4, #32]
 8006ce6:	b11b      	cbz	r3, 8006cf0 <_reclaim_reent+0xb4>
 8006ce8:	4620      	mov	r0, r4
 8006cea:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 8006cee:	4718      	bx	r3
 8006cf0:	bd70      	pop	{r4, r5, r6, pc}
 8006cf2:	bf00      	nop
 8006cf4:	20000034 	.word	0x20000034

08006cf8 <__libc_init_array>:
 8006cf8:	b570      	push	{r4, r5, r6, lr}
 8006cfa:	2600      	movs	r6, #0
 8006cfc:	4d0c      	ldr	r5, [pc, #48]	@ (8006d30 <__libc_init_array+0x38>)
 8006cfe:	4c0d      	ldr	r4, [pc, #52]	@ (8006d34 <__libc_init_array+0x3c>)
 8006d00:	1b64      	subs	r4, r4, r5
 8006d02:	10a4      	asrs	r4, r4, #2
 8006d04:	42a6      	cmp	r6, r4
 8006d06:	d109      	bne.n	8006d1c <__libc_init_array+0x24>
 8006d08:	f000 f87e 	bl	8006e08 <_init>
 8006d0c:	2600      	movs	r6, #0
 8006d0e:	4d0a      	ldr	r5, [pc, #40]	@ (8006d38 <__libc_init_array+0x40>)
 8006d10:	4c0a      	ldr	r4, [pc, #40]	@ (8006d3c <__libc_init_array+0x44>)
 8006d12:	1b64      	subs	r4, r4, r5
 8006d14:	10a4      	asrs	r4, r4, #2
 8006d16:	42a6      	cmp	r6, r4
 8006d18:	d105      	bne.n	8006d26 <__libc_init_array+0x2e>
 8006d1a:	bd70      	pop	{r4, r5, r6, pc}
 8006d1c:	f855 3b04 	ldr.w	r3, [r5], #4
 8006d20:	4798      	blx	r3
 8006d22:	3601      	adds	r6, #1
 8006d24:	e7ee      	b.n	8006d04 <__libc_init_array+0xc>
 8006d26:	f855 3b04 	ldr.w	r3, [r5], #4
 8006d2a:	4798      	blx	r3
 8006d2c:	3601      	adds	r6, #1
 8006d2e:	e7f2      	b.n	8006d16 <__libc_init_array+0x1e>
 8006d30:	08006f7c 	.word	0x08006f7c
 8006d34:	08006f7c 	.word	0x08006f7c
 8006d38:	08006f7c 	.word	0x08006f7c
 8006d3c:	08006f80 	.word	0x08006f80

08006d40 <__retarget_lock_acquire_recursive>:
 8006d40:	4770      	bx	lr

08006d42 <__retarget_lock_release_recursive>:
 8006d42:	4770      	bx	lr

08006d44 <memcpy>:
 8006d44:	440a      	add	r2, r1
 8006d46:	4291      	cmp	r1, r2
 8006d48:	f100 33ff 	add.w	r3, r0, #4294967295
 8006d4c:	d100      	bne.n	8006d50 <memcpy+0xc>
 8006d4e:	4770      	bx	lr
 8006d50:	b510      	push	{r4, lr}
 8006d52:	f811 4b01 	ldrb.w	r4, [r1], #1
 8006d56:	4291      	cmp	r1, r2
 8006d58:	f803 4f01 	strb.w	r4, [r3, #1]!
 8006d5c:	d1f9      	bne.n	8006d52 <memcpy+0xe>
 8006d5e:	bd10      	pop	{r4, pc}

08006d60 <_free_r>:
 8006d60:	b538      	push	{r3, r4, r5, lr}
 8006d62:	4605      	mov	r5, r0
 8006d64:	2900      	cmp	r1, #0
 8006d66:	d040      	beq.n	8006dea <_free_r+0x8a>
 8006d68:	f851 3c04 	ldr.w	r3, [r1, #-4]
 8006d6c:	1f0c      	subs	r4, r1, #4
 8006d6e:	2b00      	cmp	r3, #0
 8006d70:	bfb8      	it	lt
 8006d72:	18e4      	addlt	r4, r4, r3
 8006d74:	f000 f83c 	bl	8006df0 <__malloc_lock>
 8006d78:	4a1c      	ldr	r2, [pc, #112]	@ (8006dec <_free_r+0x8c>)
 8006d7a:	6813      	ldr	r3, [r2, #0]
 8006d7c:	b933      	cbnz	r3, 8006d8c <_free_r+0x2c>
 8006d7e:	6063      	str	r3, [r4, #4]
 8006d80:	6014      	str	r4, [r2, #0]
 8006d82:	4628      	mov	r0, r5
 8006d84:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8006d88:	f000 b838 	b.w	8006dfc <__malloc_unlock>
 8006d8c:	42a3      	cmp	r3, r4
 8006d8e:	d908      	bls.n	8006da2 <_free_r+0x42>
 8006d90:	6820      	ldr	r0, [r4, #0]
 8006d92:	1821      	adds	r1, r4, r0
 8006d94:	428b      	cmp	r3, r1
 8006d96:	bf01      	itttt	eq
 8006d98:	6819      	ldreq	r1, [r3, #0]
 8006d9a:	685b      	ldreq	r3, [r3, #4]
 8006d9c:	1809      	addeq	r1, r1, r0
 8006d9e:	6021      	streq	r1, [r4, #0]
 8006da0:	e7ed      	b.n	8006d7e <_free_r+0x1e>
 8006da2:	461a      	mov	r2, r3
 8006da4:	685b      	ldr	r3, [r3, #4]
 8006da6:	b10b      	cbz	r3, 8006dac <_free_r+0x4c>
 8006da8:	42a3      	cmp	r3, r4
 8006daa:	d9fa      	bls.n	8006da2 <_free_r+0x42>
 8006dac:	6811      	ldr	r1, [r2, #0]
 8006dae:	1850      	adds	r0, r2, r1
 8006db0:	42a0      	cmp	r0, r4
 8006db2:	d10b      	bne.n	8006dcc <_free_r+0x6c>
 8006db4:	6820      	ldr	r0, [r4, #0]
 8006db6:	4401      	add	r1, r0
 8006db8:	1850      	adds	r0, r2, r1
 8006dba:	4283      	cmp	r3, r0
 8006dbc:	6011      	str	r1, [r2, #0]
 8006dbe:	d1e0      	bne.n	8006d82 <_free_r+0x22>
 8006dc0:	6818      	ldr	r0, [r3, #0]
 8006dc2:	685b      	ldr	r3, [r3, #4]
 8006dc4:	4408      	add	r0, r1
 8006dc6:	6010      	str	r0, [r2, #0]
 8006dc8:	6053      	str	r3, [r2, #4]
 8006dca:	e7da      	b.n	8006d82 <_free_r+0x22>
 8006dcc:	d902      	bls.n	8006dd4 <_free_r+0x74>
 8006dce:	230c      	movs	r3, #12
 8006dd0:	602b      	str	r3, [r5, #0]
 8006dd2:	e7d6      	b.n	8006d82 <_free_r+0x22>
 8006dd4:	6820      	ldr	r0, [r4, #0]
 8006dd6:	1821      	adds	r1, r4, r0
 8006dd8:	428b      	cmp	r3, r1
 8006dda:	bf01      	itttt	eq
 8006ddc:	6819      	ldreq	r1, [r3, #0]
 8006dde:	685b      	ldreq	r3, [r3, #4]
 8006de0:	1809      	addeq	r1, r1, r0
 8006de2:	6021      	streq	r1, [r4, #0]
 8006de4:	6063      	str	r3, [r4, #4]
 8006de6:	6054      	str	r4, [r2, #4]
 8006de8:	e7cb      	b.n	8006d82 <_free_r+0x22>
 8006dea:	bd38      	pop	{r3, r4, r5, pc}
 8006dec:	20001f88 	.word	0x20001f88

08006df0 <__malloc_lock>:
 8006df0:	4801      	ldr	r0, [pc, #4]	@ (8006df8 <__malloc_lock+0x8>)
 8006df2:	f7ff bfa5 	b.w	8006d40 <__retarget_lock_acquire_recursive>
 8006df6:	bf00      	nop
 8006df8:	20001f84 	.word	0x20001f84

08006dfc <__malloc_unlock>:
 8006dfc:	4801      	ldr	r0, [pc, #4]	@ (8006e04 <__malloc_unlock+0x8>)
 8006dfe:	f7ff bfa0 	b.w	8006d42 <__retarget_lock_release_recursive>
 8006e02:	bf00      	nop
 8006e04:	20001f84 	.word	0x20001f84

08006e08 <_init>:
 8006e08:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8006e0a:	bf00      	nop
 8006e0c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8006e0e:	bc08      	pop	{r3}
 8006e10:	469e      	mov	lr, r3
 8006e12:	4770      	bx	lr

08006e14 <_fini>:
 8006e14:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8006e16:	bf00      	nop
 8006e18:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8006e1a:	bc08      	pop	{r3}
 8006e1c:	469e      	mov	lr, r3
 8006e1e:	4770      	bx	lr
